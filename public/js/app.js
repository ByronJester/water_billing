/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@inertiajs/inertia-vue/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@inertiajs/inertia-vue/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var t=e(__webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js")),r=e(__webpack_require__(/*! lodash.isequal */ "./node_modules/lodash.isequal/index.js")),n=e(__webpack_require__(/*! lodash.clonedeep */ "./node_modules/lodash.clonedeep/index.js")),i=__webpack_require__(/*! @inertiajs/inertia */ "./node_modules/@inertiajs/inertia/dist/index.js");function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e}).apply(this,arguments)}function s(){var e=[].slice.call(arguments),s="string"==typeof e[0]?e[0]:null,a=("string"==typeof e[0]?e[1]:e[0])||{},u=s?i.Inertia.restore(s):null,c=n(a),l=null,p=null,f=function(e){return e},d=t.observable(o({},u?u.data:a,{isDirty:!1,errors:u?u.errors:{},hasErrors:!1,processing:!1,progress:null,wasSuccessful:!1,recentlySuccessful:!1,data:function(){var e=this;return Object.keys(a).reduce(function(t,r){return t[r]=e[r],t},{})},transform:function(e){return f=e,this},reset:function(){var e=[].slice.call(arguments),t=n(c);return Object.assign(this,0===e.length?t:Object.keys(t).filter(function(t){return e.includes(t)}).reduce(function(e,r){return e[r]=t[r],e},{})),this},clearErrors:function(){var e=this,t=[].slice.call(arguments);return this.errors=Object.keys(this.errors).reduce(function(r,n){var i;return o({},r,t.length>0&&!t.includes(n)?((i={})[n]=e.errors[n],i):{})},{}),this.hasErrors=Object.keys(this.errors).length>0,this},submit:function(e,t,r){var s=this,a=this;void 0===r&&(r={});var u=f(this.data()),d=o({},r,{onCancelToken:function(e){if(l=e,r.onCancelToken)return r.onCancelToken(e)},onBefore:function(e){if(a.wasSuccessful=!1,a.recentlySuccessful=!1,clearTimeout(p),r.onBefore)return r.onBefore(e)},onStart:function(e){if(a.processing=!0,r.onStart)return r.onStart(e)},onProgress:function(e){if(a.progress=e,r.onProgress)return r.onProgress(e)},onSuccess:function(e){try{var t=function(e){return c=n(s.data()),s.isDirty=!1,e};return s.processing=!1,s.progress=null,s.clearErrors(),s.wasSuccessful=!0,s.recentlySuccessful=!0,p=setTimeout(function(){return s.recentlySuccessful=!1},2e3),Promise.resolve(r.onSuccess?Promise.resolve(r.onSuccess(e)).then(t):t(null))}catch(e){return Promise.reject(e)}},onError:function(e){if(a.processing=!1,a.progress=null,a.errors=e,a.hasErrors=!0,r.onError)return r.onError(e)},onCancel:function(){if(a.processing=!1,a.progress=null,r.onCancel)return r.onCancel()},onFinish:function(){if(a.processing=!1,a.progress=null,l=null,r.onFinish)return r.onFinish()}});"delete"===e?i.Inertia.delete(t,o({},d,{data:u})):i.Inertia[e](t,u,d)},get:function(e,t){this.submit("get",e,t)},post:function(e,t){this.submit("post",e,t)},put:function(e,t){this.submit("put",e,t)},patch:function(e,t){this.submit("patch",e,t)},delete:function(e,t){this.submit("delete",e,t)},cancel:function(){l&&l.cancel()},__rememberable:null===s,__remember:function(){return{data:this.data(),errors:this.errors}},__restore:function(e){Object.assign(this,e.data),Object.assign(this.errors,e.errors),this.hasErrors=Object.keys(this.errors).length>0}}));return new t({created:function(){this.$watch(function(){return d},function(e){d.isDirty=!r(d.data(),c),s&&i.Inertia.remember(e.__remember(),s)},{immediate:!0,deep:!0})}}),d}var a={props:{title:{type:String,required:!1}},data:function(){return{provider:this.$headManager.createProvider()}},beforeDestroy:function(){this.provider.disconnect()},methods:{isUnaryTag:function(e){return["area","base","br","col","embed","hr","img","input","keygen","link","meta","param","source","track","wbr"].indexOf(e.tag)>-1},renderTagStart:function(e){this.ensureNodeHasAttrs(e);var t=Object.keys(e.data.attrs).reduce(function(t,r){var n=e.data.attrs[r];return"head-key"===r?t:""===n?t+" "+r:t+" "+r+'="'+n+'"'},"");return"<"+e.tag+t+">"},renderTagChildren:function(e){var t=this;return e.children.reduce(function(e,r){return e+t.renderTag(r)},"")},renderTag:function(e){if(!e.tag)return e.text;var t=this.renderTagStart(e);return e.children&&(t+=this.renderTagChildren(e)),this.isUnaryTag(e)||(t+="</"+e.tag+">"),t},ensureNodeHasAttrs:function(e){e.data=o({},e.data||{},{attrs:o({},(e.data||{}).attrs||{})})},ensureNodeHasInertiaAttribute:function(e){return this.ensureNodeHasAttrs(e),e.data.attrs.inertia=void 0!==e.data.attrs["head-key"]?e.data.attrs["head-key"]:"",e},renderNode:function(e){return this.ensureNodeHasInertiaAttribute(e),this.renderTag(e)},renderNodes:function(e){var t=this,r=e.map(function(e){return t.renderNode(e)}).filter(function(e){return e});return this.title&&!r.find(function(e){return e.startsWith("<title")})&&r.push("<title inertia>"+this.title+"</title>"),r}},render:function(){this.provider.update(this.renderNodes(this.$scopedSlots.default?this.$scopedSlots.default():[]))}},u={functional:!0,props:{as:{type:String,default:"a"},data:{type:Object,default:function(){return{}}},href:{type:String,required:!0},method:{type:String,default:"get"},replace:{type:Boolean,default:!1},preserveScroll:{type:Boolean,default:!1},preserveState:{type:Boolean,default:null},only:{type:Array,default:function(){return[]}},headers:{type:Object,default:function(){return{}}}},render:function(e,t){var r=t.props,n=t.data,s=t.children;n.on=o({click:function(){return{}},cancelToken:function(){return{}},start:function(){return{}},progress:function(){return{}},finish:function(){return{}},cancel:function(){return{}},success:function(){return{}},error:function(){return{}}},n.on||{});var a=r.as.toLowerCase(),u=r.method.toLowerCase(),c=i.mergeDataIntoQueryString(u,r.href,r.data),l=c[0],p=c[1];return"a"===a&&"get"!==u&&console.warn('Creating POST/PUT/PATCH/DELETE <a> links is discouraged as it causes "Open Link in New Tab/Window" accessibility issues.\n\nPlease specify a more appropriate element using the "as" attribute. For example:\n\n<inertia-link href="'+l+'" method="'+u+'" as="button">...</inertia-link>'),e(r.as,o({},n,{attrs:o({},n.attrs,"a"===a?{href:l}:{}),on:o({},n.on,{click:function(e){var t;n.on.click(e),i.shouldIntercept(e)&&(e.preventDefault(),i.Inertia.visit(l,{data:p,method:u,replace:r.replace,preserveScroll:r.preserveScroll,preserveState:null!=(t=r.preserveState)?t:"get"!==u,only:r.only,headers:r.headers,onCancelToken:n.on.cancelToken,onBefore:n.on.before,onStart:n.on.start,onProgress:n.on.progress,onFinish:n.on.finish,onCancel:n.on.cancel,onSuccess:n.on.success,onError:n.on.error}))}})}),s)}},c={created:function(){var e=this;if(this.$options.remember&&!this.$isServer){Array.isArray(this.$options.remember)&&(this.$options.remember={data:this.$options.remember}),"string"==typeof this.$options.remember&&(this.$options.remember={data:[this.$options.remember]}),"string"==typeof this.$options.remember.data&&(this.$options.remember={data:[this.$options.remember.data]});var t=this.$options.remember.key instanceof Function?this.$options.remember.key.call(this):this.$options.remember.key,r=i.Inertia.restore(t),n=this.$options.remember.data.filter(function(t){return!(null!==e[t]&&"object"==typeof e[t]&&!1===e[t].__rememberable)}),s=function(t){return null!==e[t]&&"object"==typeof e[t]&&"function"==typeof e[t].__remember&&"function"==typeof e[t].__restore};n.forEach(function(a){void 0!==e[a]&&void 0!==r&&void 0!==r[a]&&(s(a)?e[a].__restore(r[a]):e[a]=r[a]),e.$watch(a,function(){i.Inertia.remember(n.reduce(function(t,r){var n;return o({},t,((n={})[r]=s(r)?e[r].__remember():e[r],n))},{}),t)},{immediate:!0,deep:!0})})}}},l={},p=null,f={name:"Inertia",props:{initialPage:{type:Object,required:!0},initialComponent:{type:Object,required:!1},resolveComponent:{type:Function,required:!1},onHeadUpdate:{type:Function,required:!1,default:function(){return function(){}}}},data:function(){return{component:this.initialComponent||null,page:this.initialPage,key:null}},created:function(){var e=this;l=this,p=i.createHeadManager(this.$isServer,this.onHeadUpdate),this.$isServer||i.Inertia.init({initialPage:this.initialPage,resolveComponent:this.resolveComponent,swapComponent:function(t){var r=t.component,n=t.page,i=t.preserveState;try{return e.component=r,e.page=n,e.key=i?e.key:Date.now(),Promise.resolve()}catch(e){return Promise.reject(e)}}})},render:function(e){var t=this;if(this.component){var r=e(this.component,{key:this.key,props:this.page.props,scopedSlots:this.$scopedSlots});return this.component.layout?"function"==typeof this.component.layout?this.component.layout(e,r):Array.isArray(this.component.layout)?this.component.layout.concat(r).reverse().reduce(function(r,n){return e(n,{props:t.$page.props},[r])}):e(this.component.layout,{props:this.page.props},[r]):r}},install:function(e){console.warn('Registering the Inertia Vue plugin via the "app" component has been deprecated. Use the new "plugin" named export instead.\n\nimport { plugin } from \'@inertiajs/inertia-vue\'\n\nVue.use(plugin)'),d.install(e)}},d={install:function(e){i.Inertia.form=s,e.mixin(c),e.component("InertiaHead",a),e.component("InertiaLink",u),e.mixin({beforeCreate:function(){Object.defineProperty(this,"$headManager",{get:function(){return p}}),Object.defineProperty(this,"$inertia",{get:function(){return i.Inertia}}),Object.defineProperty(this,"$page",{get:function(){return l.page}})}})}};exports.App=f,exports.InertiaApp=f,exports.InertiaLink=u,exports.Link=u,exports.app=f,exports.createInertiaApp=function(e){try{var r,n,i,o,s,a;n=void 0===(r=e.id)?"app":r,i=e.resolve,o=e.setup,s=e.page,a=e.render;var u="undefined"==typeof window,c=u?null:document.getElementById(n),l=s||JSON.parse(c.dataset.page),p=function(e){return Promise.resolve(i(e)).then(function(e){return e.default||e})};t.use(d);var h=[];return Promise.resolve(p(l.component).then(function(e){return o({el:c,app:f,props:{attrs:{id:n,"data-page":JSON.stringify(l)},props:{initialPage:l,initialComponent:e,resolveComponent:p,onHeadUpdate:u?function(e){return h=e}:null}}})})).then(function(e){if(u)return a(e).then(function(e){return{head:h,body:e}})})}catch(e){return Promise.reject(e)}},exports.link=u,exports.plugin=d;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@inertiajs/inertia/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@inertiajs/inertia/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var t=e(__webpack_require__(/*! axios */ "./node_modules/axios/index.js")),n=__webpack_require__(/*! qs */ "./node_modules/qs/lib/index.js"),i=e(__webpack_require__(/*! deepmerge */ "./node_modules/deepmerge/dist/cjs.js"));function r(){return(r=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e}).apply(this,arguments)}var o,s={modal:null,listener:null,show:function(e){var t=this;"object"==typeof e&&(e="All Inertia requests must receive a valid Inertia response, however a plain JSON response was received.<hr>"+JSON.stringify(e));var n=document.createElement("html");n.innerHTML=e,n.querySelectorAll("a").forEach(function(e){return e.setAttribute("target","_top")}),this.modal=document.createElement("div"),this.modal.style.position="fixed",this.modal.style.width="100vw",this.modal.style.height="100vh",this.modal.style.padding="50px",this.modal.style.boxSizing="border-box",this.modal.style.backgroundColor="rgba(0, 0, 0, .6)",this.modal.style.zIndex=2e5,this.modal.addEventListener("click",function(){return t.hide()});var i=document.createElement("iframe");if(i.style.backgroundColor="white",i.style.borderRadius="5px",i.style.width="100%",i.style.height="100%",this.modal.appendChild(i),document.body.prepend(this.modal),document.body.style.overflow="hidden",!i.contentWindow)throw new Error("iframe not yet ready.");i.contentWindow.document.open(),i.contentWindow.document.write(n.outerHTML),i.contentWindow.document.close(),this.listener=this.hideOnEscape.bind(this),document.addEventListener("keydown",this.listener)},hide:function(){this.modal.outerHTML="",this.modal=null,document.body.style.overflow="visible",document.removeEventListener("keydown",this.listener)},hideOnEscape:function(e){27===e.keyCode&&this.hide()}};function a(e,t){var n;return function(){var i=arguments,r=this;clearTimeout(n),n=setTimeout(function(){return e.apply(r,[].slice.call(i))},t)}}function c(e,t,n){for(var i in void 0===t&&(t=new FormData),void 0===n&&(n=null),e=e||{})Object.prototype.hasOwnProperty.call(e,i)&&d(t,l(n,i),e[i]);return t}function l(e,t){return e?e+"["+t+"]":t}function d(e,t,n){return n instanceof Date?e.append(t,n.toISOString()):n instanceof File?e.append(t,n,n.name):n instanceof Blob?e.append(t,n):"boolean"==typeof n?e.append(t,n?"1":"0"):"string"==typeof n?e.append(t,n):"number"==typeof n?e.append(t,""+n):null==n?e.append(t,""):void c(n,e,t)}function u(e){return new URL(e.toString(),window.location.toString())}function h(e,t,r){var o=t.toString().includes("http"),s=o||t.toString().startsWith("/"),a=!s&&!t.toString().startsWith("#")&&!t.toString().startsWith("?"),c=t.toString().includes("?")||e===exports.Method.GET&&Object.keys(r).length,l=t.toString().includes("#"),d=new URL(t.toString(),"http://localhost");return e===exports.Method.GET&&Object.keys(r).length&&(d.search=n.stringify(i(n.parse(d.search,{ignoreQueryPrefix:!0}),r),{encodeValuesOnly:!0,arrayFormat:"brackets"}),r={}),[[o?d.protocol+"//"+d.host:"",s?d.pathname:"",a?d.pathname.substring(1):"",c?d.search:"",l?d.hash:""].join(""),r]}function p(e){return(e=new URL(e.href)).hash="",e}function f(e,t){return document.dispatchEvent(new CustomEvent("inertia:"+e,t))}function v(e){return f("finish",{detail:{visit:e}})}function m(e){return f("navigate",{detail:{page:e}})}(o=exports.Method||(exports.Method={})).GET="get",o.POST="post",o.PUT="put",o.PATCH="patch",o.DELETE="delete";var g=function(){function e(){this.visitId=null}var n=e.prototype;return n.init=function(e){var t=e.resolveComponent,n=e.swapComponent;this.page=e.initialPage,this.resolveComponent=t,this.swapComponent=n,this.handleInitialPageVisit(),this.setupEventListeners()},n.handleInitialPageVisit=function(){this.isBackForwardVisit()?this.handleBackForwardVisit(this.page):this.isLocationVisit()?this.handleLocationVisit(this.page):(this.page.url+=window.location.hash,this.setPage(this.page,{preserveState:!0})),m(this.page)},n.setupEventListeners=function(){window.addEventListener("popstate",this.handlePopstateEvent.bind(this)),document.addEventListener("scroll",a(this.handleScrollEvent.bind(this),100),!0)},n.scrollRegions=function(){return document.querySelectorAll("[scroll-region]")},n.handleScrollEvent=function(e){"function"==typeof e.target.hasAttribute&&e.target.hasAttribute("scroll-region")&&this.saveScrollPositions()},n.saveScrollPositions=function(){this.replaceState(r({},this.page,{scrollRegions:Array.from(this.scrollRegions()).map(function(e){return{top:e.scrollTop,left:e.scrollLeft}})}))},n.resetScrollPositions=function(){var e;document.documentElement.scrollTop=0,document.documentElement.scrollLeft=0,this.scrollRegions().forEach(function(e){e.scrollTop=0,e.scrollLeft=0}),this.saveScrollPositions(),window.location.hash&&(null==(e=document.getElementById(window.location.hash.slice(1)))||e.scrollIntoView())},n.restoreScrollPositions=function(){var e=this;this.page.scrollRegions&&this.scrollRegions().forEach(function(t,n){t.scrollTop=e.page.scrollRegions[n].top,t.scrollLeft=e.page.scrollRegions[n].left})},n.isBackForwardVisit=function(){return window.history.state&&window.performance&&window.performance.getEntriesByType("navigation").length>0&&"back_forward"===window.performance.getEntriesByType("navigation")[0].type},n.handleBackForwardVisit=function(e){var t=this;window.history.state.version=e.version,this.setPage(window.history.state,{preserveScroll:!0,preserveState:!0}).then(function(){t.restoreScrollPositions()})},n.locationVisit=function(e,t){try{window.sessionStorage.setItem("inertiaLocationVisit",JSON.stringify({preserveScroll:t})),window.location.href=e.href,p(window.location).href===p(e).href&&window.location.reload()}catch(e){return!1}},n.isLocationVisit=function(){try{return null!==window.sessionStorage.getItem("inertiaLocationVisit")}catch(e){return!1}},n.handleLocationVisit=function(e){var t,n,i,r,o=this,s=JSON.parse(window.sessionStorage.getItem("inertiaLocationVisit")||"");window.sessionStorage.removeItem("inertiaLocationVisit"),e.url+=window.location.hash,e.rememberedState=null!=(t=null==(n=window.history.state)?void 0:n.rememberedState)?t:{},e.scrollRegions=null!=(i=null==(r=window.history.state)?void 0:r.scrollRegions)?i:[],this.setPage(e,{preserveScroll:s.preserveScroll,preserveState:!0}).then(function(){s.preserveScroll&&o.restoreScrollPositions()})},n.isLocationVisitResponse=function(e){return e&&409===e.status&&e.headers["x-inertia-location"]},n.isInertiaResponse=function(e){return null==e?void 0:e.headers["x-inertia"]},n.createVisitId=function(){return this.visitId={},this.visitId},n.cancelVisit=function(e,t){var n=t.cancelled,i=void 0!==n&&n,r=t.interrupted,o=void 0!==r&&r;!e||e.completed||e.cancelled||e.interrupted||(e.cancelToken.cancel(),e.onCancel(),e.completed=!1,e.cancelled=i,e.interrupted=o,v(e),e.onFinish(e))},n.finishVisit=function(e){e.cancelled||e.interrupted||(e.completed=!0,e.cancelled=!1,e.interrupted=!1,v(e),e.onFinish(e))},n.resolvePreserveOption=function(e,t){return"function"==typeof e?e(t):"errors"===e?Object.keys(t.props.errors||{}).length>0:e},n.visit=function(e,n){var i=this,o=void 0===n?{}:n,a=o.method,l=void 0===a?exports.Method.GET:a,d=o.data,v=void 0===d?{}:d,m=o.replace,g=void 0!==m&&m,w=o.preserveScroll,S=void 0!==w&&w,y=o.preserveState,b=void 0!==y&&y,E=o.only,P=void 0===E?[]:E,I=o.headers,x=void 0===I?{}:I,V=o.errorBag,T=void 0===V?"":V,L=o.forceFormData,O=void 0!==L&&L,C=o.onCancelToken,M=void 0===C?function(){}:C,k=o.onBefore,R=void 0===k?function(){}:k,j=o.onStart,F=void 0===j?function(){}:j,A=o.onProgress,D=void 0===A?function(){}:A,B=o.onFinish,N=void 0===B?function(){}:B,H=o.onCancel,q=void 0===H?function(){}:H,W=o.onSuccess,G=void 0===W?function(){}:W,U=o.onError,X=void 0===U?function(){}:U,J="string"==typeof e?u(e):e;if(!function e(t){return t instanceof File||t instanceof Blob||t instanceof FileList||t instanceof FormData&&Array.from(t.values()).some(function(t){return e(t)})||"object"==typeof t&&null!==t&&void 0!==Object.values(t).find(function(t){return e(t)})}(v)&&!O||v instanceof FormData||(v=c(v)),!(v instanceof FormData)){var K=h(l,J,v),_=K[1];J=u(K[0]),v=_}var z={url:J,method:l,data:v,replace:g,preserveScroll:S,preserveState:b,only:P,headers:x,errorBag:T,forceFormData:O,cancelled:!1,completed:!1,interrupted:!1};if(!1!==R(z)&&function(e){return f("before",{cancelable:!0,detail:{visit:e}})}(z)){this.activeVisit&&this.cancelVisit(this.activeVisit,{interrupted:!0}),this.saveScrollPositions();var Q=this.createVisitId();this.activeVisit=r({},z,{onCancelToken:M,onBefore:R,onStart:F,onProgress:D,onFinish:N,onCancel:q,onSuccess:G,onError:X,cancelToken:t.CancelToken.source()}),M({cancel:function(){i.activeVisit&&i.cancelVisit(i.activeVisit,{cancelled:!0})}}),function(e){f("start",{detail:{visit:e}})}(z),F(z),t({method:l,url:p(J).href,data:l===exports.Method.GET?{}:v,params:l===exports.Method.GET?v:{},cancelToken:this.activeVisit.cancelToken.token,headers:r({},x,{Accept:"text/html, application/xhtml+xml","X-Requested-With":"XMLHttpRequest","X-Inertia":!0},P.length?{"X-Inertia-Partial-Component":this.page.component,"X-Inertia-Partial-Data":P.join(",")}:{},T&&T.length?{"X-Inertia-Error-Bag":T}:{},this.page.version?{"X-Inertia-Version":this.page.version}:{}),onUploadProgress:function(e){v instanceof FormData&&(e.percentage=Math.round(e.loaded/e.total*100),function(e){f("progress",{detail:{progress:e}})}(e),D(e))}}).then(function(e){var t;if(!i.isInertiaResponse(e))return Promise.reject({response:e});var n=e.data;P.length&&n.component===i.page.component&&(n.props=r({},i.page.props,n.props)),S=i.resolvePreserveOption(S,n),(b=i.resolvePreserveOption(b,n))&&null!=(t=window.history.state)&&t.rememberedState&&n.component===i.page.component&&(n.rememberedState=window.history.state.rememberedState);var o=J,s=u(n.url);return o.hash&&!s.hash&&p(o).href===s.href&&(s.hash=o.hash,n.url=s.href),i.setPage(n,{visitId:Q,replace:g,preserveScroll:S,preserveState:b})}).then(function(){var e=i.page.props.errors||{};if(Object.keys(e).length>0){var t=T?e[T]?e[T]:{}:e;return function(e){f("error",{detail:{errors:e}})}(t),X(t)}return f("success",{detail:{page:i.page}}),G(i.page)}).catch(function(e){if(i.isInertiaResponse(e.response))return i.setPage(e.response.data,{visitId:Q});if(i.isLocationVisitResponse(e.response)){var t=u(e.response.headers["x-inertia-location"]),n=J;n.hash&&!t.hash&&p(n).href===t.href&&(t.hash=n.hash),i.locationVisit(t,!0===S)}else{if(!e.response)return Promise.reject(e);f("invalid",{cancelable:!0,detail:{response:e.response}})&&s.show(e.response.data)}}).then(function(){i.activeVisit&&i.finishVisit(i.activeVisit)}).catch(function(e){if(!t.isCancel(e)){var n=f("exception",{cancelable:!0,detail:{exception:e}});if(i.activeVisit&&i.finishVisit(i.activeVisit),n)return Promise.reject(e)}})}},n.setPage=function(e,t){var n=this,i=void 0===t?{}:t,r=i.visitId,o=void 0===r?this.createVisitId():r,s=i.replace,a=void 0!==s&&s,c=i.preserveScroll,l=void 0!==c&&c,d=i.preserveState,h=void 0!==d&&d;return Promise.resolve(this.resolveComponent(e.component)).then(function(t){o===n.visitId&&(e.scrollRegions=e.scrollRegions||[],e.rememberedState=e.rememberedState||{},(a=a||u(e.url).href===window.location.href)?n.replaceState(e):n.pushState(e),n.swapComponent({component:t,page:e,preserveState:h}).then(function(){l||n.resetScrollPositions(),a||m(e)}))})},n.pushState=function(e){this.page=e,window.history.pushState(e,"",e.url)},n.replaceState=function(e){this.page=e,window.history.replaceState(e,"",e.url)},n.handlePopstateEvent=function(e){var t=this;if(null!==e.state){var n=e.state,i=this.createVisitId();Promise.resolve(this.resolveComponent(n.component)).then(function(e){i===t.visitId&&(t.page=n,t.swapComponent({component:e,page:n,preserveState:!1}).then(function(){t.restoreScrollPositions(),m(n)}))})}else{var o=u(this.page.url);o.hash=window.location.hash,this.replaceState(r({},this.page,{url:o.href})),this.resetScrollPositions()}},n.get=function(e,t,n){return void 0===t&&(t={}),void 0===n&&(n={}),this.visit(e,r({},n,{method:exports.Method.GET,data:t}))},n.reload=function(e){return void 0===e&&(e={}),this.visit(window.location.href,r({},e,{preserveScroll:!0,preserveState:!0}))},n.replace=function(e,t){var n;return void 0===t&&(t={}),console.warn("Inertia.replace() has been deprecated and will be removed in a future release. Please use Inertia."+(null!=(n=t.method)?n:"get")+"() instead."),this.visit(e,r({preserveState:!0},t,{replace:!0}))},n.post=function(e,t,n){return void 0===t&&(t={}),void 0===n&&(n={}),this.visit(e,r({preserveState:!0},n,{method:exports.Method.POST,data:t}))},n.put=function(e,t,n){return void 0===t&&(t={}),void 0===n&&(n={}),this.visit(e,r({preserveState:!0},n,{method:exports.Method.PUT,data:t}))},n.patch=function(e,t,n){return void 0===t&&(t={}),void 0===n&&(n={}),this.visit(e,r({preserveState:!0},n,{method:exports.Method.PATCH,data:t}))},n.delete=function(e,t){return void 0===t&&(t={}),this.visit(e,r({preserveState:!0},t,{method:exports.Method.DELETE}))},n.remember=function(e,t){var n;void 0===t&&(t="default"),this.replaceState(r({},this.page,{rememberedState:r({},this.page.rememberedState,(n={},n[t]=e,n))}))},n.restore=function(e){var t,n;return void 0===e&&(e="default"),null==(t=window.history.state)||null==(n=t.rememberedState)?void 0:n[e]},n.on=function(e,t){var n=function(e){var n=t(e);e.cancelable&&!e.defaultPrevented&&!1===n&&e.preventDefault()};return document.addEventListener("inertia:"+e,n),function(){return document.removeEventListener("inertia:"+e,n)}},e}(),w={buildDOMElement:function(e){var t=document.createElement("template");t.innerHTML=e;var n=t.content.firstChild;if(!e.startsWith("<script "))return n;var i=document.createElement("script");return i.innerHTML=n.innerHTML,n.getAttributeNames().forEach(function(e){i.setAttribute(e,n.getAttribute(e)||"")}),i},isInertiaManagedElement:function(e){return e.nodeType===Node.ELEMENT_NODE&&null!==e.getAttribute("inertia")},findMatchingElementIndex:function(e,t){var n=e.getAttribute("inertia");return null!==n?t.findIndex(function(e){return e.getAttribute("inertia")===n}):-1},update:a(function(e){var t=this,n=e.map(function(e){return t.buildDOMElement(e)});Array.from(document.head.childNodes).filter(function(e){return t.isInertiaManagedElement(e)}).forEach(function(e){var i=t.findMatchingElementIndex(e,n);if(-1!==i){var r,o=n.splice(i,1)[0];o&&!e.isEqualNode(o)&&(null==e||null==(r=e.parentNode)||r.replaceChild(o,e))}else{var s;null==e||null==(s=e.parentNode)||s.removeChild(e)}}),n.forEach(function(e){return document.head.appendChild(e)})},1)},S=new g;exports.Inertia=S,exports.createHeadManager=function(e,t){var n={},i=0;function r(){var e=Object.values(n).reduce(function(e,t){return e.concat(t)},[]).reduce(function(e,t){if(-1===t.indexOf("<"))return e;if(0===t.indexOf("<title "))return e.title=t,e;var n=t.match(/ inertia="[^"]+"/);return n?e[n[0]]=t:e[Object.keys(e).length]=t,e},{});return Object.values(e)}function o(){e?t(r()):w.update(r())}return{createProvider:function(){var e=function(){var e=i+=1;return n[e]=[],e.toString()}();return{disconnect:function(){return function(e){null!==e&&-1!==Object.keys(n).indexOf(e)&&(delete n[e],o())}(e)},update:function(t){return function(e,t){void 0===t&&(t=[]),null!==e&&Object.keys(n).indexOf(e)>-1&&(n[e]=t),o()}(e,t)}}}}},exports.hrefToUrl=u,exports.mergeDataIntoQueryString=h,exports.shouldIntercept=function(e){var t="a"===e.currentTarget.tagName.toLowerCase();return!(e.target&&null!=e&&e.target.isContentEditable||e.defaultPrevented||t&&e.which>1||t&&e.altKey||t&&e.ctrlKey||t&&e.metaKey||t&&e.shiftKey)},exports.urlWithoutHash=p;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/@inertiajs/progress/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@inertiajs/progress/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var n,e=(n=__webpack_require__(/*! nprogress */ "./node_modules/nprogress/nprogress.js"))&&"object"==typeof n&&"default"in n?n.default:n,t=null;function r(n){document.addEventListener("inertia:start",o.bind(null,n)),document.addEventListener("inertia:progress",i),document.addEventListener("inertia:finish",s)}function o(n){t=setTimeout(function(){return e.start()},n)}function i(n){e.isStarted()&&n.detail.progress.percentage&&e.set(Math.max(e.status,n.detail.progress.percentage/100*.9))}function s(n){clearTimeout(t),e.isStarted()&&(n.detail.visit.completed?e.done():n.detail.visit.interrupted?e.set(0):n.detail.visit.cancelled&&(e.done(),e.remove()))}exports.InertiaProgress={init:function(n){var t=void 0===n?{}:n,o=t.delay,i=t.color,s=void 0===i?"#29d":i,a=t.includeCSS,p=void 0===a||a,d=t.showSpinner,l=void 0!==d&&d;r(void 0===o?250:o),e.configure({showSpinner:l}),p&&function(n){var e=document.createElement("style");e.type="text/css",e.textContent="\n    #nprogress {\n      pointer-events: none;\n    }\n\n    #nprogress .bar {\n      background: "+n+";\n\n      position: fixed;\n      z-index: 1031;\n      top: 0;\n      left: 0;\n\n      width: 100%;\n      height: 2px;\n    }\n\n    #nprogress .peg {\n      display: block;\n      position: absolute;\n      right: 0px;\n      width: 100px;\n      height: 100%;\n      box-shadow: 0 0 10px "+n+", 0 0 5px "+n+";\n      opacity: 1.0;\n\n      -webkit-transform: rotate(3deg) translate(0px, -4px);\n          -ms-transform: rotate(3deg) translate(0px, -4px);\n              transform: rotate(3deg) translate(0px, -4px);\n    }\n\n    #nprogress .spinner {\n      display: block;\n      position: fixed;\n      z-index: 1031;\n      top: 15px;\n      right: 15px;\n    }\n\n    #nprogress .spinner-icon {\n      width: 18px;\n      height: 18px;\n      box-sizing: border-box;\n\n      border: solid 2px transparent;\n      border-top-color: "+n+";\n      border-left-color: "+n+";\n      border-radius: 50%;\n\n      -webkit-animation: nprogress-spinner 400ms linear infinite;\n              animation: nprogress-spinner 400ms linear infinite;\n    }\n\n    .nprogress-custom-parent {\n      overflow: hidden;\n      position: relative;\n    }\n\n    .nprogress-custom-parent #nprogress .spinner,\n    .nprogress-custom-parent #nprogress .bar {\n      position: absolute;\n    }\n\n    @-webkit-keyframes nprogress-spinner {\n      0%   { -webkit-transform: rotate(0deg); }\n      100% { -webkit-transform: rotate(360deg); }\n    }\n    @keyframes nprogress-spinner {\n      0%   { transform: rotate(0deg); }\n      100% { transform: rotate(360deg); }\n    }\n  ",document.head.appendChild(e)}(s)}};
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");
var enhanceError = __webpack_require__(/*! ./core/enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var pkg = __webpack_require__(/*! ./../../package.json */ "./node_modules/axios/package.json");

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');

/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */
function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}

/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ "./node_modules/axios/package.json":
/*!*****************************************!*\
  !*** ./node_modules/axios/package.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Table.vue?vue&type=script&lang=js&":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Table.vue?vue&type=script&lang=js& ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ['rows', 'columns', 'keys', 'selected'],
  data: function data() {
    return {};
  },
  methods: {
    selectItem: function selectItem(arg) {
      this.$emit('update:selected', arg);
    }
  },
  mounted: function mounted() {}
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Toggle.vue?vue&type=script&lang=js&":
/*!*************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Toggle.vue?vue&type=script&lang=js& ***!
  \*************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _inertiajs_inertia__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @inertiajs/inertia */ "./node_modules/@inertiajs/inertia/dist/index.js");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ['value', 'url', 'id'],
  methods: {
    toggle: function toggle() {
      this.$emit('value', !this.value);
      _inertiajs_inertia__WEBPACK_IMPORTED_MODULE_0__.Inertia.post(this.$root.route + this.url, {
        is_active: !this.value,
        id: this.id
      }, {
        onSuccess: function onSuccess(res) {
          location.reload();
        },
        onError: function onError(err) {}
      });
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Layouts/Navigation.vue?vue&type=script&lang=js&":
/*!**************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Layouts/Navigation.vue?vue&type=script&lang=js& ***!
  \**************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _inertiajs_inertia__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @inertiajs/inertia */ "./node_modules/@inertiajs/inertia/dist/index.js");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ['auth'],
  data: function data() {
    return {
      leftPanel: '3%',
      rightPanel: '97%',
      active: window.location.pathname
    };
  },
  created: function created() {},
  methods: {
    logout: function logout() {
      _inertiajs_inertia__WEBPACK_IMPORTED_MODULE_0__.Inertia.post(this.$root.route + "/users/logout", {}, {
        onSuccess: function onSuccess(res) {},
        orError: function orError(err) {}
      });
    },
    changeActive: function changeActive(arg) {
      _inertiajs_inertia__WEBPACK_IMPORTED_MODULE_0__.Inertia.get(this.$root.route + arg, {
        onSuccess: function onSuccess() {}
      });
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Bill.vue?vue&type=script&lang=js&":
/*!******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Bill.vue?vue&type=script&lang=js& ***!
  \******************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _inertiajs_inertia__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @inertiajs/inertia */ "./node_modules/@inertiajs/inertia/dist/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  data: function data() {
    return {
      form: {
        reference: null,
        amount: 0
      },
      saveError: null
    };
  },
  methods: {
    logout: function logout() {
      _inertiajs_inertia__WEBPACK_IMPORTED_MODULE_0__.Inertia.post(this.$root.route + "/users/logout", {}, {
        onSuccess: function onSuccess(res) {},
        orError: function orError(err) {}
      });
    },
    generateBill: function generateBill() {
      var _this = this;

      axios__WEBPACK_IMPORTED_MODULE_1___default().post(this.$root.route + "/bills/generate", this.form).then(function (response) {
        if (response.data.status == 422) {
          _this.saveError = response.data.errors;
        } else {
          _this.form = {
            reference: null,
            amount: 0
          };
          alert("Successfully generate bill.");
          _this.saveError = null;
          location.reload();
        }
      });
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Client.vue?vue&type=script&lang=js&":
/*!********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Client.vue?vue&type=script&lang=js& ***!
  \********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layouts_Navigation_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Layouts/Navigation.vue */ "./resources/js/Layouts/Navigation.vue");
/* harmony import */ var _inertiajs_inertia__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @inertiajs/inertia */ "./node_modules/@inertiajs/inertia/dist/index.js");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ['auth', 'options'],
  components: {
    Navigation: _Layouts_Navigation_vue__WEBPACK_IMPORTED_MODULE_0__.default
  },
  data: function data() {
    return {
      client: null
    };
  },
  mounted: function mounted() {
    console.log(this.options);
    this.client = this.options.client;
  },
  methods: {
    back: function back() {
      _inertiajs_inertia__WEBPACK_IMPORTED_MODULE_1__.Inertia.get(this.$root.route + '/clients', {
        onSuccess: function onSuccess() {}
      });
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Clients.vue?vue&type=script&lang=js&":
/*!*********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Clients.vue?vue&type=script&lang=js& ***!
  \*********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layouts_Navigation_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Layouts/Navigation.vue */ "./resources/js/Layouts/Navigation.vue");
/* harmony import */ var _Components_Table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Components/Table */ "./resources/js/Components/Table.vue");
/* harmony import */ var _inertiajs_inertia__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @inertiajs/inertia */ "./node_modules/@inertiajs/inertia/dist/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Components_Toggle_vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Components/Toggle.vue */ "./resources/js/Components/Toggle.vue");
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ['auth', 'options'],
  components: {
    Navigation: _Layouts_Navigation_vue__WEBPACK_IMPORTED_MODULE_0__.default,
    Table: _Components_Table__WEBPACK_IMPORTED_MODULE_1__.default,
    Toggle: _Components_Toggle_vue__WEBPACK_IMPORTED_MODULE_4__.default
  },
  data: function data() {
    return {
      columns: ['Name', 'Address', 'Line #'],
      keys: [{
        label: 'name'
      }, {
        label: 'address'
      }, {
        label: 'reference'
      }],
      clients: [],
      form: {
        name: null,
        address: null
      },
      saveError: null,
      client: null
    };
  },
  mounted: function mounted() {
    this.clients = this.options.clients;
  },
  watch: {
    client: function client(arg) {
      console.log(arg);
    }
  },
  methods: {
    createClient: function createClient() {
      var _this = this;

      var headers = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'HEAD, GET, POST, PUT, PATCH, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type'
      };
      axios__WEBPACK_IMPORTED_MODULE_3___default().post(this.$root.route + "/clients/client/create", this.form).then(function (response) {
        if (response.data.status == 422) {
          _this.saveError = response.data.errors;
        } else {
          _this.form = {
            name: null,
            address: null
          };
          alert("New connection successfully created.");
          _this.saveError = null;
          location.reload();
        }
      });
    },
    viewClient: function viewClient(arg) {
      _inertiajs_inertia__WEBPACK_IMPORTED_MODULE_2__.Inertia.get(this.$root.route + '/clients/' + arg, {
        onSuccess: function onSuccess() {}
      });
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Login.vue?vue&type=script&lang=js&":
/*!*******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Login.vue?vue&type=script&lang=js& ***!
  \*******************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _inertiajs_inertia__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @inertiajs/inertia */ "./node_modules/@inertiajs/inertia/dist/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ['message'],
  data: function data() {
    return {
      formloginData: {
        email: null,
        password: null
      },
      formRegisterData: {
        name: null,
        phone: null,
        email: null,
        password: null,
        confirm_password: null,
        role: 2,
        user_type: 'client',
        reference: null
      },
      isRegister: false,
      saveError: null,
      mobile: window.screen.width <= 400,
      isLogin: null,
      active: 'client'
    };
  },
  watch: {
    isRegister: function isRegister(arg) {
      this.saveError = null;
      this.message = null;
    }
  },
  mounted: function mounted() {},
  methods: {
    login: function login() {
      _inertiajs_inertia__WEBPACK_IMPORTED_MODULE_0__.Inertia.post(this.$root.route + "/users/login", this.formloginData, {
        onSuccess: function onSuccess(res) {},
        orError: function orError(err) {}
      });
    },
    disableButton: function disableButton() {
      if (!this.formloginData.email) {
        return true;
      }

      if (!this.formloginData.password) {
        return true;
      }

      return false;
    },
    register: function register() {
      var _this = this;

      axios__WEBPACK_IMPORTED_MODULE_1___default().post(this.$root.route + "/users/create-client-account", this.formRegisterData).then(function (response) {
        if (response.data.status == 422) {
          _this.saveError = response.data.errors;
        } else {
          _this.formRegisterData = {
            name: null,
            phone: null,
            email: null,
            password: null,
            confirm_password: null,
            role: 2,
            user_type: 'client',
            reference: null
          };
          alert("Account successfully created.");
          _this.saveError = null;
          _this.isRegister = false;
        }
      });
    },
    changeActive: function changeActive(arg) {
      this.active = arg;
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Users.vue?vue&type=script&lang=js&":
/*!*******************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Users.vue?vue&type=script&lang=js& ***!
  \*******************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Layouts_Navigation_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Layouts/Navigation.vue */ "./resources/js/Layouts/Navigation.vue");
/* harmony import */ var _Components_Table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Components/Table */ "./resources/js/Components/Table.vue");
/* harmony import */ var _Components_Toggle_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Components/Toggle.vue */ "./resources/js/Components/Toggle.vue");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_3__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ['auth', 'options'],
  components: {
    Navigation: _Layouts_Navigation_vue__WEBPACK_IMPORTED_MODULE_0__.default,
    Table: _Components_Table__WEBPACK_IMPORTED_MODULE_1__.default,
    Toggle: _Components_Toggle_vue__WEBPACK_IMPORTED_MODULE_2__.default
  },
  data: function data() {
    return {
      columns: ['Name', 'Email', 'Contact', 'User Type', 'Line #'],
      keys: [{
        label: 'name'
      }, {
        label: 'email'
      }, {
        label: 'phone'
      }, {
        label: 'user_type'
      }, {
        label: 'reference'
      }],
      users: [],
      user: null,
      newUser: false,
      formRegisterData: {
        name: null,
        phone: null,
        email: null,
        password: null,
        confirm_password: null,
        role: 1,
        user_type: 'staff'
      },
      saveError: null
    };
  },
  watch: {
    user: function user(arg) {}
  },
  mounted: function mounted() {
    this.users = this.options.users;
  },
  methods: {
    createAccount: function createAccount() {
      var _this = this;

      axios__WEBPACK_IMPORTED_MODULE_3___default().post(this.$root.route + "/users/create-account", this.formRegisterData).then(function (response) {
        if (response.data.status == 422) {
          _this.saveError = response.data.errors;
        } else {
          _this.formRegisterData = {
            name: null,
            phone: null,
            email: null,
            password: null,
            confirm_password: null,
            role: 1,
            user_type: 'staff'
          };
          alert("Account successfully created.");
          _this.saveError = null;
          location.reload();
        }
      });
    }
  }
});

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _inertiajs_inertia_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @inertiajs/inertia-vue */ "./node_modules/@inertiajs/inertia-vue/dist/index.js");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm.js");
/* harmony import */ var _inertiajs_progress__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @inertiajs/progress */ "./node_modules/@inertiajs/progress/dist/index.js");
/* harmony import */ var vue_graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue-graph */ "./node_modules/vue-graph/src/main.js");




_inertiajs_progress__WEBPACK_IMPORTED_MODULE_1__.InertiaProgress.init({
  // The delay after which the progress bar will
  // appear during navigation, in milliseconds.
  delay: 0,
  // The color of the progress bar.
  color: '#29d',
  // Whether to include the default NProgress styles.
  includeCSS: true,
  // Whether the NProgress spinner will be shown.
  showSpinner: true
});
_inertiajs_progress__WEBPACK_IMPORTED_MODULE_1__.InertiaProgress.init();
var app = document.getElementById('app');
vue__WEBPACK_IMPORTED_MODULE_3__.default.use(vue_graph__WEBPACK_IMPORTED_MODULE_2__.default);
vue__WEBPACK_IMPORTED_MODULE_3__.default.mixin({
  methods: {
    validationError: function validationError(field, errors) {
      if (errors) {
        if (errors.hasOwnProperty(field)) {
          return Array.isArray(errors[field]) ? errors[field][0] : errors[field];
        }
      }

      return null;
    }
  }
});
var pages = {
  'Login': __webpack_require__(/*! ./Pages/Login.vue */ "./resources/js/Pages/Login.vue").default,
  'Users': __webpack_require__(/*! ./Pages/Users.vue */ "./resources/js/Pages/Users.vue").default,
  'Clients': __webpack_require__(/*! ./Pages/Clients.vue */ "./resources/js/Pages/Clients.vue").default,
  'Client': __webpack_require__(/*! ./Pages/Client.vue */ "./resources/js/Pages/Client.vue").default,
  'Bill': __webpack_require__(/*! ./Pages/Bill.vue */ "./resources/js/Pages/Bill.vue").default
};
new vue__WEBPACK_IMPORTED_MODULE_3__.default({
  data: {
    route: window.location.protocol + '//' + window.location.host
  },
  render: function render(h) {
    return h(_inertiajs_inertia_vue__WEBPACK_IMPORTED_MODULE_0__.InertiaApp, {
      props: {
        initialPage: JSON.parse(app.dataset.page),
        resolveComponent: function resolveComponent(name) {
          return pages[name];
        }
      }
    });
  }
}).$mount(app);

/***/ }),

/***/ "./node_modules/call-bind/callBound.js":
/*!*********************************************!*\
  !*** ./node_modules/call-bind/callBound.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var callBind = __webpack_require__(/*! ./ */ "./node_modules/call-bind/index.js");

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
		return callBind(intrinsic);
	}
	return intrinsic;
};


/***/ }),

/***/ "./node_modules/call-bind/index.js":
/*!*****************************************!*\
  !*** ./node_modules/call-bind/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

module.exports = function callBind(originalFunction) {
	var func = $reflectApply(bind, $call, arguments);
	if ($gOPD && $defineProperty) {
		var desc = $gOPD(func, 'length');
		if (desc.configurable) {
			// original length, plus the receiver, minus any additional arguments (after the receiver)
			$defineProperty(
				func,
				'length',
				{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
			);
		}
	}
	return func;
};

var applyBind = function applyBind() {
	return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
	$defineProperty(module.exports, 'apply', { value: applyBind });
} else {
	module.exports.apply = applyBind;
}


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Table.vue?vue&type=style&index=0&id=67955193&scoped=true&lang=css&":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Table.vue?vue&type=style&index=0&id=67955193&scoped=true&lang=css& ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\ntable[data-v-67955193] {\r\n    border-collapse: collapse;\r\n    border-radius: 5px;\r\n    border-style: hidden;\r\n    box-shadow: 0 0 0 1px black;\n}\ntd[data-v-67955193] {\r\n    border: 1px solid black;\n}\nth[data-v-67955193] {\r\n    border: 1px solid black;\r\n    background: #3949AB;\r\n    color: white;\n}\n.--active__color[data-v-67955193] {\r\n    background: #B0BEC5;\n}\r\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Layouts/Navigation.vue?vue&type=style&index=0&id=5b807f98&scoped=true&lang=css&":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Layouts/Navigation.vue?vue&type=style&index=0&id=5b807f98&scoped=true&lang=css& ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.dropdown[data-v-5b807f98] {\r\n  position: relative;\r\n  display: inline-block;\n}\n.dropdown-content[data-v-5b807f98] {\r\n  display: none;\r\n  position: absolute;\r\n  background-color: #ffffff;\r\n  min-width: 130px;\r\n  z-index: 1;\r\n  border: 1px solid black;\r\n  border-radius: 5px;\r\n  left: -2.5rem;\n}\n.dropdown-content a[data-v-5b807f98] {\r\n  color: black;\r\n  text-decoration: none;\r\n  display: block;\n}\n.dropdown-content a[data-v-5b807f98]:hover {background-color: #2c85c1;}\n.dropdown:hover .dropdown-content[data-v-5b807f98] {display: block;}\n.--active[data-v-5b807f98] {\r\n    border-bottom: 2px solid black;\n}\r\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Bill.vue?vue&type=style&index=0&id=873580a0&scoped=true&lang=css&":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Bill.vue?vue&type=style&index=0&id=873580a0&scoped=true&lang=css& ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.--login__register--input[data-v-873580a0] {\r\n\theight: 40px;\r\n\tborder-radius: 10px;\r\n    border: 1px solid black;\n}\n.--login__register--button[data-v-873580a0] {\r\n\theight: 40px;\r\n\tborder-radius: 30px;\r\n\tbackground: #2C3333;\r\n\tcolor: white\n}\n.--logout--button[data-v-873580a0] {\r\n\theight: 40px;\r\n\tborder-radius: 30px;\r\n\tbackground: #303F9F;\r\n\tcolor: white\n}\r\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Clients.vue?vue&type=style&index=0&id=43a8cb22&scoped=true&lang=css&":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Clients.vue?vue&type=style&index=0&id=43a8cb22&scoped=true&lang=css& ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.--input[data-v-43a8cb22] {\r\n    width: 100%;\r\n    height: 30px;\r\n    border: 1px solid black;\r\n    border-radius: 5px;\r\n    text-align: center;\n}\n.--btn[data-v-43a8cb22] {\r\n    background: #2B4865;\r\n    border-radius: 10px;\r\n    width: 100%;\r\n    text-align: center;\r\n    color: white;\n}\r\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Login.vue?vue&type=style&index=0&id=0004d9e0&scoped=true&lang=css&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Login.vue?vue&type=style&index=0&id=0004d9e0&scoped=true&lang=css& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.--panel[data-v-0004d9e0] {\r\n\tbackground-image: url('/images/bg.jpg');\r\n\tbackground-repeat: no-repeat;\r\n \tbackground-size: 100vw 100vh;\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n\tjustify-content: center;\n}\n.--banner[data-v-0004d9e0] {\r\n\tbackground-image: url('/images/banner.png');\r\n\tbackground-repeat: no-repeat;\r\n \tbackground-size: 100% 100%;\n}\n.--login__register[data-v-0004d9e0] {\r\n\twidth: 380px;\r\n\theight: auto;\r\n\tbackground: #607EAA;\r\n\tborder-radius: 10px;\r\n\tposition: relative;\n}\n.--login__register--input[data-v-0004d9e0] {\r\n\theight: 40px;\r\n\tborder-radius: 10px;\n}\n.--login__register--button[data-v-0004d9e0] {\r\n\theight: 40px;\r\n\tborder-radius: 30px;\r\n\tbackground: #2C3333;\r\n\tcolor: white\n}\r\n\r\n\r\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Users.vue?vue&type=style&index=0&id=7bbfca2f&scoped=true&lang=css&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Users.vue?vue&type=style&index=0&id=7bbfca2f&scoped=true&lang=css& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, "\n.--login__register--input[data-v-7bbfca2f] {\r\n\theight: 40px;\r\n\tborder-radius: 10px;\r\n    border: 1px solid black;\n}\n.--login__register--button[data-v-7bbfca2f] {\r\n\theight: 40px;\r\n\tborder-radius: 30px;\r\n\tbackground: #2C3333;\r\n\tcolor: white\n}\r\n\r\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join("");
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === "string") {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, ""]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/deepmerge/dist/cjs.js":
/*!********************************************!*\
  !*** ./node_modules/deepmerge/dist/cjs.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";


var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return target.propertyIsEnumerable(symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

module.exports = deepmerge_1;


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/area.js":
/*!****************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/area.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var _line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line */ "./node_modules/juijs-chart/src/brush/line.js");



_main_js__WEBPACK_IMPORTED_MODULE_0__.default.use(_line__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.area",
    extend: "chart.brush.line",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");

        var AreaBrush = function() {
                this.drawArea = function(path) {
                    var g = this.chart.svg.group(),
                        y = this.axis.y(this.brush.startZero ? 0 : this.axis.y.min()),
                        opacity = (_.typeCheck("number", this.brush.opacity)) ? this.brush.opacity : this.chart.theme("areaBackgroundOpacity");

                    for(var k = 0; k < path.length; k++) {
                        var children = this.createLine(path[k], k).children;

                        for(var i = 0; i < children.length; i++) {
                            var p = children[i];

                            // opacity 옵션이 콜백함수 일때, 상위 클래스 설정을 따름.
                            if(_.typeCheck("function", this.brush.opacity)) {
                                opacity = p.attr("stroke-opacity");
                            }

                            if (path[k].length > 0) {
                                p.LineTo(p.attr("x2"), y);
                                p.LineTo(p.attr("x1"), y);
                                p.ClosePath();
                            }

                            p.attr({
                                fill: p.attr("stroke"),
                                "fill-opacity": opacity,
                                "stroke-width": 0
                            });

                            g.prepend(p);
                        }

                        if(this.brush.line) {
                            var p = this.createLine(path[k], k);
                            g.prepend(p);

                            this.addLineElement({
                                element: p,
                                tooltip: null
                            });

                            if(this.brush.display) {
                                this.createTooltip(g, path[k], k);
                            }
                        }

                        this.addEvent(g, null, k);
                    }

                    return g;
                }

                this.draw = function() {
                    return this.drawArea(this.getXY());
                }

                this.drawAnimate = function(root) {
                    root.append(
                        this.chart.svg.animate({
                            attributeName: "opacity",
                            from: "0",
                            to: "1",
                            begin: "0s" ,
                            dur: "1.5s",
                            repeatCount: "1",
                            fill: "freeze"
                        })
                    );
                }
            }

        AreaBrush.setup = function() {
            return {
                /** @cfg {"normal"/"curve"/"step"} [symbol="normal"] Sets the shape of a line (normal, curve, step). */
                symbol: "normal", // normal, curve, step
                /** @cfg {Number} [active=null] Activates the bar of an applicable index. */
                active: null,
                /** @cfg {String} [activeEvent=null]  Activates the bar in question when a configured event occurs (click, mouseover, etc). */
                activeEvent: null,
                /** @cfg {"max"/"min"} [display=null]  Shows a tool tip on the bar for the minimum/maximum value.  */
                display: null,
                /** @cfg {Boolean} [startZero=true]  The end of the area is zero point. */
                startZero: true,
                /** @cfg {Boolean} [line=true]  Visible line */
                line: true
            };
        }

        return AreaBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/bar.js":
/*!***************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/bar.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.bar",
    extend: "chart.brush.core",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");

        var BarBrush = function() {
            var g;
            var zeroX, height, half_height, bar_height;

            this.getBarStyle = function() {
                return {
                    borderColor: this.chart.theme("barBorderColor"),
                    borderWidth: this.chart.theme("barBorderWidth"),
                    borderOpacity: this.chart.theme("barBorderOpacity"),
                    borderRadius: this.chart.theme("barBorderRadius"),
                    disableOpacity: this.chart.theme("barDisableBackgroundOpacity"),
                    circleColor: this.chart.theme("barPointBorderColor")
                }
            }

            this.getBarElement = function(dataIndex, targetIndex, info) {
                var style = this.getBarStyle(),
                    color = this.color(dataIndex, targetIndex),
                    value = this.getData(dataIndex)[this.brush.target[targetIndex]];

                var r = this.chart.svg.pathRect({
                    width: info.width,
                    height: info.height,
                    fill : color,
                    stroke : style.borderColor,
                    "stroke-width" : style.borderWidth,
                    "stroke-opacity" : style.borderOpacity
                });

                if(value != 0) {
                    this.addEvent(r, dataIndex, targetIndex);
                }

                if(this.barList == null) {
                    this.barList = [];
                }

                this.barList.push(_.extend({
                    element: r,
                    color: color
                }, info));

                return r;
            }

            this.setActiveEffect = function(r) {
                var style = this.getBarStyle(),
                    cols = this.barList;

                for(var i = 0; i < cols.length; i++) {
                    var opacity = (cols[i] == r) ? 1 : style.disableOpacity;
                    cols[i].element.attr({ opacity: opacity });

                    if(cols[i].minmax) {
                        cols[i].minmax.style(cols[i].color, style.circleColor, opacity);
                    }
                }
            }

            this.drawBefore = function() {
                var op = this.brush.outerPadding,
                    ip = this.brush.innerPadding,
                    len = this.brush.target.length;

                g = this.chart.svg.group();
                zeroX = this.axis.x(0);
                height = this.axis.y.rangeBand();

                if(this.brush.size > 0) {
                    bar_height = this.brush.size;
                    half_height = (bar_height * len) + ((len - 1) * ip);
                } else {
                    half_height = height - (op * 2);
                    bar_height = (half_height - (len - 1) * ip) / len;
                    bar_height = (bar_height < 0) ? 0 : bar_height;
                }
            }

            this.drawETC = function(group) {
                if(!_.typeCheck("array", this.barList)) return;

                var self = this,
                    style = this.getBarStyle();

                // 액티브 툴팁 생성
                this.active = this.drawTooltip();
                group.append(this.active.tooltip);

                for(var i = 0; i < this.barList.length; i++) {
                    var r = this.barList[i],
                        d = this.brush.display;

                    // Max & Min 툴팁 생성
                    if((d == "max" && r.max) || (d == "min" && r.min) || d == "all") {
                        r.minmax = this.drawTooltip(r.color, style.circleColor, 1);
                        r.minmax.control(r.position, r.tooltipX, r.tooltipY, this.format(r.value));
                        group.append(r.minmax.tooltip);
                    }

                    // 컬럼 및 기본 브러쉬 이벤트 설정
                    if(r.value != 0 && this.brush.activeEvent != null) {
                        (function(bar) {
                            self.active.style(bar.color, style.circleColor, 1);

                            bar.element.on(self.brush.activeEvent, function(e) {
                                self.active.style(bar.color, style.circleColor, 1);
                                self.active.control(bar.position, bar.tooltipX, bar.tooltipY, self.format(bar.value));
                                self.setActiveEffect(bar);
                            });

                            bar.element.attr({ cursor: "pointer" });
                        })(r);
                    }
                }

                // 액티브 툴팁 위치 설정
                var r = this.barList[this.brush.active];
                if(r != null) {
                    this.active.style(r.color, style.circleColor, 1);
                    this.active.control(r.position, r.tooltipX, r.tooltipY, this.format(r.value));
                    this.setActiveEffect(r);
                }
            }

            this.draw = function() {
                var points = this.getXY(),
                    style = this.getBarStyle();

                this.eachData(function(data, i) {
                    var startY = this.offset("y", i) - (half_height / 2);

                    for(var j = 0; j < this.brush.target.length; j++) {
                        var value = data[this.brush.target[j]],
                            tooltipX = this.axis.x(value),
                            tooltipY = startY + (bar_height / 2),
                            position = (tooltipX >= zeroX) ? "right" : "left";

                        // 최소 크기 설정
                        if(Math.abs(zeroX - tooltipX) < this.brush.minSize) {
                            tooltipX = (position == "right") ? tooltipX + this.brush.minSize : tooltipX - this.brush.minSize;
                        }

                        var width = Math.abs(zeroX - tooltipX),
                            radius = (width < style.borderRadius || bar_height < style.borderRadius) ? 0 : style.borderRadius,
                            r = this.getBarElement(i, j, {
                                width: width,
                                height: bar_height,
                                value: value,
                                tooltipX: tooltipX,
                                tooltipY: tooltipY,
                                position: position,
                                max: points[j].max[i],
                                min: points[j].min[i]
                            });

                        if(tooltipX >= zeroX) {
                            r.round(width, bar_height, 0, radius, radius, 0);
                            r.translate(zeroX, startY);
                        } else {
                            r.round(width, bar_height, radius, 0, 0, radius);
                            r.translate(zeroX - width, startY);
                        }

                        // 그룹에 컬럼 엘리먼트 추가
                        g.append(r);

                        // 다음 컬럼 좌표 설정
                        startY += bar_height + this.brush.innerPadding;
                    }
                });

                this.drawETC(g);

                return g;
            }

            this.drawAnimate = function(root) {
                var svg = this.chart.svg,
                    type = this.brush.animate;

                root.append(
                    svg.animate({
                        attributeName: "opacity",
                        from: "0",
                        to: "1",
                        begin: "0s" ,
                        dur: "1.4s",
                        repeatCount: "1",
                        fill: "freeze"
                    })
                );

                root.each(function(i, elem) {
                    if(elem.is("util.svg.element.path")) {
                        var xy = elem.data("translate").split(","),
                            x = parseInt(xy[0]),
                            y = parseInt(xy[1]),
                            w = parseInt(elem.attr("width")),
                            start = (type == "right") ? x + w : x - w;

                        elem.append(svg.animateTransform({
                            attributeName: "transform",
                            type: "translate",
                            from: start + " " + y,
                            to: x + " " + y,
                            begin: "0s",
                            dur: "0.7s",
                            repeatCount: "1",
                            fill: "freeze"
                        }));
                    }
                });
            }
        }

        BarBrush.setup = function() {
            return {
                /** @cfg {Number} [size=0] Set a fixed size of the bar. */
                size: 0,
                /** @cfg {Number} [minSize=0] Sets the minimum size as it is not possible to draw a bar when the value is 0. */
                minSize: 0,
                /** @cfg {Number} [outerPadding=2] Determines the outer margin of a bar.  */
                outerPadding: 2,
                /** @cfg {Number} [innerPadding=1] Determines the inner margin of a bar. */
                innerPadding: 1,
                /** @cfg {Number} [active=null] Activates the bar of an applicable index. */
                active: null,
                /** @cfg {String} [activeEvent=null]  Activates the bar in question when a configured event occurs (click, mouseover, etc). */
                activeEvent: null,
                /** @cfg {"max"/"min"/"all"} [display=null]  Shows a tool tip on the bar for the minimum/maximum value.  */
                display: null,
                /** @cfg {Function} [format=null] Sets the format of the value that is displayed on the tool tip. */
                format: null
            };
        }

        return BarBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/bubble.js":
/*!******************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/bubble.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.bubble",
    extend: "chart.brush.core",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");
        var math = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.math");

        var BubbleBrush = function() {
            var self = this,
                min = null,
                max = null;

            this.getFormatText = function(value, dataIndex) {
                if(_.typeCheck("function", this.brush.format)) {
                    return this.format(this.axis.data[dataIndex]);
                }

                return value;
            }

            this.getBubbleRadius = function(value, dataIndex) {
                var scaleKey = this.brush.scaleKey;

                if(scaleKey != null) {
                    var scaleValue = this.axis.data[dataIndex][scaleKey];
                    value = (_.typeCheck("number", scaleValue)) ? scaleValue : value;
                }

                return math.scaleValue(value, min, max, this.brush.min, this.brush.max);
            }

            this.createBubble = function(pos, color, dataIndex) {
                var radius = this.getBubbleRadius(pos.value, dataIndex),
                    circle = this.svg.group().translate(pos.x, pos.y);

                circle.append(
                    this.svg.circle({
                        r: radius,
                        "fill": color,
                        "fill-opacity": this.chart.theme("bubbleBackgroundOpacity"),
                        "stroke": color,
                        "stroke-width": this.chart.theme("bubbleBorderWidth")
                    })
                );

                if(this.brush.showText) {
                    var text = this.getFormatText(pos.value, dataIndex);

                    circle.append(
                        this.chart.text({
                            "font-size": this.chart.theme("bubbleFontSize"),
                            fill: this.chart.theme("bubbleFontColor"),
                            "text-anchor": "middle",
                            dy: 3
                        }).text(text)
                    );
                }

                this.bubbleList.push(circle);

                return circle;
            }

            this.setActiveEffect = function(r) {
                var cols = this.bubbleList;

                for(var i = 0; i < cols.length; i++) {
                    var opacity = (cols[i] == r) ? 1 : this.chart.theme("bubbleBackgroundOpacity");

                    cols[i].get(0).attr({ opacity: opacity });
                    cols[i].get(1).attr({ opacity: opacity });
                }
            }

            this.drawBubble = function(points) {
                var g = this.svg.group();

                for(var i = 0; i < points.length; i++) {
                    for(var j = 0; j < points[i].x.length; j++) {
                        var b = this.createBubble({
                            x: points[i].x[j], y: points[i].y[j], value: points[i].value[j]
                        }, this.color(j, i), j);

                        // 컬럼 및 기본 브러쉬 이벤트 설정
                        if(this.brush.activeEvent != null) {
                            (function(bubble) {
                                bubble.on(self.brush.activeEvent, function(e) {
                                    self.setActiveEffect(bubble);
                                });

                                bubble.attr({ cursor: "pointer" });
                            })(b);
                        }

                        this.addEvent(b, j, i);
                        g.append(b);
                    }
                }

                // 액티브 버블 설정
                var bubble = this.bubbleList[this.brush.active];
                if(bubble != null) {
                    this.setActiveEffect(bubble);
                }

                return g;
            }

            this.drawBefore = function() {
                var scaleKey = this.brush.scaleKey;

                if(scaleKey != null) {
                    var values = [];

                    for (var i = 0; i < this.axis.data.length; i++) {
                        values.push(this.axis.data[i][scaleKey]);
                    }

                    min = Math.min.apply(this, values);
                    max = Math.max.apply(this, values);
                } else {
                    min = this.axis.y.min();
                    max = this.axis.y.max();
                }

                this.bubbleList = [];
            }

            this.draw = function() {
                return this.drawBubble(this.getXY());
            }

            this.drawAnimate = function(root) {
                root.each(function(i, elem) {
                    var c = elem.children[0];

                    c.append(self.svg.animateTransform({
                        attributeType: "xml",
                        attributeName: "transform",
                        type: "scale",
                        from: "0",
                        to: "1",
                        dur: "0.7s",
                        fill: "freeze",
                        repeatCount: "1"
                    }));

                    c.append(self.svg.animate({
                        attributeType: "xml",
                        attributeName: "fill-opacity",
                        from: "0",
                        to: self.chart.theme("bubbleBackgroundOpacity"),
                        dur: "1.4s",
                        repeatCount: "1",
                        fill: "freeze"
                    }));
                });
            }
        }

        BubbleBrush.setup = function() {
            return {
                /** @cfg {Number} [min=5] Determines the minimum size of a bubble. */
                min: 5,
                /** @cfg {Number} [max=30] Determines the maximum size of a bubble.*/
                max: 30,
                /** @cfg {String} [scaleKey=null] The name of the property to determine the bubble size. */
                scaleKey: null,
                /** @cfg {Boolean} [showText=false] Set the text appear. */
                showText: false,
                /** @cfg {Function} [format=null] Returns a value from the format callback function of a defined option. */
                format: null,
                /** @cfg {Number} [active=null] Activates the bar of an applicable index. */
                active: null,
                /** @cfg {String} [activeEvent=null]  Activates the bar in question when a configured event occurs (click, mouseover, etc). */
                activeEvent: null
            };
        }

        return BubbleBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/canvas/activebubble.js":
/*!*******************************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/canvas/activebubble.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../main.js */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var _base_mortalbubble_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base/mortalbubble.js */ "./node_modules/juijs-chart/src/brush/canvas/base/mortalbubble.js");



_main_js__WEBPACK_IMPORTED_MODULE_0__.default.use(_base_mortalbubble_js__WEBPACK_IMPORTED_MODULE_1__.default);

class ActiveBubble {
    constructor(renderContext, contextWidth, contextHeight, gravity) {
        this.renderContext = renderContext;
        this.contextWidth = contextWidth;
        this.contextHeight = contextHeight;

        this.gravity = gravity;
        this.data = []; // MortalBubble
        this.isArrange = false;
    }

    preCheck() {
        for (let i = 0; i < this.data.length; i++) {
            const bubble = this.data[i];
            if(!bubble.active) {
                this.data[i] = null;
                this.data.splice(i, 1);
            }
        }

        return this.data.length > 0;
    }

    draw() {
        if(!this.preCheck()) return;

        let collisions = [],
            dups = [];

        for (let i = 0; i < this.data.length; i++) {
            // force gravity
            const bubble = this.data[i];
            const gDirection = [1, 0];
            bubble.force([
                gDirection[0] * bubble.mass * this.gravity,
                gDirection[1] * bubble.mass * this.gravity,
            ]);

            bubble.update();
        }

        for (let i = 0; i < this.data.length; i++) {
            for (let j = 0; j < this.data.length; j++) {
                if (i == j) continue;
                const me = this.data[i];
                const other = this.data[j];
                const dist = me.distance(other);
                const radiusSum = me.radius + other.radius;
                if (radiusSum - dist > 1) {
                    collisions.push([me, other]);
                }
            }
        }

        if(collisions.length == 0) {
            this.isArrange = true;
        }

        for (let i = 0; i < collisions.length - 1; i++) {
            const me = collisions[i];
            for (let j = i + 1; j < collisions.length; j++) {
                const other = collisions[j];
                if (
                    (me[0] == other[0] && me[1] == other[1]) ||
                    (me[1] == other[0] && me[0] == other[1])
                ) {
                    dups.push(j);
                }
            }
        }

        for (let i = 0; i < collisions.length; i++) {
            if (dups.indexOf(i) != -1) continue;

            const collision = collisions[i];
            const me = collision[0];
            const other = collision[1];
            const radiusSum = me.radius + other.radius;
            const dist = me.distance(other);
            let normal = [other.pos[0] - me.pos[0], other.pos[1] - me.pos[1]];
            const len = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
            normal = [normal[0] / len, normal[1] / len];
            const size = radiusSum - dist;
            if (other.pos[0] == me.pos[0] && other.pos[1] == me.pos[1]) {
                normal = [0, -1];
            }

            me.pos = [
                -size / 2 * normal[0] + me.pos[0],
                -size / 2 * normal[1] + me.pos[1],
            ];

            other.pos = [
                size / 2 * normal[0] + other.pos[0],
                size / 2 * normal[1] + other.pos[1],
            ];

            // const c = 0.01;
            const meForce = [
                normal[0] * me.accel[0],
                normal[1] * me.accel[1],
            ];
            const otherForce = [
                normal[0] * other.accel[0],
                normal[1] * other.accel[1],
            ];

            if (me.pos[0] < other.pos[0]) {
                me.veloc = [me.veloc[0] * 0.7, me.veloc[1] * 0.99];
                me.force([-otherForce[0], -otherForce[1]]);
            } else {
                if(this.isArrange) {
                    me.veloc = [
                        other.pos[0] > me.pos[0] ? -1 : 1,
                        other.pos[1] > me.pos[1] ? -1 : 1
                    ];
                    me.force([-meForce[0], -meForce[1]]);
                }

                other.veloc = [other.veloc[0] * 0.7, other.veloc[1] * 0.99];
                other.force([-meForce[0], -meForce[1]]);
            }
        }

        const now = (new Date()).getTime();
        for (let i = 0; i < this.data.length; i++) {
            const me = this.data[i];

            if (me.pos[0] > this.contextWidth) {
                me.pos[0] = this.contextWidth;
            }
            if (me.pos[1] > this.contextHeight) {
                me.pos[1] = this.contextHeight;
            } else if (me.pos[1] < 0) {
                me.pos[1] = 0;
            }

            this.data[i].draw(this.renderContext, now);
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.canvas.activebubble",
    extend: "chart.brush.canvas.core",
    component: function () {
        const MortalBubble = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.canvas.base.mortalbubble");
        const ColorUtil = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.color");

        const CanvasActiveBubbleBrush = function() {
            function hexToRgba(color, opacity) {
                const rgb = ColorUtil.rgb(color);
                return `rgba(${rgb.r},${rgb.g},${rgb.b},${opacity})`;
            }

            this.drawBefore = function() {
                const activeBubbleCount = this.chart.getCache('active_bubble_count', 0);
                const dataCount = this.axis.data.length;

                if(this.chart.getCache('active_bubble') == null) {
                    this.chart.setCache( 'active_bubble', new ActiveBubble(
                        this.canvas, this.axis.area('width'), this.axis.area('height'), this.brush.gravity) )
                }

                if(activeBubbleCount != dataCount) {
                    const activeBubble = this.chart.getCache('active_bubble');
                    activeBubble.isArrange = false;

                    this.chart.setCache('active_bubble_count', dataCount);
                }
            }

            this.draw = function() {
                const activeBubble = this.chart.getCache('active_bubble');

                let index = 0;
                while(this.axis.data.length > 0) {
                    let color = this.color(index),
                        data = this.axis.data.shift(),
                        startTime = this.getValue(data, "startTime", Date.now()),
                        duration = this.getValue(data, "duration", 1000);

                    activeBubble.data.push(new MortalBubble(startTime, duration, this.brush.radius,
                        hexToRgba(color, this.brush.opacity), hexToRgba(color, 0.2)));
                    index++;
                }

                activeBubble.draw();
            }
        }

        CanvasActiveBubbleBrush.setup = function() {
            return {
                gravity: 0.2,
                radius: 20,
                opacity: 1
            }
        }

        return CanvasActiveBubbleBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/canvas/base/bubble.js":
/*!******************************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/canvas/base/bubble.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../main.js */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_graph_src_util_canvas_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! juijs-graph/src/util/canvas/base.js */ "./node_modules/juijs-graph/src/util/canvas/base.js");
/* harmony import */ var _kinetic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./kinetic */ "./node_modules/juijs-chart/src/brush/canvas/base/kinetic.js");




_main_js__WEBPACK_IMPORTED_MODULE_0__.default.use(juijs_graph_src_util_canvas_base_js__WEBPACK_IMPORTED_MODULE_1__.default, _kinetic__WEBPACK_IMPORTED_MODULE_2__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "util.canvas.base.bubble",
    extend: "util.canvas.base.kinetic",
    component: function () {
        const CanvasUtil = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.canvas.base");

        const Bubble = function(radius, text, color='#497eff', shadowColor='rgba(16,116,252,0.2)', textColor='#fff', textStyle='bold 11px Noto Sans KR') {
            this.mark = false;
            this.dim = false;
            this.radius = radius;
            this.text = text;
            this.color = color;
            this.shadowColor = shadowColor;
            this.textColor = textColor;

            this.draw = function(context, now) {
                if (this.dim)
                    context.globalAlpha = 0.5;

                context.shadowColor = this.shadowColor;
                context.shadowBlur = 10;
                context.shadowOffsetX = 0;
                context.shadowOffsetY = 10;

                const util = new CanvasUtil(context);
                util.drawCircle(this.pos[0], this.pos[1], this.radius, this.color);
                context.fillStyle = this.textColor;
                context.textAlign = 'center';
                context.font = textStyle;
                context.fillText(this.text, this.pos[0], this.pos[1] + 5);
                context.globalAlpha = 1.0;

            }
        }

        return Bubble;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/canvas/base/kinetic.js":
/*!*******************************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/canvas/base/kinetic.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "util.canvas.base.kinetic",
    extend: null,
    component: function () {
        const KineticObject = function() {
            this.mass = 10;
            this.friction = 0.1;
            this.pos = [0, 0];
            this.veloc = [0, 0];
            this.accel = [0, 0];

            this.force = function(f) {
                this.accel = [
                    this.accel[0] + f[0] / this.mass,
                    this.accel[1] + f[1] / this.mass,
                ];
            }

            this.accelScalar = function() {
                return Math.sqrt(this.accel[0] * this.accel[0] + this.accel[1] * this.accel[1])
            }

            this.velocScalar = function() {
                return Math.sqrt(this.veloc[0] * this.veloc[0] + this.veloc[1] * this.veloc[1])
            }

            this.velocityForce = function() {
                const xDir = this.veloc[0] < 0 ? -1 : 1;
                const yDir = this.veloc[1] < 0 ? -1 : 1;
                return [
                    xDir * 0.5 * this.mass * this.veloc[0] * this.veloc[0],
                    yDir * 0.5 * this.mass * this.veloc[1] * this.veloc[1],
                ];
            }

            this.distancePos = function(pos) {
                return Math.sqrt(
                    Math.pow(this.pos[0] - pos[0], 2) +
                    Math.pow(this.pos[1] - pos[1], 2)
                );
            }

            this.distance = function(other) {
                return this.distancePos(other.pos);
            }

            this.direction = function(pos) {
                const distance = this.distancePos(pos);
                if (distance == 0) return [0, 0];
                return [
                    (this.pos[0] - pos[0]) / distance,
                    (this.pos[1] - pos[1]) / distance,
                ];
            }

            this.speed = function() {
                return Math.sqrt(Math.pow(this.veloc[0], 2) + Math.pow(this.veloc[1], 2))
            }

            this.update = function() {
                this.veloc = [
                    this.veloc[0] + this.accel[0],
                    this.veloc[1] + this.accel[1],
                ];

                let x = this.pos[0];
                let y = this.pos[1];

                if (Math.abs(this.veloc[0]) > 2) {
                    x = this.pos[0] + this.veloc[0];
                }
                if (Math.abs(this.veloc[1]) > 2) {
                    y = this.pos[1] + this.veloc[1];
                }

                this.pos = [x, y];
                this.accel = [0, 0];
            }

            this.draw = function(context, n) {

            }
        }

        return KineticObject;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/canvas/base/mortalbubble.js":
/*!************************************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/canvas/base/mortalbubble.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../main.js */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_graph_src_util_canvas_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! juijs-graph/src/util/canvas/base.js */ "./node_modules/juijs-graph/src/util/canvas/base.js");
/* harmony import */ var _kinetic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./kinetic */ "./node_modules/juijs-chart/src/brush/canvas/base/kinetic.js");




_main_js__WEBPACK_IMPORTED_MODULE_0__.default.use(juijs_graph_src_util_canvas_base_js__WEBPACK_IMPORTED_MODULE_1__.default, _kinetic__WEBPACK_IMPORTED_MODULE_2__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "util.canvas.base.mortalbubble",
    extend: "util.canvas.base.kinetic",
    component: function () {
        const CanvasUtil = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.canvas.base");

        const MortalBubble = function(birthtime, age, radius=20, color='#497eff', shadowColor='rgba(16,116,252,0.2)') {
            this.active = true;
            this.birthtime = birthtime;
            this.age = age;
            this.radius = radius;
            this.color = color;
            this.shadowColor = shadowColor;
            this.force([30, 0]);

            this.draw = function(context, now) {
                context.shadowColor = this.shadowColor;
                context.shadowBlur = 10;
                context.shadowOffsetX = 0;
                context.shadowOffsetY = 10;

                const util = new CanvasUtil(context);
                const d = this.age - (now - this.birthtime);
                let radius = this.radius;
                let animSpeed = 3;

                if (d <= 0) {
                    this.active = false;
                    return;
                }

                if (d <= 100 * animSpeed) {
                    radius *= (100 * animSpeed - d) / (100 * animSpeed) + 1;
                }

                if (d <= 80 * animSpeed) {
                    const x = (80 * animSpeed - d) / (80 * animSpeed);
                    const sd = (radius / 3 - 2) * x + 2;
                    const ed = (radius / 3 - 2) * Math.sin(Math.PI / 2 * x) + 2;
                    const stroke = 3 * x + 2;
                    context.lineCap = 'round';
                    util.drawLine(
                        this.pos[0] + sd, this.pos[1],
                        this.pos[0] + ed, this.pos[1],
                        this.color, stroke
                    );
                    util.drawLine(
                        this.pos[0] - sd, this.pos[1],
                        this.pos[0] - ed, this.pos[1],
                        this.color, stroke
                    );
                    util.drawLine(
                        this.pos[0], this.pos[1] + sd,
                        this.pos[0], this.pos[1] + ed,
                        this.color, stroke
                    );
                    util.drawLine(
                        this.pos[0], this.pos[1] - sd,
                        this.pos[0], this.pos[1] - ed,
                        this.color, stroke
                    );
                    context.lineCap = 'butt';
                } else {
                    util.drawCircle(this.pos[0], this.pos[1], radius, this.color);
                }
            }
        }

        return MortalBubble;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/canvas/bubblecloud.js":
/*!******************************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/canvas/bubblecloud.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../main.js */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var _base_bubble_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base/bubble.js */ "./node_modules/juijs-chart/src/brush/canvas/base/bubble.js");



_main_js__WEBPACK_IMPORTED_MODULE_0__.default.use(_base_bubble_js__WEBPACK_IMPORTED_MODULE_1__.default);

class BubbleCloud {
    constructor(renderContext, contextWidth, contextHeight) {
        this.renderContext = renderContext;
        this.contextWidth = contextWidth;
        this.contextHeight = contextHeight;

        this.bubbles = {}; // [url: string]: Bubble<PopularPage>
        this.animationAlpha = 0.1;
        this.hoverBubble = null;
    }

    processData(nextData) {
        if (nextData == null) return;

        const Bubble = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.canvas.base.bubble");

        let count = nextData.reduce((a, b) => a + b.count, 0);
        let isChanged = false;

        for (const key in this.bubbles) this.bubbles[key].mark = false;

        const radiusSize = (c) => {
            let s = this.contextWidth > this.contextHeight ? this.contextHeight : this.contextWidth;
            return c / count * (s / 6) + 50;
        }

        nextData.forEach(e => {
            const bubble = this.bubbles[e.name];
            if (bubble == null) {
                let bubble = new Bubble(radiusSize(e.count), e.name, e.color, e.shadowColor, e.textColor, e.textStyle);
                bubble.data = e;
                bubble.mark = true;
                bubble.pos = [Math.random() * this.contextWidth, Math.random() * this.contextHeight];

                this.bubbles[e.name] = bubble;
                isChanged = true;
            } else {
                bubble.mark = true;
                const newRadius = radiusSize(e.count);

                if (Math.abs(bubble.radius - newRadius) > 20) {
                    bubble.radius = newRadius;
                    isChanged = true;
                }
            }
        });

        for (const key in this.bubbles) {
            const bubble = this.bubbles[key];
            // sweep
            if (!bubble.mark) {
                delete this.bubbles[key];
                isChanged = true;
            }
        }

        if (isChanged)
            this.animationAlpha = 0.1;
    }

    start(data) {
        this.bubbles = {};
        this.processData(data);
    }

    draw() {
        this.animationAlpha *= 0.99;

        const bubbles = Object.values(this.bubbles);
        if (this.animationAlpha < 0)
            this.animationAlpha = 0;

        const center = [this.contextWidth / 2, this.contextHeight / 2];
        for (let i = 0; i < bubbles.length; i++) {
            // force gravity
            const bubble = bubbles[i];
            const g = [center[0] - bubble.pos[0], center[1] - bubble.pos[1]];
            bubble.pos = [
                bubble.pos[0] + g[0] * this.animationAlpha,
                bubble.pos[1] + g[1] * this.animationAlpha,
            ];
        }

        const jitter = 0.5;
        const collisionPadding = 4;

        for (let i = 0; i < bubbles.length; i++) {
            // collapse testing
            for (let j = 0; j < bubbles.length; j++) {
                if (i == j) continue;
                const me = bubbles[i];
                const other = bubbles[j];
                const dist = me.distance(other);
                const minDist = me.radius + other.radius + collisionPadding;
                if (dist < minDist) {
                    const d = (dist - minDist) / dist * jitter;
                    const dx = (me.pos[0] - other.pos[0]) * d;
                    const dy = (me.pos[1] - other.pos[1]) * d;

                    me.pos[0] -= dx;
                    me.pos[1] -= dy;
                    other.pos[0] += dx;
                    other.pos[1] += dy;
                }
            }
        }

        const now = (new Date()).getTime();
        for (let i = 0; i < bubbles.length; i++) {
            const me = bubbles[i];
            me.update();
            if (this.hoverBubble && this.hoverBubble != me) {
                me.dim = true;
            } else
                me.dim = false;

            bubbles[i].draw(this.renderContext, now);
        }
    }

    pick(x, y) {
        let isHover = false;

        const bubbles = Object.values(this.bubbles);
        for (let i = 0; i < bubbles.length; i++) {
            const d = bubbles[i].distancePos([x, y])
            if (d < bubbles[i].radius) {
                this.hoverBubble = bubbles[i];
                isHover = true;
                break;
            }
        }

        if(!isHover)
            this.hoverBubble = null;

        return this.hoverBubble != null ? this.hoverBubble.data.origin : null;
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.canvas.bubblecloud",
    extend: "chart.brush.canvas.core",
    component: function () {
        const ColorUtil = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.color");

        const CanvasBubbleCloudBrush = function() {
            function hexToRgba(color, opacity) {
                const rgb = ColorUtil.rgb(color);
                return `rgba(${rgb.r},${rgb.g},${rgb.b},${opacity})`;
            }

            this.draw = function() {
                let bubbleCloud = this.chart.getCache('bubble_cloud'),
                    bubbleData = this.chart.getCache('bubble_data');

                if(bubbleCloud != null && (bubbleData != null && bubbleData == this.axis.data)) {
                    bubbleCloud.draw();
                } else {
                    bubbleCloud = new BubbleCloud(this.canvas, this.axis.area('width'), this.axis.area('height'));

                    this.eachData(function(data, index) {
                        let color = this.color(index, null),
                            name = this.getValue(data, 'title', 'Unknown'),
                            count = this.getValue(data, 'capacity', 1);

                        let bubbleData = {
                            name: name,
                            count: count,
                            color: color,
                            shadowColor: hexToRgba(color, 0.2),
                            textColor: this.chart.theme('bubbleCloudFontColor'),
                            textStyle: `${this.chart.theme('bubbleCloudFontWeight')} ${this.chart.theme('bubbleCloudFontSize')}px ${this.chart.theme('fontFamily')}`,
                            origin: data
                        };

                        bubbleCloud.bubbles[name] = bubbleData;
                    });

                    bubbleCloud.start(Object.values(bubbleCloud.bubbles));
                    bubbleCloud.draw();

                    this.chart.setCache('picker', { obj: bubbleCloud, func: bubbleCloud.pick });
                    this.chart.setCache('bubble_cloud', bubbleCloud);
                    this.chart.setCache('bubble_data', this.axis.data);
                }
            }
        }

        return CanvasBubbleCloudBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/canvas/equalizercolumn.js":
/*!**********************************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/canvas/equalizercolumn.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../main.js */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.canvas.equalizercolumn",
    extend: "chart.brush.canvas.core",
    component: function () {
        const _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");

        const CanvasEqualizerColumnBrush = function() {
            let zeroY, bar_width, is_reverse;

            this.getTargetSize = function() {
                let width = this.axis.x.rangeBand();

                if(this.brush.size > 0) {
                    return this.brush.size;
                } else {
                    let size = width - this.brush.outerPadding * 2;
                    return (size < this.brush.minSize) ? this.brush.minSize : size;
                }
            }

            this.getBarElement = function(dataIndex, targetIndex) {
                let style = this.getBarStyle(),
                    color = this.color(targetIndex),
                    value = this.getData(dataIndex)[this.brush.target[targetIndex]],
                    active = this.brush.active,
                    opacity = 1;

                if ((_.typeCheck("array", active) && !active.includes(dataIndex)) ||
                    (_.typeCheck("integer", active) && active !== dataIndex)) {
                    opacity = style.disableOpacity;
                }

                return {
                    fill : color,
                    "fill-opacity": opacity,
                    stroke : style.borderColor,
                    "stroke-width" : style.borderWidth,
                    "stroke-opacity" : style.borderOpacity,
                    hidden: value == 0
                };
            }

            this.getBarStyle = function() {
                return {
                    borderColor: this.chart.theme("barBorderColor"),
                    borderWidth: this.chart.theme("barBorderWidth"),
                    borderOpacity: this.chart.theme("barBorderOpacity"),
                    borderRadius: this.chart.theme("barBorderRadius"),
                    disableOpacity: this.chart.theme("barDisableBackgroundOpacity"),
                    circleColor: this.chart.theme("barPointBorderColor")
                }
            }

            this.isErrorColumn = function(i) {
                const error = this.brush.error;

                if ((_.typeCheck("array", error) && !error.includes(i)) ||
                    (_.typeCheck("integer", error) && error !== i) || error === null) {
                    return false;
                }

                return true;
            }

            this.drawBefore = function() {
                zeroY = this.axis.y(0);
                bar_width = this.getTargetSize();
                is_reverse = this.axis.get("y").reverse;
            }

            this.draw = function() {
                const targets = this.brush.target,
                    padding = this.brush.innerPadding,
                    band = this.axis.y.rangeBand(),
                    unit = band / (this.brush.unit * padding),
                    height = unit + padding,
                    translateY = (is_reverse) ? 0 : -unit;

                this.eachData(function(data, i) {
                    let offsetX = this.offset("x", i),
                        startX = offsetX - bar_width / 2,
                        startY = this.axis.y(0),
                        y = startY,
                        value = 0,
                        stackList = [];

                    for(let j = 0; j < targets.length; j++) {
                        let yValue = data[targets[j]] + value,
                            endY = this.axis.y(yValue),
                            targetHeight = Math.abs(startY - endY),
                            targetY = targetHeight;

                        if (!this.isErrorColumn(i)) {
                            while(targetY >= height) {
                                let r = _.extend(this.getBarElement(i, j), {
                                    x : startX,
                                    y : y + translateY,
                                    width : bar_width,
                                    height : unit
                                });

                                targetY -= height;
                                y += (is_reverse) ? height : -height;

                                this.canvas.save();
                                this.canvas.globalAlpha = r["fill-opacity"];
                                this.canvas.beginPath();
                                this.canvas.fillStyle = r.fill;
                                this.canvas.strokeStyle = r.stroke;
                                this.canvas.strokeOpacity = r["stroke-opacity"];
                                this.canvas.lineWidth = r["stroke-width"];
                                this.canvas.rect(r.x, r.y, r.width, r.height);
                                this.canvas.fill();
                                this.canvas.restore();

                                stackList.push(r);
                            }
                        } else {
                            let size = Math.min(this.axis.x.rangeBand(), this.axis.area("height")) * 0.4;
                            let height = this.axis.area("height") * 0.5;
                            let tick = size * 0.3;
                            let startX = offsetX - size / 2;
                            let fontSize = height / 5;
                            let yt = y - tick;
                            let yht = y - height - tick;
                            let round = 5;

                            this.canvas.save();
                            this.canvas.beginPath();
                            this.canvas.fillStyle = this.chart.theme("equalizerColumnErrorBackgroundColor");
                            this.canvas.moveTo(offsetX, y);
                            this.canvas.lineTo(startX, yt);
                            this.canvas.lineTo(startX, yht + round);
                            this.canvas.arcTo(startX, yht, startX + round, yht, round);
                            this.canvas.lineTo(startX + size - round, yht);
                            this.canvas.arcTo(startX + size, yht, startX + size, yht + round, round);
                            this.canvas.lineTo(startX + size, yt);
                            this.canvas.fill();

                            this.canvas.save();
                            this.canvas.font = `${fontSize}px ${this.chart.theme("fontFamily")}`;
                            this.canvas.translate(offsetX, y - height - tick);
                            this.canvas.rotate(Math.PI / 2);
                            this.canvas.textAlign = "center";
                            this.canvas.fillStyle = this.chart.theme("equalizerColumnErrorFontColor");
                            this.canvas.fillText(this.brush.errorText, height / 1.75, fontSize / 3, height);

                            this.canvas.restore();
                        }

                        startY = endY;
                        value = yValue;
                    }

                    if(stackList.length > 0) {
                        this.chart.setCache(`equalizer_${i}`, stackList.length == 0 ? null : stackList[stackList.length - 1]);
                        this.chart.setCache(`raycast_area_${i}`, {
                            x1: stackList[0].x,
                            x2: stackList[0].x + stackList[0].width,
                            y2: this.axis.y(this.axis.y.min()),
                            y1: stackList[stackList.length - 1].y
                        });
                    }
                });

                this.drawAnimation();
            }

            this.drawAnimation = function() {
                const MAX_DISTANCE = 8; // 애니메이션 움직인 최대 반경 (0px ~ 10px)
                const UP_SEC_PER_MOVE = 20; // 초당 20픽셀 이동
                const DOWN_SEC_PER_MOVE = 30; // 초당 30픽셀 이동
                const TOP_PADDING = -3;
                const TOTAL_PADDING = -8;

                this.eachData(function (data, i) {
                    if (!this.isErrorColumn(i)) {
                        const r = this.chart.getCache(`equalizer_${i}`);
                        let total = 0;

                        for(let j = 0; j < this.brush.target.length; j++) {
                            total += data[this.brush.target[j]];
                        }

                        if(r != null) {
                            const tpf = this.chart.getCache(`tpf`, 1);
                            const status = this.chart.getCache(`equalizer_move_${i}`, { direction: -1, distance: 0 });
                            const speed = status.direction == -1 ? UP_SEC_PER_MOVE : DOWN_SEC_PER_MOVE;

                            status.distance += status.direction * speed * tpf;

                            // 애니메이션-바 방향 벡터 설정
                            if(Math.abs(status.distance) >= MAX_DISTANCE) {
                                status.direction = 1;
                            } else if(status.distance >= 0) {
                                status.direction = -1;
                            }

                            // 애니메이션-바 최소/최대 위치 설정
                            if(status.distance < -MAX_DISTANCE) {
                                status.distance = -MAX_DISTANCE;
                            } else if(status.distance > 0) {
                                status.distance = 0;
                            }

                            const ry = r.y + status.distance + TOP_PADDING;

                            this.canvas.save();
                            this.canvas.globalAlpha = r["fill-opacity"];
                            this.canvas.strokeStyle = r.fill;
                            this.canvas.lineWidth = r.height * 0.7;
                            this.canvas.beginPath();
                            this.canvas.moveTo(r.x, ry);
                            this.canvas.lineTo(r.x + r.width, ry);
                            this.canvas.closePath();
                            this.canvas.stroke();

                            this.canvas.fillStyle = this.chart.theme("barFontColor");
                            this.canvas.font = this.chart.theme("barFontSize") + "px";
                            this.canvas.textAlign = "center";
                            this.canvas.textBaseline = "middle";
                            this.canvas.fillText(total, r.x + r.width/2, ry + TOTAL_PADDING);
                            this.canvas.fill();
                            this.canvas.restore();

                            this.chart.setCache(`equalizer_move_${i}`, status);
                        }
                    }
                });
            }
        }

        CanvasEqualizerColumnBrush.setup = function() {
            return {
                /** @cfg {Number} [size=0] Set a fixed size of the bar. */
                size: 0,
                /** @cfg {Number} [minSize=0] Sets the minimum size as it is not possible to draw a bar when the value is 0. */
                minSize: 0,
                /** @cfg {Number} [outerPadding=15] Determines the outer margin of a stack bar. */
                outerPadding: 15,
                /** @cfg {Number} [innerPadding=1] Determines the inner margin of a bar. */
                innerPadding: 1,
                /** @cfg {Number} [unit=5] Determines the reference value that represents the color.*/
                unit: 1,
                /** @cfg {Number | Array} [active=null] Activates the bar of an applicable index. */
                active: null,
                /** @cfg {Number | Array} [active=null] Activates the bar of an applicable index. */
                error: null,
                errorText: "Stopped"
            };
        }

        return CanvasEqualizerColumnBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/column.js":
/*!******************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/column.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var _bar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bar.js */ "./node_modules/juijs-chart/src/brush/bar.js");



_main_js__WEBPACK_IMPORTED_MODULE_0__.default.use(_bar_js__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.column",
    extend: "chart.brush.bar",
    component: function() {
        var ColumnBrush = function() {
            var g;
            var zeroY, width, col_width, half_width;

            this.drawBefore = function() {
                var op = this.brush.outerPadding,
                    ip = this.brush.innerPadding,
                    len = this.brush.target.length;

                g = this.chart.svg.group();
                zeroY = this.axis.y(0);
                width = this.axis.x.rangeBand();

                if(this.brush.size > 0) {
                    col_width = this.brush.size;
                    half_width = (col_width * len) + ((len - 1) * ip);
                } else {
                    half_width = (width - op * 2);
                    col_width = (width - op * 2 - (len - 1) * ip) / len;
                    col_width = (col_width < 0) ? 0 : col_width;
                }
            }

            this.draw = function() {
                var points = this.getXY(),
                    style = this.getBarStyle();

                this.eachData(function(data, i) {
                    var startX = this.offset("x", i) - (half_width / 2);

                    for (var j = 0; j < this.brush.target.length; j++) {
                        var value = data[this.brush.target[j]],
                            tooltipX = startX + (col_width / 2),
                            tooltipY = this.axis.y(value),
                            position = (tooltipY <= zeroY) ? "top" : "bottom";

                        // 최소 크기 설정
                        if(Math.abs(zeroY - tooltipY) < this.brush.minSize) {
                            tooltipY = (position == "top") ? tooltipY - this.brush.minSize : tooltipY + this.brush.minSize;
                        }

                        var	height = Math.abs(zeroY - tooltipY),
                            radius = (col_width < style.borderRadius || height < style.borderRadius) ? 0 : style.borderRadius,
                            r = this.getBarElement(i, j, {
                                width: col_width,
                                height: height,
                                value: value,
                                tooltipX: tooltipX,
                                tooltipY: tooltipY,
                                position: position,
                                max: points[j].max[i],
                                min: points[j].min[i]
                            });

                        if (tooltipY <= zeroY) {
                            r.round(col_width, height, radius, radius, 0, 0);
                            r.translate(startX, tooltipY);
                        } else {
                            r.round(col_width, height, 0, 0, radius, radius);
                            r.translate(startX, zeroY);
                        }

                        // 그룹에 컬럼 엘리먼트 추가
                        g.append(r);

                        // 다음 컬럼 좌표 설정
                        startX += col_width + this.brush.innerPadding;
                    }
                });

                this.drawETC(g);

                return g;
            }

            this.drawAnimate = function(root) {
                var svg = this.chart.svg,
                    type = this.brush.animate;

                root.append(
                    svg.animate({
                        attributeName: "opacity",
                        from: "0",
                        to: "1",
                        begin: "0s" ,
                        dur: "1.4s",
                        repeatCount: "1",
                        fill: "freeze"
                    })
                );

                root.each(function(i, elem) {
                    if(elem.is("util.svg.element.path")) {
                        var xy = elem.data("translate").split(","),
                            x = parseInt(xy[0]),
                            y = parseInt(xy[1]),
                            h = parseInt(elem.attr("height")),
                            start = (type == "top") ? y - h : y + h;

                        elem.append(svg.animateTransform({
                            attributeName: "transform",
                            type: "translate",
                            from: x + " " + start,
                            to: x + " " + y,
                            begin: "0s",
                            dur: "0.7s",
                            repeatCount: "1",
                            fill: "freeze"
                        }));
                    }
                });
            }
        }

        return ColumnBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/donut.js":
/*!*****************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/donut.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var _pie_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pie.js */ "./node_modules/juijs-chart/src/brush/pie.js");



_main_js__WEBPACK_IMPORTED_MODULE_0__.default.use(_pie_js__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.donut",
    extend: "chart.brush.pie",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");
        var math = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.math");
        var ColorUtil = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.color");

        var DonutBrush = function() {
            var self = this,
                cache_active = {};

            this.drawDonut = function(centerX, centerY, innerRadius, outerRadius, startAngle, endAngle, attr) {
                attr['stroke-width'] = outerRadius - innerRadius;

                if (endAngle >= 360) { // bugfix : if angle is 360 , donut cang't show
                    endAngle = 359.9999;
                }

                var g = this.chart.svg.group(),
                    path = this.chart.svg.path(attr),
                    dist = Math.abs(outerRadius - innerRadius);

                // 바깥 지름 부터 그림
                var obj = math.rotate(0, -outerRadius, math.radian(startAngle)),
                    startX = obj.x,
                    startY = obj.y;

                // 시작 하는 위치로 옮김
                path.MoveTo(startX, startY);

                // outer arc 에 대한 지점 설정
                obj = math.rotate(startX, startY, math.radian(endAngle));

                // 중심점 이동
                g.translate(centerX, centerY);

                // outer arc 그림
                path.Arc(outerRadius, outerRadius, 0, (endAngle > 180) ? 1 : 0, 1, obj.x, obj.y);

                // 마우스 이벤트 빈공간 제외
                path.css({
                    "pointer-events": "stroke"
                });

                g.append(path);
                g.order = 1;

                return g;
            }

            this.drawDonut3d = function(centerX, centerY, innerRadius, outerRadius, startAngle, endAngle, attr) {
                var g = this.chart.svg.group(),
                    path = this.chart.svg.path(attr),
                    dist = Math.abs(outerRadius - innerRadius);

                outerRadius += dist/2;
                innerRadius = outerRadius - dist;

                // 바깥 지름 부터 그림
                var obj = math.rotate(0, -outerRadius, math.radian(startAngle)),
                    startX = obj.x,
                    startY = obj.y;

                var innerObj = math.rotate(0, -innerRadius, math.radian(startAngle)),
                    innerStartX = innerObj.x,
                    innerStartY = innerObj.y;


                // 시작 하는 위치로 옮김
                path.MoveTo(startX, startY);

                // outer arc 에 대한 지점 설정
                obj = math.rotate(startX, startY, math.radian(endAngle));
                innerObj = math.rotate(innerStartX, innerStartY, math.radian(endAngle));

                // 중심점 이동
                g.translate(centerX, centerY);

                // outer arc 그림
                path.Arc(outerRadius, outerRadius, 0, (endAngle > 180) ? 1 : 0, 1, obj.x, obj.y);


                var y = obj.y + 10,
                    x = obj.x + 5,
                    innerY = innerObj.y + 10,
                    innerX = innerObj.x + 5,
                    targetX = startX + 5,
                    targetY = startY + 10,
                    innerTargetX = innerStartX + 5,
                    innerTargetY = innerStartY + 10;

                path.LineTo(x, y);
                path.Arc(outerRadius, outerRadius, 0, (endAngle > 180) ? 1 : 0, 0, targetX, targetY)
                path.ClosePath();
                g.append(path);

                // 안쪽 면 그리기
                var innerPath = this.chart.svg.path(attr);

                // 시작 하는 위치로 옮김
                innerPath.MoveTo(innerStartX, innerStartY);
                innerPath.Arc(innerRadius, innerRadius, 0, (endAngle > 180) ? 1 : 0, 1, innerObj.x, innerObj.y);
                innerPath.LineTo(innerX, innerY);
                innerPath.Arc(innerRadius, innerRadius, 0, (endAngle > 180) ? 1 : 0, 0, innerTargetX, innerTargetY);
                innerPath.ClosePath();

                g.append(innerPath);
                g.order = 1;

                return g;
            }

            this.drawDonut3dBlock = function(centerX, centerY, innerRadius, outerRadius, startAngle, endAngle, attr) {
                var g = this.chart.svg.group(),
                    path = this.chart.svg.path(attr),
                    dist = Math.abs(outerRadius - innerRadius);

                outerRadius += dist/2;
                innerRadius = outerRadius - dist;

                // 바깥 지름 부터 그림
                var obj = math.rotate(0, -outerRadius, math.radian(startAngle)),
                    startX = obj.x,
                    startY = obj.y;

                var innerObj = math.rotate(0, -innerRadius, math.radian(startAngle)),
                    innerStartX = innerObj.x,
                    innerStartY = innerObj.y;


                // 시작 하는 위치로 옮김
                path.MoveTo(startX, startY);

                // outer arc 에 대한 지점 설정
                obj = math.rotate(startX, startY, math.radian(endAngle));
                innerObj = math.rotate(innerStartX, innerStartY, math.radian(endAngle));

                // 중심점 이동
                g.translate(centerX, centerY);

                var y = obj.y + 10,
                    x = obj.x + 5,
                    innerY = innerObj.y + 10,
                    innerX = innerObj.x + 5;

                // 왼쪽면 그리기
                var rect = this.chart.svg.path(attr);
                rect.MoveTo(obj.x, obj.y).LineTo(x, y).LineTo(innerX, innerY).LineTo(innerObj.x, innerObj.y).ClosePath();

                g.append(rect);
                g.order = 1;

                return g;
            }

            this.drawUnit = function (index, data, g) {
                var props = this.getProperty(index),
                    centerX = props.centerX,
                    centerY = props.centerY,
                    innerRadius = props.innerRadius,
                    outerRadius = props.outerRadius;

                var target = this.brush.target,
                    active = this.brush.active,
                    all = 360,
                    startAngle = 0,
                    max = 0,
                    totalValue = 0;

                for (var i = 0; i < target.length; i++) {
                    max += data[target[i]];
                }

                if (this.brush['3d']) {
                    // 화면 블럭 그리기
                    for (var i = 0; i < target.length; i++) {
                        var value = data[target[i]],
                            endAngle = all * (value / max),
                            donut3d = this.drawDonut3dBlock(centerX, centerY, innerRadius, outerRadius, startAngle, endAngle, {
                                fill : ColorUtil.darken(this.color(i), 0.5)
                            }, i == target.length - 1);
                        g.append(donut3d);

                        startAngle += endAngle;
                    }

                    startAngle = 0;
                    for (var i = 0; i < target.length; i++) {
                        var value = data[target[i]],
                            endAngle = all * (value / max),
                            donut3d = this.drawDonut3d(centerX, centerY, innerRadius, outerRadius, startAngle, endAngle, {
                                fill : ColorUtil.darken(this.color(i), 0.5)
                            }, i == target.length - 1);
                        g.append(donut3d);

                        startAngle += endAngle;
                    }
                }

                startAngle = 0;

                for (var i = 0; i < target.length; i++) {
                    if(data[target[i]] == 0) continue;

                    var value = data[target[i]],
                        endAngle = all * (value / max),
                        centerAngle = startAngle + (endAngle / 2) - 90,
                        isOnlyOne = Math.abs(startAngle - endAngle) == 360,
                        radius = (this.brush.showText == "inside") ? this.brush.size + innerRadius + outerRadius : outerRadius,
                        donut = this.drawDonut(centerX, centerY, innerRadius, outerRadius, startAngle, endAngle, {
                            stroke : this.color(i),
                            fill : 'transparent'
                        }),
                        text = this.drawText(centerX, centerY, centerAngle, radius, this.getFormatText(target[i], value));

                    // 파이 액티브상태 캐싱하는 객체
                    cache_active[centerAngle] = {
                        active: false,
                        pie: donut,
                        text: text,
                        centerX: centerX,
                        centerY: centerY,
                        centerAngle: centerAngle,
                        outerRadius: radius
                    };

                    // TODO: 파이가 한개일 경우, 액티브 처리를 할 필요가 없다.
                    if(!isOnlyOne) {
                        // 설정된 키 활성화
                        if (active == target[i] || _.inArray(target[i], active) != -1) {
                            cache_active[centerAngle].active = true;
                        } else {
                            cache_active[centerAngle].active = false;
                        }

                        // 파이 및 텍스트 액티브 상태 처리
                        if(this.brush.showText == "inside") {
                            this.setActiveTextEvent(cache_active);
                        }

                        // 파이 및 텍스트 액티브 상태 처리
                        this.setActiveEvent(cache_active, false);

                        // 활성화 이벤트 설정
                        if (this.brush.activeEvent != null) {
                            (function (p, t, cx, cy, ca, r) {
                                p.on(self.brush.activeEvent, function (e) {
                                    if (!cache_active[ca].active) {
                                        cache_active[ca].active = true;
                                    } else {
                                        cache_active[ca].active = false;
                                    }

                                    if(self.brush.showText == "inside") {
                                        self.setActiveTextEvent(cache_active);
                                    }

                                    self.setActiveEvent(cache_active, false);
                                });

                                p.attr({ cursor: "pointer" });
                            })(donut, text.get(0), centerX, centerY, centerAngle, radius);
                        }
                    }

                    this.addEvent(donut, index, i);
                    g.append(donut);
                    g.append(text);

                    startAngle += endAngle;
                    totalValue += value;
                }

                // Show total value
                if(this.brush.showValue) {
                    this.drawTotalValue(g, centerX, centerY, totalValue);
                }
            }

            this.drawNoData = function(g) {
                var props = this.getProperty(0);

                g.append(this.drawDonut(props.centerX, props.centerY, props.innerRadius, props.outerRadius, 0, 360, {
                    stroke : this.chart.theme("pieNoDataBackgroundColor"),
                    fill : "transparent"
                }));

                // Show total value
                if(this.brush.showValue) {
                    this.drawTotalValue(g, props.centerX, props.centerY, 0);
                }
            }

            this.drawTotalValue = function(g, centerX, centerY, value) {
                var size = this.chart.theme("pieTotalValueFontSize");

                var text = this.chart.text({
                    "font-size": size,
                    "font-weight": this.chart.theme("pieTotalValueFontWeight"),
                    fill: this.chart.theme("pieTotalValueFontColor"),
                    "text-anchor": "middle",
                    dy: size / 3
                }, this.format(value));

                text.translate(centerX, centerY);
                g.append(text)
            }

            this.getProperty = function(index) {
                var obj = this.axis.c(index);

                var width = obj.width,
                    height = obj.height,
                    x = obj.x,
                    y = obj.y,
                    min = width;

                if (height < min) {
                    min = height;
                }

                if (this.brush.size >= min/2) {
                    this.brush.size = min/4;
                }

                var outerRadius = min / 2 - this.brush.size / 2;

                return {
                    centerX : width / 2 + x,
                    centerY : height / 2 + y,
                    outerRadius : outerRadius,
                    innerRadius : outerRadius - this.brush.size
                }
            }
        }

        DonutBrush.setup = function() {
            return {
                /** @cfg {Number} [size=50] donut stroke width  */
                size: 50,
                /** @cfg {Boolean} [showValue=false] donut stroke width  */
                showValue: false
            };
        }

        return DonutBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/focus.js":
/*!*****************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/focus.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.focus",
    extend: "chart.brush.core",
    component: function () {
        const FocusBrush = function() {
            const self = this;
            let g, grid;

            this.drawFocus = function(start, end) {
                const borderColor = this.chart.theme("focusBorderColor"),
                    borderSize = this.chart.theme("focusBorderWidth"),
                    bgColor = this.chart.theme("focusBackgroundColor"),
                    bgOpacity = this.chart.theme("focusBackgroundOpacity");

                const width = this.axis.area("width"),
                    height = this.axis.area("height"),
                    x = this.axis.area("x"),
                    y = this.axis.area("y");

                g = this.svg.group({}, function() {
                    if(self.brush.hide || self.axis.data.length == 0) return;

                    const a = self.svg.line({
                        stroke: borderColor,
                        "stroke-width": borderSize,
                        x1: 0,
                        y1: 0,
                        x2: (grid == "x") ? 0 : width,
                        y2: (grid == "x") ? height : 0
                    });

                    const b = self.svg.rect({
                        width: (grid == "x") ? Math.abs(end - start) : width,
                        height: (grid == "x") ? height : Math.abs(end - start),
                        fill: bgColor,
                        opacity: bgOpacity
                    });

                    const c = self.svg.line({
                        stroke: borderColor,
                        "stroke-width": borderSize,
                        x1: 0,
                        y1: 0,
                        x2: (grid == "x") ? 0 : width,
                        y2: (grid == "x") ? height : 0
                    });

                    if(grid == "x") {
                        a.translate(start, y);
                        b.translate(start, y);
                        c.translate(end, y);
                    } else {
                        a.translate(x, start);
                        b.translate(x, start);
                        c.translate(x, end);
                    }
                });

                return g;
            }

            this.drawBefore = function() {
                grid = (this.axis.y.type == "range") ? "x" : "y";
            }

            this.draw = function() {
                let start = 0, end = 0;

                if(this.brush.start == -1 || this.brush.end == -1) {
                    return this.svg.g();
                }

                if(this.axis[grid].type == "block") {
                    const size = this.axis[grid].rangeBand();

                    start = this.axis[grid](this.brush.start) - size / 2;
                    end = this.axis[grid](this.brush.end) + size / 2;
                } else  {
                    start = this.axis[grid](this.brush.start);
                    end = this.axis[grid](this.brush.end);
                }

                return this.drawFocus(start, end);
            }
        }

        FocusBrush.setup = function() {
            return {
                /** @cfg {Integer} [start=-1] Sets a focus start index.*/
                start: -1,

                /** @cfg {Integer} [end=-1] Sets a focus end index. */
                end: -1
            };
        }

        return FocusBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/fullstackbar.js":
/*!************************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/fullstackbar.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var _stackbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stackbar */ "./node_modules/juijs-chart/src/brush/stackbar.js");



_main_js__WEBPACK_IMPORTED_MODULE_0__.default.use(_stackbar__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.fullstackbar",
    extend: "chart.brush.stackbar",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");

        var FullStackBarBrush = function(chart, axis, brush) {
            var g, zeroX, height, bar_height;

            this.drawBefore = function() {
                g = chart.svg.group();
                zeroX = axis.x(0);
                height = axis.y.rangeBand();
                bar_height = this.getTargetSize();
            }

            this.drawText = function(percent, x, y) {
                if(percent === 0 || isNaN(percent)) return null;

                let result = _.typeCheck("function", this.brush.showText) ?
                    this.brush.showText.call(this, percent) : percent + "%";

                let text = this.chart.text({
                    "font-size": this.chart.theme("barFontSize"),
                    fill: this.chart.theme("barFontColor"),
                    x: x,
                    y: y,
                    "text-anchor": "middle"
                }, result);

                return text;
            }

            this.draw = function() {
                this.eachData(function(data, i) {
                    var group = chart.svg.group();

                    var startY = this.offset("y", i) - bar_height / 2,
                        sum = 0,
                        list = [];

                    for(var j = 0; j < brush.target.length; j++) {
                        var width = data[brush.target[j]];

                        sum += width;
                        list.push(width);
                    }

                    var startX = 0,
                        max = axis.x.max();

                    for(var j = 0; j < list.length; j++) {
                        var width = axis.x.rate(list[j], sum),
                            r = this.getBarElement(i, j);

                        if(isNaN(width)) continue;

                        r.attr({
                            x : startX,
                            y : startY,
                            width: width,
                            height: bar_height
                        });

                        group.append(r);

                        // 퍼센트 노출 옵션 설정
                        if(brush.showText !== false) {
                            var p = Math.round((list[j] / sum) * max),
                                x = startX + width / 2,
                                y = startY + bar_height / 2 + 5,
                                text = this.drawText(p, x, y);

                            if(text != null)
                                group.append(text);
                        }

                        // 액티브 엘리먼트 이벤트 설정
                        this.setActiveEventOption(group);

                        startX += width;
                    }

                    this.addBarElement(group);
                    g.append(group);
                });

                // 액티브 엘리먼트 설정
                this.setActiveEffectOption();

                return g;
            }
        }

        FullStackBarBrush.setup = function() {
            return {
                /** @cfg {Number} [outerPadding=15] */
                outerPadding: 15,
                /** @cfg {Boolean} [showText=false] Configures settings to let the percent text of a full stack bar revealed. */
                showText: false
            };
        }

        return FullStackBarBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/fullstackcolumn.js":
/*!***************************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/fullstackcolumn.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var _fullstackbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fullstackbar */ "./node_modules/juijs-chart/src/brush/fullstackbar.js");



_main_js__WEBPACK_IMPORTED_MODULE_0__.default.use(_fullstackbar__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.fullstackcolumn",
    extend: "chart.brush.fullstackbar",
    component: function() {
        var FullStackColumnBrush = function(chart, axis, brush) {
            var g, zeroY, bar_width;

            this.getTargetSize = function() {
                var width = this.axis.x.rangeBand(),
                    r_width = 0;

                if(this.brush.size > 0) {
                    r_width = this.brush.size;
                } else {
                    r_width = width - this.brush.outerPadding * 2;
                }

                return (r_width < 0) ? 0 : r_width;
            }

            this.drawBefore = function() {
                g = chart.svg.group();
                zeroY = axis.y(0);
                bar_width = this.getTargetSize();
            }

            this.draw = function() {
                var chart_height = axis.area("height");

                this.eachData(function(data, i) {
                    var group = chart.svg.group();

                    var startX = this.offset("x", i) - bar_width / 2,
                        sum = 0,
                        list = [];

                    for(var j = 0; j < brush.target.length; j++) {
                        var height = data[brush.target[j]];

                        sum += height;
                        list.push(height);
                    }

                    var startY = 0,
                        max = axis.y.max();

                    for(var j = list.length - 1; j >= 0; j--) {
                        var height = chart_height - axis.y.rate(list[j], sum),
                            r = this.getBarElement(i, j);

                        if (isNaN(startX) || isNaN(startY) || isNaN(height) ) {
                            // 정상적인 숫자가 아니면 element 를 설정하지 않음.
                        } else {
                            // 값의 범위가 정상일때 오류가 안나도록 함.
                            r.attr({
                                x: startX,
                                y: startY,
                                width: bar_width,
                                height: height
                            });
                        }


                        group.append(r);

                        // 퍼센트 노출 옵션 설정
                        if(brush.showText) {
                            var p = Math.round((list[j] / sum) * max),
                                x = startX + bar_width / 2,
                                y = startY + height / 2 + 8,
                                text = this.drawText(p, x, y);

                            if(text != null)
                                group.append(text);

                        }

                        // 액티브 엘리먼트 이벤트 설정
                        this.setActiveEventOption(group);

                        startY += height;
                    }

                    this.addBarElement(group);
                    g.append(group);
                });

                // 액티브 엘리먼트 설정
                this.setActiveEffectOption();

                return g;
            }
        }

        return FullStackColumnBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/line.js":
/*!****************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/line.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.line",
    extend: "chart.brush.core",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");

        var LineBrush = function() {
            var g;
            var circleColor, disableOpacity, lineBorderWidth, lineBorderDashArray, lineBorderOpacity;

            this.setActiveEffect = function(elem) {
                var lines = this.lineList;

                for(var i = 0; i < lines.length; i++) {
                    var opacity = (elem == lines[i].element) ? lineBorderOpacity : disableOpacity,
                        color = lines[i].element.get(0).attr("stroke");

                    if(lines[i].tooltip != null) {
                        lines[i].tooltip.style(color, circleColor, opacity);
                    }

                    lines[i].element.attr({ opacity: opacity });
                }
            }

            this.setActiveEffects = function() {
                var lines = this.lineList,
                    active = this.brush.active;

                for(var i = 0; i < lines.length; i++) {
                    var target = this.brush.target[i],
                        opacity = disableOpacity,
                        color = lines[i].element.get(0).attr("stroke");

                    if(active === null || active === target || (_.typeCheck("array", active) && active.includes(target))) {
                        opacity = lineBorderOpacity;
                    }

                    if(lines[i].tooltip != null) {
                        lines[i].tooltip.style(color, circleColor, opacity);
                    }

                    lines[i].element.attr({ opacity: opacity });
                }
            }

            this.addLineElement = function(elem) {
                if(!this.lineList) {
                    this.lineList = [];
                }

                this.lineList.push(elem);
            }

            this.createLine = function(pos, tIndex) {
                var x = pos.x,
                    y = pos.y,
                    v = pos.value,
                    px = (this.brush.symbol == "curve") ? this.curvePoints(x) : null,
                    py = (this.brush.symbol == "curve") ? this.curvePoints(y) : null,
                    color = null,
                    opacity = null,
                    opts = {
                        "stroke-width" : lineBorderWidth,
                        "stroke-dasharray" : lineBorderDashArray,
                        fill : "transparent",
                        "cursor" : (this.brush.activeEvent != null) ? "pointer" : "normal"
                    };

                var g = this.svg.group(),
                    p = null;

                if(pos.length > 0) {
                    var start = null, end = null;

                    for (var i = 0; i < x.length - 1; i++) {
                        if(!_.typeCheck([ "undefined", "null" ], v[i]))
                            start = i;
                        if(!_.typeCheck([ "undefined", "null" ], v[i + 1]))
                            end = i + 1;

                        if(start == null || end == null || start == end)
                            continue;

                        var newColor = this.color(i, tIndex),
                            newOpacity = this.getOpacity(i);

                        if(color != newColor || opacity != newOpacity) {
                            p = this.svg.path(_.extend({
                                "stroke-opacity": newOpacity,
                                stroke: newColor,
                                x1: x[start] // Start coordinates of area brush
                            }, opts));

                            p.css({
                                "pointer-events": "stroke"
                            });

                            p.MoveTo(x[start], y[start]);
                            g.append(p);

                            color = newColor;
                            opacity = newOpacity;
                        } else {
                            p.attr({
                                x2: x[end] // End coordinates of area brush
                            });
                        }

                        if (this.brush.symbol == "curve") {
                            p.CurveTo(px.p1[start], py.p1[start], px.p2[start], py.p2[start], x[end], y[end]);
                        } else {
                            if (this.brush.symbol == "step") {
                                var sx = x[start] + ((x[end] - x[start]) / 2);

                                p.LineTo(sx, y[start]);
                                p.LineTo(sx, y[end]);
                            }

                            p.LineTo(x[end], y[end]);
                        }
                    }
                }

                return g;
            }

            this.createTooltip = function(g, pos, index) {
                var display = this.brush.display;

                for (var i = 0; i < pos.x.length; i++) {
                    if((display == "max" && pos.max[i]) || (display == "min" && pos.min[i]) || display == "all") {
                        var orient = (display == "max" && pos.max[i]) ? "top" : "bottom",
                            tooltip = this.lineList[index].tooltip;

                        // 최소/최대 값은 무조건 한개만 보여야 함.
                        if(display == "all" || tooltip == null) {
                            var minmax = this.drawTooltip(this.color(index), circleColor, lineBorderOpacity);
                            minmax.control(orient, +pos.x[i], +pos.y[i], this.format(pos.value[i]));

                            g.append(minmax.tooltip);
                            this.lineList[index].tooltip = minmax;
                        }
                    }
                }
            }

            this.getOpacity = function(rowIndex) {
                var opacity = this.brush.opacity,
                    defOpacity = this.chart.theme("lineBorderOpacity");

                if(_.typeCheck("function", opacity) && _.typeCheck("number", rowIndex)) {
                    return opacity.call(this.chart, this.getData(rowIndex), rowIndex);
                } else if(_.typeCheck("number", opacity)) {
                    return opacity;
                }

                return defOpacity;
            }

            this.drawLine = function(path) {
                var self = this;

                for(var k = 0; k < path.length; k++) {
                    var p = this.createLine(path[k], k);

                    this.addEvent(p, null, k);
                    g.append(p);

                    // 컬럼 상태 설정
                    this.addLineElement({
                        element: p,
                        tooltip: null
                    });

                    // Max & Min 툴팁 추가
                    if(this.brush.display != null) {
                        this.createTooltip(g, path[k], k);
                    }

                    // 액티브 이벤트 설정
                    if(this.brush.activeEvent != null) {
                        (function(elem) {
                            elem.on(self.brush.activeEvent, function(e) {
                                self.setActiveEffect(elem);
                            });
                        })(p);
                    }
                }

                // 액티브 라인 설정
                if(this.brush.active != null) {
                    this.setActiveEffects();
                }

                return g;
            }

            this.drawBefore = function() {
                g = this.chart.svg.group();
                circleColor = this.chart.theme("linePointBorderColor");
                disableOpacity = this.chart.theme("lineDisableBorderOpacity");
                lineBorderWidth = this.chart.theme("lineBorderWidth");
                lineBorderDashArray = this.chart.theme("lineBorderDashArray");
                lineBorderOpacity = this.getOpacity(null);
            }

            this.draw = function() {
                return this.drawLine(this.getXY());
            }

            this.drawAnimate = function(root) {
                var svg = this.chart.svg;

                root.each(function(i, elem) {
                    if(elem.is("util.svg.element.path")) {
                        var dash = elem.attributes["stroke-dasharray"],
                            len = elem.length();

                        if(dash == "none") {
                            elem.attr({
                                "stroke-dasharray": len
                            });

                            elem.append(svg.animate({
                                attributeName: "stroke-dashoffset",
                                from: len,
                                to: "0",
                                begin: "0s",
                                dur: "1s",
                                repeatCount: "1"
                            }));
                        } else {
                            elem.append(svg.animate({
                                attributeName: "opacity",
                                from: "0",
                                to: "1",
                                begin: "0s" ,
                                dur: "1.5s",
                                repeatCount: "1",
                                fill: "freeze"
                            }));
                        }
                    }
                });
            }
        }

        LineBrush.setup = function() {
            return {
                /** @cfg {"normal"/"curve"/"step"} [symbol="normal"] Sets the shape of a line (normal, curve, step). */
                symbol: "normal", // normal, curve, step
                /** @cfg {Number} [active=null] Activates the bar of an applicable index. */
                active: null,
                /** @cfg {String} [activeEvent=null]  Activates the bar in question when a configured event occurs (click, mouseover, etc). */
                activeEvent: null,
                /** @cfg {"max"/"min"/"all"} [display=null]  Shows a tool tip on the bar for the minimum/maximum value.  */
                display: null,
                /** @cfg {Number} [opacity=null]  Stroke opacity.  */
                opacity: null
            };
        }

        return LineBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/pie.js":
/*!***************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/pie.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.pie",
    extend: "chart.brush.core",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");
        var math = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.math");
        var ColorUtil = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.color");

        var PieBrush = function() {
            var self = this, textY = 3;
            var preAngle = 0, preRate = 0, preOpacity = 1;
            var g, cache_active = {};

            this.setActiveEvent = function(items, useOpacity) {
                var isDisableAll = true,
                    disabledOpacity = this.chart.theme("pieDisableBackgroundOpacity") || 0.5;

                for(var key in items) {
                    var data = items[key];

                    if(data.active) {
                        isDisableAll = false;
                        break;
                    }
                }

                for(var key in items) {
                    var data = items[key];

                    if(data.active) {
                        let dist = this.chart.theme("pieActiveDistance"),
                            tx = Math.cos(math.radian(data.centerAngle)) * dist,
                            ty = Math.sin(math.radian(data.centerAngle)) * dist;

                        data.pie.translate(data.centerX + tx, data.centerY + ty);
                    } else {
                        data.pie.translate(data.centerX, data.centerY);
                    }

                    if(useOpacity) {
                        if(data.pie.children.length > 0) {
                            data.pie.get(0).attr({ "opacity": isDisableAll || data.active ? 1 : disabledOpacity });
                        }

                        if(data.text.children.length > 0) {
                            data.text.get(0).attr({ "opacity": isDisableAll || data.active ? 1 : disabledOpacity });
                        }
                    }
                }
            }

            this.setActiveTextEvent = function(items) {
                for(var key in items) {
                    var data = items[key],
                        dist = (data.active) ? this.chart.theme("pieActiveDistance") : 0,
                        cx = data.centerX + (Math.cos(math.radian(data.centerAngle)) * ((data.outerRadius + dist) / 2)),
                        cy = data.centerY + (Math.sin(math.radian(data.centerAngle)) * ((data.outerRadius + dist) / 2));

                    if(data.text.children.length > 0) {
                        data.text.get(0).translate(cx, cy);
                    }
                }
            }

            this.getFormatText = function(target, value, max) {
                var key = target;

                if(typeof(this.brush.format) == "function") {
                    return this.format(key, value, max);
                } else {
                    if (!value) {
                        return key;
                    }

                    return key + ": " + this.format(value);
                }
            }

            this.drawPie = function(centerX, centerY, outerRadius, startAngle, endAngle, color) {
                var pie = this.chart.svg.group();

                if (endAngle == 360) { // if pie is full size, draw a circle as pie brush
                    var circle = this.chart.svg.circle({
                        cx : centerX,
                        cy : centerY,
                        r : outerRadius,
                        fill : color,
                        stroke : this.chart.theme("pieBorderColor") || color,
                        "stroke-width" : this.chart.theme("pieBorderWidth")
                    });

                    pie.append(circle);

                    return pie;
                }

                var path = this.chart.svg.path({
                    fill : color,
                    stroke : this.chart.theme("pieBorderColor") || color,
                    "stroke-width" : this.chart.theme("pieBorderWidth")
                });

                // 바깥 지름 부터 그림
                var obj = math.rotate(0, -outerRadius, math.radian(startAngle)),
                    startX = obj.x,
                    startY = obj.y;

                // 시작 하는 위치로 옮김
                path.MoveTo(startX, startY);

                // outer arc 에 대한 지점 설정
                obj = math.rotate(startX, startY, math.radian(endAngle));

                pie.translate(centerX, centerY);

                // arc 그림
                path.Arc(outerRadius, outerRadius, 0, (endAngle > 180) ? 1 : 0, 1, obj.x, obj.y)
                    .LineTo(0, 0)
                    .ClosePath();

                pie.append(path);
                pie.order = 1;

                return pie;
            }

            this.drawPie3d = function(centerX, centerY, outerRadius, startAngle, endAngle, color) {
                var pie = this.chart.svg.group(),
                    path = this.chart.svg.path({
                        fill : color,
                        stroke : this.chart.theme("pieBorderColor") || color,
                        "stroke-width" : this.chart.theme("pieBorderWidth")
                    });

                // 바깥 지름 부터 그림
                var obj = math.rotate(0, -outerRadius, math.radian(startAngle)),
                    startX = obj.x,
                    startY = obj.y;

                // 시작 하는 위치로 옮김
                path.MoveTo(startX, startY);

                // outer arc 에 대한 지점 설정
                obj = math.rotate(startX, startY, math.radian(endAngle));

                pie.translate(centerX, centerY);

                // arc 그림
                path.Arc(outerRadius, outerRadius, 0, (endAngle > 180) ? 1 : 0, 1, obj.x, obj.y)

                var y = obj.y + 10,
                    x = obj.x + 5,
                    targetX = startX + 5,
                    targetY = startY + 10;

                path.LineTo(x, y);
                path.Arc(outerRadius, outerRadius, 0, (endAngle > 180) ? 1 : 0, 0, targetX, targetY)
                path.ClosePath();

                pie.append(path);
                pie.order = 1;

                return pie;
            }

            this.drawText = function(centerX, centerY, centerAngle, outerRadius, text) {
                var g = this.svg.group({
                        visibility: !this.brush.showText ? "hidden" : "visible"
                    }),
                    isLeft = (centerAngle + 90 > 180) ? true : false;

                if(text === "" || !text) {
                    return g;
                }

                if(this.brush.showText == "inside") {
                    var cx = centerX + (Math.cos(math.radian(centerAngle)) * (outerRadius / 2)),
                        cy = centerY + (Math.sin(math.radian(centerAngle)) * (outerRadius / 2));

                    var text = this.chart.text({
                        "font-size": this.chart.theme("pieInnerFontSize"),
                        fill: this.chart.theme("pieInnerFontColor"),
                        "text-anchor": "middle",
                        y: textY
                    }, text);

                    text.translate(cx, cy);

                    g.append(text);
                    g.order = 2;
                } else {
                    // TODO: 각도가 좁을 때, 텍스트와 라인을 보정하는 코드 개선 필요

                    var rate = this.chart.theme("pieOuterLineRate"),
                        diffAngle = Math.abs(centerAngle - preAngle);

                    if(diffAngle < 2) {
                        if(preRate == 0) {
                            preRate = rate;
                        }

                        var tick = rate * 0.05;
                        preRate -= tick;
                        preOpacity -= 0.25;
                    } else {
                        preRate = rate;
                        preOpacity = 1;
                    }

                    if(preRate > 1.2) {
                        var dist = this.chart.theme("pieOuterLineSize"),
                            r = outerRadius * preRate,
                            cx = centerX + (Math.cos(math.radian(centerAngle)) * outerRadius),
                            cy = centerY + (Math.sin(math.radian(centerAngle)) * outerRadius),
                            tx = centerX + (Math.cos(math.radian(centerAngle)) * r),
                            ty = centerY + (Math.sin(math.radian(centerAngle)) * r),
                            ex = (isLeft) ? tx - dist : tx + dist;

                        var path = this.svg.path({
                            fill: "transparent",
                            stroke: this.chart.theme("pieOuterLineColor"),
                            "stroke-width": this.chart.theme("pieOuterLineWidth"),
                            "stroke-opacity": preOpacity
                        });

                        path.MoveTo(cx, cy)
                            .LineTo(tx, ty)
                            .LineTo(ex, ty);

                        var text = this.chart.text({
                            "font-size": this.chart.theme("pieOuterFontSize"),
                            "fill": this.chart.theme("pieOuterFontColor"),
                            "fill-opacity": preOpacity,
                            "text-anchor": (isLeft) ? "end" : "start",
                            y: textY
                        }, text);

                        text.translate(ex + (isLeft ? -3 : 3), ty);

                        g.append(text);
                        g.append(path);
                        g.order = 0;

                        preAngle = centerAngle;
                    }
                }

                return g;
            }

            this.drawUnit = function (index, data, g) {
                var props = this.getProperty(index),
                    centerX = props.centerX,
                    centerY = props.centerY,
                    outerRadius = props.outerRadius;

                var target = this.brush.target,
                    active = this.brush.active,
                    all = 360,
                    startAngle = 0,
                    max = 0;

                for (var i = 0; i < target.length; i++) {
                    max += data[target[i]];
                }

                for (var i = 0; i < target.length; i++) {
                    if(data[target[i]] == 0) continue;

                    var value = data[target[i]],
                        endAngle = all * (value / max);

                    if (this.brush['3d']) {
                        var pie3d = this.drawPie3d(centerX, centerY, outerRadius, startAngle, endAngle, ColorUtil.darken(this.color(i), 0.5));
                        g.append(pie3d);
                    }

                    startAngle += endAngle;
                }

                startAngle = 0;

                for (var i = 0; i < target.length; i++) {
                    var value = data[target[i]],
                        endAngle = all * (value / max),
                        centerAngle = startAngle + (endAngle / 2) - 90,
                        isOnlyOne = Math.abs(startAngle - endAngle) == 360,
                        pie = this.drawPie(centerX, centerY, outerRadius, startAngle, endAngle, this.color(i)),
                        text = this.drawText(centerX, centerY, centerAngle, outerRadius, this.getFormatText(target[i], value, max));

                    // 파이 액티브상태 캐싱하는 객체
                    cache_active[centerAngle] = {
                        active: false,
                        pie: pie,
                        text: text,
                        centerX: centerX,
                        centerY: centerY,
                        centerAngle: centerAngle,
                        outerRadius: outerRadius
                    };

                    // TODO: 파이가 한개일 경우, 액티브 처리를 할 필요가 없다.
                    if(!isOnlyOne) {
                        // 설정된 키 활성화
                        if (active == target[i] || _.inArray(target[i], active) != -1) {
                            cache_active[centerAngle].active = true;
                        } else {
                            cache_active[centerAngle].active = false;
                        }

                        // 파이 및 텍스트 액티브 상태 처리
                        if(this.brush.showText == "inside") {
                            this.setActiveTextEvent(cache_active);
                        }

                        // 파이 및 텍스트 액티브 상태 처리
                        this.setActiveEvent(cache_active, true);

                        // 활성화 이벤트 설정
                        if (this.brush.activeEvent != null) {
                            (function(p, t, cx, cy, ca, r) {
                                p.on(self.brush.activeEvent, function(e) {
                                    if(!cache_active[ca].active) {
                                        cache_active[ca].active = true;
                                    } else {
                                        cache_active[ca].active = false;
                                    }

                                    if(self.brush.showText == "inside") {
                                        self.setActiveTextEvent(cache_active);
                                    }

                                    self.setActiveEvent(cache_active, true);
                                });

                                p.attr({ cursor: "pointer" });
                            })(pie, text.get(0), centerX, centerY, centerAngle, outerRadius);
                        }
                    }

                    self.addEvent(pie, index, i);
                    g.append(pie);
                    g.append(text);

                    startAngle += endAngle;
                }
            }

            this.drawNoData = function(g) {
                var props = this.getProperty(0);

                g.append(this.drawPie(props.centerX, props.centerY, props.outerRadius, 0, 360, this.chart.theme("pieNoDataBackgroundColor")));
            }

            this.drawBefore = function() {
                g = this.chart.svg.group();
            }

            this.draw = function() {
                if(this.listData().length == 0) {
                    this.drawNoData(g);
                } else {
                    this.eachData(function(data, i) {
                        this.drawUnit(i, data, g);
                    });
                }

                return g;
            }

            this.getProperty = function(index) {
                var obj = this.axis.c(index);

                var width = obj.width,
                    height = obj.height,
                    x = obj.x,
                    y = obj.y,
                    min = width;

                if (height < min) {
                    min = height;
                }

                return {
                    centerX: width / 2 + x,
                    centerY: height / 2 + y,
                    outerRadius: min / 2
                }
            }
        }

        PieBrush.setup = function() {
            return {
                /** @cfg {Boolean} [clip=false] If the brush is drawn outside of the chart, cut the area. */
                clip: false,
                /** @cfg {String} [showText=null] Set the text appear. (outside or inside)  */
                showText: null,
                /** @cfg {Function} [format=null] Returns a value from the format callback function of a defined option. */
                format: null,
                /** @cfg {Boolean} [3d=false] check 3d support */
                "3d": false,
                /** @cfg {String|Array} [active=null] Activates the pie of an applicable property's name. */
                active: null,
                /** @cfg {String} [activeEvent=null]  Activates the pie in question when a configured event occurs (click, mouseover, etc). */
                activeEvent: null
            }
        }

        return PieBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/polygon/column3d.js":
/*!****************************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/polygon/column3d.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../main.js */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.polygon.column3d",
    extend: "chart.brush.polygon.core",
    component: function() {
        var ColorUtil = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.color");
        var CubePolygon = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("chart.polygon.cube");

        var PolygonColumn3DBrush = function() {
            var col_width, col_height;

            this.createColumn = function(data, target, dataIndex, targetIndex) {
                var w = col_width,
                    h = col_height,
                    x = this.axis.x(dataIndex) - w/2,
                    y = this.axis.y(data[target]),
                    yy = this.axis.y(0),
                    z = this.axis.z(targetIndex) - h/2,
                    color = this.color(targetIndex);

                return this.createPolygon(new CubePolygon(x, yy, z, w, y - yy, h), function(p) {
                    var g = this.svg.group();

                    for(var i = 0; i < p.faces.length; i++) {
                        var key = p.faces[i];

                        var face = this.svg.polygon({
                            fill: color,
                            "fill-opacity": this.chart.theme("polygonColumnBackgroundOpacity"),
                            stroke: ColorUtil.darken(color, this.chart.theme("polygonColumnBorderOpacity")),
                            "stroke-opacity": this.chart.theme("polygonColumnBorderOpacity")
                        });

                        for (var j = 0; j < key.length; j++) {
                            var vector = p.vectors[key[j]];
                            face.point(vector.x, vector.y);
                        }

                        g.append(face);
                    }

                    if(data[target] != 0) {
                        this.addEvent(g, dataIndex, targetIndex);
                    }

                    return g;
                });
            }

            this.drawBefore = function() {
                var padding = this.brush.padding,
                    width = this.axis.x.rangeBand(),
                    height = this.axis.z.rangeBand();

                col_width = (this.brush.width > 0) ? this.brush.width : width - padding * 2;
                col_height = (this.brush.height > 0) ? this.brush.height : height - padding * 2;
            }

            this.draw = function() {
                var g = this.chart.svg.group(),
                    datas = this.listData(),
                    targets = this.brush.target;

                for(var i = 0; i < datas.length; i++) {
                    for(var j = 0; j < targets.length; j++) {
                        g.append(this.createColumn(datas[i], targets[j], i, j));
                    }
                }

                return g;
            }
        }

        PolygonColumn3DBrush.setup = function() {
            return {
                /** @cfg {Number} [width=50]  Determines the size of a starter. */
                width: 0,
                /** @cfg {Number} [height=50]  Determines the size of a starter. */
                height: 0,
                /** @cfg {Number} [padding=20] Determines the outer margin of a bar.  */
                padding: 20,
                /** @cfg {Boolean} [clip=false] If the brush is drawn outside of the chart, cut the area. */
                clip: false
            };
        }

        return PolygonColumn3DBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/polygon/line3d.js":
/*!**************************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/polygon/line3d.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../main.js */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.polygon.line3d",
    extend: "chart.brush.polygon.core",
    component: function() {
        var ColorUtil = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.color");
        var PointPolygon = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("chart.polygon.point");

        var PolygonLine3DBrush = function() {
            this.createLine = function(datas, target, dataIndex, targetIndex) {
                var color = this.color(dataIndex, targetIndex),
                    d = this.axis.z.rangeBand() - this.brush.padding * 2,
                    x1 = this.axis.x(dataIndex),
                    y1 = this.axis.y(datas[dataIndex][target]),
                    z1 = this.axis.z(targetIndex) - d / 2,
                    x2 = this.axis.x(dataIndex + 1),
                    y2 = this.axis.y(datas[dataIndex + 1][target]),
                    z2 = this.axis.z(targetIndex) + d / 2,
                    maxPoint = null;

                var elem = this.chart.svg.polygon({
                    fill: color,
                    "fill-opacity": this.chart.theme("polygonLineBackgroundOpacity"),
                    stroke: ColorUtil.darken(color, this.chart.theme("polygonLineBorderOpacity")),
                    "stroke-opacity": this.chart.theme("polygonLineBorderOpacity")
                });

                var points = [
                    new PointPolygon(x1, y1, z1),
                    new PointPolygon(x1, y1, z2),
                    new PointPolygon(x2, y2, z2),
                    new PointPolygon(x2, y2, z1)
                ];

                for(var i = 0; i < points.length; i++) {
                    this.createPolygon(points[i], function(p) {
                        var vector = p.vectors[0];
                        elem.point(vector.x, vector.y);

                        if(maxPoint == null) {
                            maxPoint = p;
                        } else {
                            if(vector.z > maxPoint.vectors[0].z) {
                                maxPoint = p;
                            }
                        }
                    });
                }

                // 별도로 우선순위 설정
                elem.order = this.axis.depth - maxPoint.max().z;

                return elem;
            }

            this.draw = function() {
                var g = this.chart.svg.group(),
                    datas = this.listData(),
                    targets = this.brush.target;

                for(var i = 0; i < datas.length - 1; i++) {
                    for(var j = 0; j < targets.length; j++) {
                        g.append(this.createLine(datas, targets[j], i, j));
                    }
                }

                return g;
            }
        }

        PolygonLine3DBrush.setup = function() {
            return {
                /** @cfg {Number} [padding=20] Determines the outer margin of a bar.  */
                padding: 10,
                /** @cfg {Boolean} [clip=false] If the brush is drawn outside of the chart, cut the area. */
                clip: false
            };
        }

        return PolygonLine3DBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/rangearea.js":
/*!*********************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/rangearea.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.rangearea",
    extend: "chart.brush.core",
    component: function() {
        var RangeAreaBrush = function() {

            this.draw = function() {
                var g = this.svg.group(),
                    targets = this.brush.target,
                    datas = this.axis.data,
                    isRangeY = (this.axis.y.type == "range");

                for(var i = 0; i < targets.length; i++) {
                    var p = this.svg.polygon({
                        fill: this.color(i),
                        "fill-opacity": this.chart.theme("areaBackgroundOpacity"),
                        "stroke-width": 0
                    });

                    for(var j = 0; j < datas.length; j++) {
                        var value = datas[j][targets[i]];

                        if(isRangeY) {
                            p.point(this.axis.x(j), this.axis.y(value[0]));
                        } else {
                            p.point(this.axis.x(value[0]), this.axis.y(j));
                        }
                    }

                    for(var j = datas.length - 1; j >= 0; j--) {
                        var value = datas[j][targets[i]];

                        if(isRangeY) {
                            p.point(this.axis.x(j), this.axis.y(value[1]));
                        } else {
                            p.point(this.axis.x(value[1]), this.axis.y(j));
                        }
                    }

                    g.append(p);
                }

                return g;
            }
        }

        return RangeAreaBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/rangebar.js":
/*!********************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/rangebar.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.rangebar",
    extend: "chart.brush.core",
    component: function() {
        var RangeBarBrush = function(chart, axis, brush) {
            var g, height, half_height, barHeight;
            var outerPadding, innerPadding;
            var borderColor, borderWidth, borderOpacity;

            this.drawBefore = function() {
                g = chart.svg.group();

                outerPadding = brush.outerPadding;
                innerPadding = brush.innerPadding;

                height = axis.y.rangeBand();
                half_height = height - (outerPadding * 2);
                barHeight = (half_height - (brush.target.length - 1) * innerPadding) / brush.target.length;

                borderColor = chart.theme("barBorderColor");
                borderWidth = chart.theme("barBorderWidth");
                borderOpacity = chart.theme("barBorderOpacity");
            }

            this.draw = function() {
                this.eachData(function(data, i) {
                    var group = chart.svg.group(),
                        startY = this.offset("y", i) - (half_height / 2);

                    for(var j = 0; j < brush.target.length; j++) {
                        var value = data[brush.target[j]],
                            startX = axis.x(value[1]),
                            zeroX = axis.x(value[0]);

                        var r = chart.svg.rect({
                            x : zeroX,
                            y : startY,
                            height : barHeight,
                            width : Math.abs(zeroX - startX),
                            fill : this.color(j),
                            stroke : borderColor,
                            "stroke-width" : borderWidth,
                            "stroke-opacity" : borderOpacity
                        });

                        this.addEvent(r, i, j);
                        group.append(r);

                        startY += barHeight + innerPadding;
                    }

                    g.append(group);
                });

                return g;
            }
        }

        RangeBarBrush.setup = function() {
            return {
                /** @cfg {Number} [outerPadding=2] Determines the outer margin of a bar. */
                outerPadding: 2,
                /** @cfg {Number} [innerPadding=1] Determines the inner margin of a bar. */
                innerPadding: 1
            };
        }

        return RangeBarBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/rangecolumn.js":
/*!***********************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/rangecolumn.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.rangecolumn",
    extend: "chart.brush.core",
    component: function() {
        var RangeColumnBrush = function(chart, axis, brush) {
            var g, width, columnWidth, half_width;
            var outerPadding, innerPadding;
            var borderColor, borderWidth, borderOpacity;

            this.drawBefore = function() {
                g = chart.svg.group();

                outerPadding = brush.outerPadding;
                innerPadding = brush.innerPadding;

                width = axis.x.rangeBand();
                half_width = (width - outerPadding * 2);
                columnWidth = (width - outerPadding * 2 - (brush.target.length - 1) * innerPadding) / brush.target.length;

                borderColor = chart.theme("columnBorderColor");
                borderWidth = chart.theme("columnBorderWidth");
                borderOpacity = chart.theme("columnBorderOpacity");
            }

            this.draw = function() {
                this.eachData(function(data, i) {
                    var startX = this.offset("x", i) - (half_width / 2);

                    for(var j = 0; j < brush.target.length; j++) {
                        var value = data[brush.target[j]],
                            startY = axis.y(value[1]),
                            zeroY = axis.y(value[0]);

                        var r = chart.svg.rect({
                            x : startX,
                            y : startY,
                            width : columnWidth,
                            height : Math.abs(zeroY - startY),
                            fill : this.color(j),
                            stroke : borderColor,
                            "stroke-width" : borderWidth,
                            "stroke-opacity" : borderOpacity
                        });

                        this.addEvent(r, i, j);
                        g.append(r);

                        startX += columnWidth + innerPadding;
                    }
                });

                return g;
            }
        }

        RangeColumnBrush.setup = function() {
            return {
                /** @cfg {Number} [outerPadding=2] Determines the outer margin of a column. */
                outerPadding: 2,
                /** @cfg {Number} [innerPadding=1] Determines the inner margin of a column. */
                innerPadding: 1
            };
        }

        return RangeColumnBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/scatter.js":
/*!*******************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/scatter.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.scatter",
    extend: "chart.brush.core",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");

        var ScatterBrush = function() {

            this.getSymbolType = function(key, value) {
                var symbol = this.brush.symbol,
                    target = this.brush.target[key];

                if(_.typeCheck("function", symbol)) {
                    var res = symbol.apply(this.chart, [ target, value ]);

                    if (res == "triangle" || res == "cross" || res == "rectangle" || res == "rect" || res == "circle") {
                        return {
                            type : "default",
                            uri : res
                        };
                    } else {
                        return {
                            type : "image",
                            uri : res
                        };
                    }
                }

                return {
                    type : "default",
                    uri : symbol
                };
            }

            this.createScatter = function(pos, dataIndex, targetIndex, symbol) {
                var self = this,
                    elem = null,
                    w = this.brush.size,
                    h = this.brush.size;

                var color = this.color(dataIndex, targetIndex),
                    borderColor = this.chart.theme("scatterBorderColor"),
                    borderWidth = this.chart.theme("scatterBorderWidth"),
                    bgOpacity = this.brush.opacity;

                if(symbol.type == "image") {
                    elem = this.chart.svg.image({
                        "xlink:href": symbol.uri,
                        width: w + borderWidth,
                        height: h + borderWidth,
                        x: pos.x - (w / 2) - borderWidth,
                        y: pos.y - (h / 2)
                    });
                } else {
                    if(symbol.uri == "triangle" || symbol.uri == "cross") {
                        elem = this.chart.svg.group({
                            width: w,
                            height: h,
                            opacity: bgOpacity,
                        }, function() {
                            if(symbol.uri == "triangle") {
                                var poly = self.chart.svg.polygon();

                                poly.point(0, h)
                                    .point(w, h)
                                    .point(w / 2, 0);
                            } else {
                                self.chart.svg.line({ stroke: color, "stroke-width": borderWidth * 2, x1: 0, y1: 0, x2: w, y2: h });
                                self.chart.svg.line({ stroke: color, "stroke-width": borderWidth * 2, x1: 0, y1: w, x2: h, y2: 0 });
                            }
                        }).translate(pos.x - (w / 2), pos.y - (h / 2));
                    } else {
                        if(symbol.uri == "rectangle" || symbol.uri == "rect") {
                            elem = this.chart.svg.rect({
                                width: w,
                                height: h,
                                x: pos.x - (w / 2),
                                y: pos.y - (h / 2),
                                opacity: bgOpacity
                            });
                        } else {
                            elem = this.chart.svg.ellipse({
                                rx: w / 2,
                                ry: h / 2,
                                cx: pos.x,
                                cy: pos.y,
                                opacity: bgOpacity
                            });
                        }
                    }

                    if(symbol.uri != "cross") {
                        elem.attr({
                            fill: color,
                            stroke: borderColor,
                            "stroke-width": borderWidth
                        })
                            .hover(function () {
                                if(elem == self.activeScatter) return;

                                var opts = {
                                    fill: self.chart.theme("scatterHoverColor"),
                                    stroke: color,
                                    "stroke-width": borderWidth * 2,
                                    opacity: bgOpacity
                                };

                                if(self.brush.hoverSync) {
                                    for(var i = 0; i < self.cachedSymbol[dataIndex].length; i++) {
                                        opts.stroke = self.color(dataIndex, i);
                                        self.cachedSymbol[dataIndex][i].attr(opts);
                                    }
                                } else {
                                    elem.attr(opts);
                                }
                            }, function () {
                                if(elem == self.activeScatter) return;

                                var opts = {
                                    fill: color,
                                    stroke: borderColor,
                                    "stroke-width": borderWidth,
                                    opacity: (self.brush.hide) ? 0 : bgOpacity
                                };

                                if(self.brush.hoverSync) {
                                    for(var i = 0; i < self.cachedSymbol[dataIndex].length; i++) {
                                        opts.fill = self.color(dataIndex, i);
                                        self.cachedSymbol[dataIndex][i].attr(opts);
                                    }
                                } else {
                                    elem.attr(opts);
                                }
                            });
                    }
                }

                return elem;
            }

            this.drawScatter = function(points) {
                // hoverSync 옵션 처리를 위한 캐싱 처리
                this.cachedSymbol = {};

                var self = this,
                    g = this.chart.svg.group(),
                    borderColor = this.chart.theme("scatterBorderColor"),
                    borderWidth = this.chart.theme("scatterBorderWidth"),
                    bgOpacity = this.brush.opacity,
                    isTooltipDraw = false;

                for(var i = 0; i < points.length; i++) {
                    for(var j = 0; j < points[i].length; j++) {
                        if(!this.cachedSymbol[j]) {
                            this.cachedSymbol[j] = [];
                        }

                        if(this.brush.hideZero && points[i].value[j] === 0) {
                            continue;
                        }

                        var data = {
                            x: points[i].x[j],
                            y: points[i].y[j],
                            max: points[i].max[j],
                            min: points[i].min[j],
                            value: points[i].value[j]
                        };

                        // 값이 null이나 undefined일 때, 그리지 않음
                        if(_.typeCheck([ "undefined", "null" ], data.value))
                            continue;

                        var symbol = this.getSymbolType(i, data.value),
                            p = this.createScatter(data, j, i, symbol),
                            d = this.brush.display;

                        // hoverSync 옵션을 위한 엘리먼트 캐싱
                        if(symbol.type == "default" && symbol.uri != "cross") {
                            this.cachedSymbol[j].push(p);
                        }

                        // Max & Min & All 툴팁 생성
                        if((d == "max" && data.max) || (d == "min" && data.min) || d == "all") {
                            // 최소/최대 값은 무조건 한개만 보여야 함.
                            if(d == "all" || !isTooltipDraw) {
                                g.append(this.drawTooltip(data.x, data.y, this.format(data.value)));
                                isTooltipDraw = true;
                            }
                        }

                        // 컬럼 및 기본 브러쉬 이벤트 설정
                        if(this.brush.activeEvent != null) {
                            (function(scatter, data, color, symbol) {
                                var x = data.x,
                                    y = data.y,
                                    text = self.format(data.value);

                                scatter.on(self.brush.activeEvent, function(e) {
                                    if(symbol.type == "default" && symbol.uri != "cross") {
                                        if (self.activeScatter != null) {
                                            self.activeScatter.attr({
                                                fill: self.activeScatter.attributes["stroke"],
                                                stroke: borderColor,
                                                "stroke-width": borderWidth,
                                                opacity: (self.brush.hide) ? 0 : bgOpacity
                                            });
                                        }

                                        self.activeScatter = scatter;
                                        self.activeScatter.attr({
                                            fill: self.chart.theme("scatterHoverColor"),
                                            stroke: color,
                                            "stroke-width": borderWidth * 2,
                                            opacity: bgOpacity
                                        });
                                    }

                                    self.activeTooltip.html(text);
                                    self.activeTooltip.translate(x, y);
                                });

                                scatter.attr({ cursor: "pointer" });
                            })(p, data, this.color(j, i), this.getSymbolType(i, data.value));
                        }

                        if(this.brush.hide) {
                            p.attr({ opacity: 0 });
                        }

                        this.addEvent(p, j, i);
                        g.append(p);
                    }
                }

                // 액티브 툴팁
                this.activeTooltip = this.drawTooltip(0, 0, "");
                g.append(this.activeTooltip);

                return g;
            }

            this.drawTooltip = function(x, y, text) {
                return this.chart.text({
                    y: -this.brush.size,
                    "text-anchor" : "middle",
                    fill : this.chart.theme("tooltipPointFontColor"),
                    "font-size" : this.chart.theme("tooltipPointFontSize"),
                    "font-weight" : this.chart.theme("tooltipPointFontWeight"),
                    opacity : this.brush.opacity
                }, text).translate(x, y);
            }

            this.draw = function() {
                return this.drawScatter(this.getXY());
            }

            this.drawAnimate = function() {
                var area = this.chart.area();

                return this.chart.svg.animateTransform({
                    attributeName: "transform",
                    type: "translate",
                    from: area.x + " " + area.height,
                    to: area.x + " " + area.y,
                    begin: "0s" ,
                    dur: "0.4s",
                    repeatCount: "1"
                });
            }
        }

        ScatterBrush.setup = function() {
            return {
                /** @cfg {"circle"/"triangle"/"rectangle"/"cross"/"callback"} [symbol="circle"] Determines the shape of a (circle, rectangle, cross, triangle).  */
                symbol: "circle",
                /** @cfg {Number} [size=7]  Determines the size of a starter. */
                size: 7,
                /** @cfg {Boolean} [hide=false]  Hide the scatter, will be displayed only when the mouse is over. */
                hide: false,
                /** @cfg {Boolean} [hideZero=false]  When scatter value is zero, will be hidden. */
                hideZero: false,
                /** @cfg {Boolean} [hoverSync=false]  Over effect synchronization of all the target's symbol. */
                hoverSync: false,
                /** @cfg {String} [activeEvent=null]  Activates the scatter in question when a configured event occurs (click, mouseover, etc). */
                activeEvent: null,
                /** @cfg {"max"/"min"/"all"} [display=null]  Shows a tooltip on the scatter for the minimum/maximum value.  */
                display: null,
                /** @cfg {Number} [opacity=1]  Stroke opacity.  */
                opacity: 1,
                /** @cfg {Boolean} [clip=false] If the brush is drawn outside of the chart, cut the area. */
                clip: false
            };
        }

        return ScatterBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/stackarea.js":
/*!*********************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/stackarea.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "./node_modules/juijs-chart/src/brush/area.js");



_main_js__WEBPACK_IMPORTED_MODULE_0__.default.use(_area_js__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.stackarea",
    extend: "chart.brush.area",
    component: function() {
        var StackAreaBrush = function() {
            this.draw = function() {
                return this.drawArea(this.getStackXY());
            }
        }

        return StackAreaBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/stackbar.js":
/*!********************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/stackbar.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var _bar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bar.js */ "./node_modules/juijs-chart/src/brush/bar.js");



_main_js__WEBPACK_IMPORTED_MODULE_0__.default.use(_bar_js__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.stackbar",
    extend: "chart.brush.bar",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");

        var StackBarBrush = function(chart, axis, brush) {
            var g, height, bar_height;

            this.addBarElement = function(elem) {
                if(this.barList == null) {
                    this.barList = [];
                }

                this.barList.push(elem);
            }

            this.getBarElement = function(dataIndex, targetIndex) {
                var style = this.getBarStyle(),
                    color = this.color(targetIndex),
                    value = this.getData(dataIndex)[this.brush.target[targetIndex]];

                var r = this.chart.svg.rect({
                    fill : color,
                    stroke : style.borderColor,
                    "stroke-width" : style.borderWidth,
                    "stroke-opacity" : style.borderOpacity
                });

                // 데이타가 0이면 화면에 표시하지 않음.
                if (value == 0) {
                    r.attr({ display : 'none' });
                }

                if(value != 0) {
                    this.addEvent(r, dataIndex, targetIndex);
                }

                return r;
            }

            this.setActiveEffect = function(group) {
                var style = this.getBarStyle(),
                    columns = this.barList,
                    tooltips = this.stackTooltips;

                for(var i = 0; i < columns.length; i++) {
                    var opacity = (group == columns[i]) ? 1 : style.disableOpacity;

                    if (tooltips) {			// bar 가 그려지지 않으면 tooltips 객체가 없을 수 있음.
                        if(opacity == 1 || _.inArray(i, this.tooltipIndexes) != -1) {
                            tooltips[i].attr({ opacity: 1 });
                        } else {
                            tooltips[i].attr({ opacity: 0 });
                        }
                    }

                    columns[i].attr({ opacity: opacity });
                }
            }

            this.setActiveEffectOption = function() {
                var active = this.brush.active;

                if(this.barList && this.barList[active]) {
                    this.setActiveEffect(this.barList[active]);
                }
            }

            this.setActiveEvent = function(group) {
                var self = this;

                group.on(self.brush.activeEvent, function (e) {
                    self.setActiveEffect(group);
                });
            }

            this.setActiveEventOption = function(group) {
                if(this.brush.activeEvent != null) {
                    this.setActiveEvent(group);
                    group.attr({ cursor: "pointer" });
                }
            }

            this.getTargetSize = function() {
                var height = this.axis.y.rangeBand();

                if(this.brush.size > 0) {
                    return this.brush.size;
                } else {
                    var size = height - this.brush.outerPadding * 2;
                    return (size < this.brush.minSize) ? this.brush.minSize : size;
                }
            }

            this.setActiveTooltips = function(minIndex, maxIndex) {
                var type = this.brush.display,
                    activeIndex = (type == "min") ? minIndex : maxIndex;

                for(var i = 0; i < this.stackTooltips.length; i++) {
                    if(i == activeIndex || type == "all") {
                        this.stackTooltips[i].css({
                            opacity: 1
                        });

                        this.tooltipIndexes.push(i);
                    }
                }
            }

            this.drawStackTooltip = function(group, index, value, x, y, pos) {
                var fontSize = this.chart.theme("tooltipPointFontSize"),
                    orient = "middle",
                    dx = 0,
                    dy = 0;

                if(pos == "left") {
                    orient = "start";
                    dx = 3;
                    dy = fontSize / 3;
                } else if(pos == "right") {
                    orient = "end";
                    dx = -3;
                    dy = fontSize / 3;
                } else if(pos == "top") {
                    dy = -(fontSize / 3);
                } else {
                    dy = fontSize;
                }

                var tooltip = this.chart.text({
                    fill : this.chart.theme("tooltipPointFontColor"),
                    "font-size" : fontSize,
                    "font-weight" : this.chart.theme("tooltipPointFontWeight"),
                    "text-anchor" : orient,
                    dx: dx,
                    dy: dy,
                    opacity: 0
                }).text(this.format(value)).translate(x, y);

                this.stackTooltips[index] = tooltip;
                group.append(tooltip);
            }

            this.drawStackEdge = function(g) {
                var borderWidth = this.chart.theme("barStackEdgeBorderWidth");

                for(var i = 1; i < this.edgeData.length; i++) {
                    var pre = this.edgeData[i - 1],
                        now = this.edgeData[i];

                    for(var j = 0; j < this.brush.target.length; j++) {
                        if(now[j].width > 0 && now[j].height > 0) {
                            g.append(this.svg.line({
                                x1: pre[j].x + pre[j].width - pre[j].ex,
                                x2: now[j].x + now[j].dx - now[j].ex,
                                y1: pre[j].y + pre[j].height - pre[j].ey,
                                y2: now[j].y + now[j].dy,
                                stroke: now[j].color,
                                "stroke-width": borderWidth
                            }));
                        }
                    }
                }
            }

            this.drawBefore = function() {
                g = chart.svg.group();
                height = axis.y.rangeBand();
                bar_height = this.getTargetSize();

                this.stackTooltips = [];
                this.tooltipIndexes = [];
                this.edgeData = [];
            }

            this.draw = function() {
                var maxIndex = null,
                    maxValue = 0,
                    minIndex = null,
                    minValue = this.axis.x.max(),
                    isReverse = this.axis.get("x").reverse;

                this.eachData(function(data, i) {
                    var group = chart.svg.group();

                    var offsetY = this.offset("y", i),
                        startY = offsetY - bar_height / 2,
                        startX = axis.x(0),
                        value = 0,
                        sumValue = 0;

                    for(var j = 0; j < brush.target.length; j++) {
                        var xValue = data[brush.target[j]] + value,
                            endX = axis.x(xValue),
                            opts = {
                                x : (startX < endX) ? startX : endX,
                                y : startY,
                                width : Math.abs(startX - endX),
                                height : bar_height
                            },
                            r = this.getBarElement(i, j).attr(opts);

                        if(!this.edgeData[i]) {
                            this.edgeData[i] = {};
                        }

                        this.edgeData[i][j] = _.extend({
                            color: this.color(j),
                            dx: opts.width,
                            dy: 0,
                            ex: (isReverse) ? opts.width : 0,
                            ey: 0
                        }, opts);

                        startX = endX;
                        value = xValue;
                        sumValue += data[brush.target[j]];

                        group.append(r);
                    }

                    // min & max 인덱스 가져오기
                    if(sumValue > maxValue) {
                        maxValue = sumValue;
                        maxIndex = i;
                    }
                    if(sumValue < minValue) {
                        minValue = sumValue;
                        minIndex = i;
                    }

                    this.drawStackTooltip(group, i, sumValue, startX, offsetY, (isReverse) ? "right" : "left");
                    this.setActiveEventOption(group); // 액티브 엘리먼트 이벤트 설정
                    this.addBarElement(group);
                    g.append(group);
                });

                // 스탭 연결선 그리기
                if(this.brush.edge) {
                    this.drawStackEdge(g);
                }

                // 최소/최대/전체 값 표시하기
                if(this.brush.display != null) {
                    this.setActiveTooltips(minIndex, maxIndex);
                }

                // 액티브 엘리먼트 설정
                this.setActiveEffectOption();

                return g;
            }
        }

        StackBarBrush.setup = function() {
            return {
                /** @cfg {Number} [outerPadding=15] Determines the outer margin of a stack bar. */
                outerPadding: 15,
                /** @cfg {Boolean} [edge=false] */
                edge: false
            };
        }

        return StackBarBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/stackcolumn.js":
/*!***********************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/stackcolumn.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var _stackbar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stackbar.js */ "./node_modules/juijs-chart/src/brush/stackbar.js");



_main_js__WEBPACK_IMPORTED_MODULE_0__.default.use(_stackbar_js__WEBPACK_IMPORTED_MODULE_1__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.stackcolumn",
    extend: "chart.brush.stackbar",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");

        var StackColumnBrush = function(chart, axis, brush) {
            var g, zeroY, bar_width;

            this.getTargetSize = function() {
                var width = this.axis.x.rangeBand();

                if(this.brush.size > 0) {
                    return this.brush.size;
                } else {
                    var size = width - this.brush.outerPadding * 2;
                    return (size < this.brush.minSize) ? this.brush.minSize : size;
                }
            }

            this.drawBefore = function() {
                g = chart.svg.group();
                zeroY = axis.y(0);
                bar_width = this.getTargetSize();

                this.stackTooltips = [];
                this.tooltipIndexes = [];
                this.edgeData = [];
            }

            this.draw = function() {
                var maxIndex = null,
                    maxValue = 0,
                    minIndex = null,
                    minValue = this.axis.y.max(),
                    isReverse = this.axis.get("y").reverse;

                this.eachData(function(data, i) {
                    var group = chart.svg.group();

                    var offsetX = this.offset("x", i),
                        startX = offsetX - bar_width / 2,
                        startY = axis.y(0),
                        value = 0,
                        sumValue = 0;

                    for(var j = 0; j < brush.target.length; j++) {
                        var yValue = data[brush.target[j]] + value,
                            endY = axis.y(yValue),
                            opts = {
                                x : startX,
                                y : (startY > endY) ? endY : startY,
                                width : bar_width,
                                height : Math.abs(startY - endY)
                            },
                            r = this.getBarElement(i, j).attr(opts);

                        if(!this.edgeData[i]) {
                            this.edgeData[i] = {};
                        }

                        this.edgeData[i][j] = _.extend({
                            color: this.color(j),
                            dx: 0,
                            dy: (isReverse) ? opts.height : 0,
                            ex: 0,
                            ey: (isReverse) ? 0 : opts.height
                        }, opts);

                        startY = endY;
                        value = yValue;
                        sumValue += data[brush.target[j]];

                        group.append(r);
                    }

                    // min & max 인덱스 가져오기
                    if(sumValue > maxValue) {
                        maxValue = sumValue;
                        maxIndex = i;
                    }
                    if(sumValue < minValue) {
                        minValue = sumValue;
                        minIndex = i;
                    }

                    this.drawStackTooltip(group, i, sumValue, offsetX, startY, (isReverse) ? "bottom" : "top");
                    this.setActiveEventOption(group); // 액티브 엘리먼트 이벤트 설정
                    this.addBarElement(group);

                    g.append(group);
                });

                // 스탭 연결선 그리기
                if(this.brush.edge) {
                    this.drawStackEdge(g);
                }

                // 최소/최대/전체 값 표시하기
                if(this.brush.display != null) {
                    this.setActiveTooltips(minIndex, maxIndex);
                }

                // 액티브 엘리먼트 설정
                this.setActiveEffectOption();

                return g;
            }
        }

        return StackColumnBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/brush/treemap.js":
/*!*******************************************************!*\
  !*** ./node_modules/juijs-chart/src/brush/treemap.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");


_main_js__WEBPACK_IMPORTED_MODULE_0__.default.define("util.keyparser", [], function() {
    return function () {

        /**
         * @method isIndexDepth
         *
         * @param {String} index
         * @return {Boolean}
         */
        this.isIndexDepth = function (index) {
            if (typeof(index) == "string" && index.indexOf(".") != -1) {
                return true;
            }

            return false;
        }

        /**
         * @method getIndexList
         *
         * @param {String} index
         * @return {Array}
         */
        this.getIndexList = function (index) { // 트리 구조의 모든 키를 배열 형태로 반환
            var resIndex = [],
                strIndexes = ("" + index).split(".");

            for(var i = 0; i < strIndexes.length; i++) {
                resIndex[i] = parseInt(strIndexes[i]);
            }

            return resIndex;
        }

        /**
         * @method changeIndex
         *
         *
         * @param {String} index
         * @param {String} targetIndex
         * @param {String} rootIndex
         * @return {String}
         */
        this.changeIndex = function (index, targetIndex, rootIndex) {
            var rootIndexLen = this.getIndexList(rootIndex).length,
                indexList = this.getIndexList(index),
                tIndexList = this.getIndexList(targetIndex);

            for (var i = 0; i < rootIndexLen; i++) {
                indexList.shift();
            }

            return tIndexList.concat(indexList).join(".");
        }

        /**
         * @method getNextIndex
         *
         * @param {String} index
         * @return {String}
         */
        this.getNextIndex = function (index) { // 현재 인덱스에서 +1
            var indexList = this.getIndexList(index),
                no = indexList.pop() + 1;

            indexList.push(no);
            return indexList.join(".");
        }

        /**
         * @method getParentIndex
         *
         *
         * @param {String} index
         * @returns {*}
         */
        this.getParentIndex = function (index) {
            if (!this.isIndexDepth(index)) return null;

            return index.substr(0, index.lastIndexOf("."))
        }
    }
});

_main_js__WEBPACK_IMPORTED_MODULE_0__.default.define("util.treemap", [], function() {

    return {
        sumArray: function (arr) {
            var sum = 0;

            for (var i = 0; i < arr.length; i++) {
                sum += arr[i];
            }

            return sum;
        }
    }
});

_main_js__WEBPACK_IMPORTED_MODULE_0__.default.define("chart.brush.treemap.node", [], function() {

    /**
     * @class chart.brush.treemap.node
     *
     */
    var Node = function(data) {
        var self = this;

        this.text = data.text;
        this.value = data.value;
        this.x = data.x;
        this.y = data.y;
        this.width = data.width;
        this.height = data.height;

        /** @property {Integer} [index=null] Index of a specified node */
        this.index = null;

        /** @property {Integer} [nodenum=null] Unique number of a specifiede node at the current depth */
        this.nodenum = null;

        /** @property {ui.tree.node} [parent=null] Variable that refers to the parent of the current node */
        this.parent = null;

        /** @property {Array} [children=null] List of child nodes of a specified node */
        this.children = [];

        /** @property {Integer} [depth=0] Depth of a specified node */
        this.depth = 0;

        function setIndexChild(node) {
            var clist = node.children;

            for(var i = 0; i < clist.length; i++) {
                if(clist[i].children.length > 0) {
                    setIndexChild(clist[i]);
                }
            }
        }

        this.reload = function(nodenum) {
            this.nodenum = (!isNaN(nodenum)) ? nodenum : this.nodenum;

            if(self.parent) {
                if(this.parent.index == null) this.index = "" + this.nodenum;
                else this.index = self.parent.index + "." + this.nodenum;
            }

            // 뎁스 체크
            if(this.parent && typeof(self.index) == "string") {
                this.depth = this.index.split(".").length;
            }

            // 자식 인덱스 체크
            if(this.children.length > 0) {
                setIndexChild(this);
            }
        }

        this.isLeaf = function() {
            return (this.children.length == 0) ? true : false;
        }

        this.appendChild = function(node) {
            this.children.push(node);
        }

        this.insertChild = function(nodenum, node) {
            var preNodes = this.children.splice(0, nodenum);
            preNodes.push(node);

            this.children = preNodes.concat(this.children);
        }

        this.removeChild = function(index) {
            for(var i = 0; i < this.children.length; i++) {
                var node = this.children[i];

                if(node.index == index) {
                    this.children.splice(i, 1); // 배열에서 제거
                }
            }
        }

        this.lastChild = function() {
            if(this.children.length > 0)
                return this.children[this.children.length - 1];

            return null;
        }

        this.lastChildLeaf = function(lastRow) {
            var row = (!lastRow) ? this.lastChild() : lastRow;

            if(row.isLeaf()) return row;
            else {
                return this.lastChildLeaf(row.lastChild());
            }
        }
    }

    return Node;
});

_main_js__WEBPACK_IMPORTED_MODULE_0__.default.define("chart.brush.treemap.nodemanager",
    [ "util.base", "util.keyparser", "chart.brush.treemap.node" ], function(_, KeyParser, Node) {

    var NodeManager = function() {
        var self = this,
            root = new Node({
                text: null,
                value: -1,
                x: -1,
                y: -1,
                width: -1,
                height: -1
            }),
            iParser = new KeyParser();

        function createNode(data, no, pNode) {
            var node = new Node(data);

            node.parent = (pNode) ? pNode : null;
            node.reload(no);

            return node;
        }

        function setNodeChildAll(dataList, node) {
            var c_nodes = node.children;

            if(c_nodes.length > 0) {
                for(var i = 0; i < c_nodes.length; i++) {
                    dataList.push(c_nodes[i]);

                    if(c_nodes[i].children.length > 0) {
                        setNodeChildAll(dataList, c_nodes[i]);
                    }
                }
            }
        }

        function getNodeChildLeaf(keys, node) {
            if(!node) return null;
            var tmpKey = keys.shift();

            if(tmpKey == undefined) {
                return node;
            } else {
                return getNodeChildLeaf(keys, node.children[tmpKey]);
            }
        }

        function insertNodeDataChild(index, data) {
            var keys = iParser.getIndexList(index);

            var pNode = self.getNodeParent(index),
                nodenum = keys[keys.length - 1],
                node = createNode(data, nodenum, pNode);

            // 데이터 갱신
            pNode.insertChild(nodenum, node);

            return node;
        }

        function appendNodeData(data) {
            var node = createNode(data, root.children.length, root);
            root.appendChild(node);

            return node;
        }

        function appendNodeDataChild(index, data) {
            var pNode = self.getNode(index),
                cNode = createNode(data, pNode.children.length, pNode);

            pNode.appendChild(cNode);

            return cNode;
        }

        this.appendNode = function() {
            var index = arguments[0],
                data = arguments[1];

            if(!data) {
                return appendNodeData(index);
            } else {
                return appendNodeDataChild(index, data);
            }
        }

        this.insertNode = function(index, data) {
            if(root.children.length == 0 && parseInt(index) == 0) {
                return this.appendNode(data);
            } else {
                return insertNodeDataChild(index, data);
            }
        }

        this.updateNode = function(index, data) {
            var node = this.getNode(index);

            for(var key in data) {
                node.data[key] = data[key];
            }

            node.reload(node.nodenum, true);

            return node;
        }

        this.getNode = function(index) {
            if(index == null) return root.children;
            else {
                var nodes = root.children;

                if(iParser.isIndexDepth(index)) {
                    var keys = iParser.getIndexList(index);
                    return getNodeChildLeaf(keys, nodes[keys.shift()]);
                } else {
                    return (nodes[index]) ? nodes[index] : null;
                }
            }
        }

        this.getNodeAll = function(index) {
            var dataList = [],
                tmpNodes = (index == null) ? root.children : [ this.getNode(index) ];

            for(var i = 0; i < tmpNodes.length; i++) {
                if(tmpNodes[i]) {
                    dataList.push(tmpNodes[i]);

                    if(tmpNodes[i].children.length > 0) {
                        setNodeChildAll(dataList, tmpNodes[i]);
                    }
                }
            }

            return dataList;
        }

        this.getNodeParent = function(index) { // 해당 인덱스의 부모 노드를 가져옴 (단, 해당 인덱스의 노드가 없을 경우)
            var keys = iParser.getIndexList(index);

            if(keys.length == 1) {
                return root;
            } else if(keys.length == 2) {
                return this.getNode(keys[0]);
            } else if(keys.length > 2) {
                keys.pop();
                return this.getNode(keys.join("."));
            }
        }

        this.getRoot = function() {
            return root;
        }
    }

    return NodeManager;
});

_main_js__WEBPACK_IMPORTED_MODULE_0__.default.define("chart.brush.treemap.container", [ "util.treemap" ], function(util) {

    var Container = function(xoffset, yoffset, width, height) {
        this.xoffset = xoffset; // offset from the the top left hand corner
        this.yoffset = yoffset; // ditto
        this.height = height;
        this.width = width;

        this.shortestEdge = function () {
            return Math.min(this.height, this.width);
        };

        // getCoordinates - for a row of boxes which we've placed
        //                  return an array of their cartesian coordinates
        this.getCoordinates = function (row) {
            var coordinates = [],
                subxoffset = this.xoffset, subyoffset = this.yoffset, //our offset within the container
                areawidth = util.sumArray(row) / this.height,
                areaheight = util.sumArray(row) / this.width;

            if (this.width >= this.height) {
                for (var i = 0; i < row.length; i++) {
                    coordinates.push([ subxoffset, subyoffset, subxoffset + areawidth, subyoffset + row[i] / areawidth ]);
                    subyoffset = subyoffset + row[i] / areawidth;
                }
            } else {
                for (var i = 0; i < row.length; i++) {
                    coordinates.push([ subxoffset, subyoffset, subxoffset + row[i] / areaheight, subyoffset + areaheight ]);
                    subxoffset = subxoffset + row[i] / areaheight;
                }
            }

            return coordinates;
        }

        // cutArea - once we've placed some boxes into an row we then need to identify the remaining area,
        //           this function takes the area of the boxes we've placed and calculates the location and
        //           dimensions of the remaining space and returns a container box defined by the remaining area
        this.cutArea = function (area) {
            if (this.width >= this.height) {
                var areawidth = area / this.height,
                    newwidth = this.width - areawidth;

                return new Container(this.xoffset + areawidth, this.yoffset, newwidth, this.height);
            } else {
                var areaheight = area / this.width,
                    newheight = this.height - areaheight;

                return new Container(this.xoffset, this.yoffset + areaheight, this.width, newheight);
            }
        }
    }

    return Container;
});

_main_js__WEBPACK_IMPORTED_MODULE_0__.default.define("chart.brush.treemap.calculator", [ "util.base", "util.treemap", "chart.brush.treemap.container" ], function(_, util, Container) {

    // normalize - the Bruls algorithm assumes we're passing in areas that nicely fit into our
    //             container box, this method takes our raw data and normalizes the data values into
    //             area values so that this assumption is valid.
    function normalize(data, area) {
        var normalizeddata = [],
            sum = util.sumArray(data),
            multiplier = area / sum;

        for (var i = 0; i < data.length; i++) {
            normalizeddata[i] = data[i] * multiplier;
        }

        return normalizeddata;
    }

    // treemapMultidimensional - takes multidimensional data (aka [[23,11],[11,32]] - nested array)
    //                           and recursively calls itself using treemapSingledimensional
    //                           to create a patchwork of treemaps and merge them
    function treemapMultidimensional(data, width, height, xoffset, yoffset) {
        xoffset = (typeof xoffset === "undefined") ? 0 : xoffset;
        yoffset = (typeof yoffset === "undefined") ? 0 : yoffset;

        var mergeddata = [],
            mergedtreemap,
            results = [];

        if(_.typeCheck("array", data[0])) { // if we've got more dimensions of depth
            for(var i = 0; i < data.length; i++) {
                mergeddata[i] = sumMultidimensionalArray(data[i]);
            }

            mergedtreemap = treemapSingledimensional(mergeddata, width, height, xoffset, yoffset);

            for(var i = 0; i < data.length; i++) {
                results.push(treemapMultidimensional(data[i], mergedtreemap[i][2] - mergedtreemap[i][0], mergedtreemap[i][3] - mergedtreemap[i][1], mergedtreemap[i][0], mergedtreemap[i][1]));
            }
        } else {
            results = treemapSingledimensional(data,width,height, xoffset, yoffset);
        }
        return results;
    }

    // treemapSingledimensional - simple wrapper around squarify
    function treemapSingledimensional(data, width, height, xoffset, yoffset) {
        xoffset = (typeof xoffset === "undefined") ? 0 : xoffset;
        yoffset = (typeof yoffset === "undefined") ? 0 : yoffset;

        //console.log(normalize(data, width * height))
        var rawtreemap = squarify(normalize(data, width * height), [], new Container(xoffset, yoffset, width, height), []);
        return flattenTreemap(rawtreemap);
    }

    // flattenTreemap - squarify implementation returns an array of arrays of coordinates
    //                  because we have a new array everytime we switch to building a new row
    //                  this converts it into an array of coordinates.
    function flattenTreemap(rawtreemap) {
        var flattreemap = [];

        if(rawtreemap) {
            for (var i = 0; i < rawtreemap.length; i++) {
                for (var j = 0; j < rawtreemap[i].length; j++) {
                    flattreemap.push(rawtreemap[i][j]);
                }

            }
        }

        return flattreemap;
    }

    // squarify  - as per the Bruls paper
    //             plus coordinates stack and containers so we get
    //             usable data out of it
    function squarify(data, currentrow, container, stack) {
        var length;
        var nextdatapoint;
        var newcontainer;

        if (data.length === 0) {
            stack.push(container.getCoordinates(currentrow));
            return;
        }

        length = container.shortestEdge();
        nextdatapoint = data[0];

        if (improvesRatio(currentrow, nextdatapoint, length)) {
            currentrow.push(nextdatapoint);
            squarify(data.slice(1), currentrow, container, stack);
        } else {
            newcontainer = container.cutArea(util.sumArray(currentrow), stack);
            stack.push(container.getCoordinates(currentrow));
            squarify(data, [], newcontainer, stack);
        }
        return stack;
    }

    // improveRatio - implements the worse calculation and comparision as given in Bruls
    //                (note the error in the original paper; fixed here)
    function improvesRatio(currentrow, nextnode, length) {
        var newrow;

        if (currentrow.length === 0) {
            return true;
        }

        newrow = currentrow.slice();
        newrow.push(nextnode);

        var currentratio = calculateRatio(currentrow, length),
            newratio = calculateRatio(newrow, length);

        // the pseudocode in the Bruls paper has the direction of the comparison
        // wrong, this is the correct one.
        return currentratio >= newratio;
    }

    // calculateRatio - calculates the maximum width to height ratio of the
    //                  boxes in this row
    function calculateRatio(row, length) {
        var min = Math.min.apply(Math, row),
            max = Math.max.apply(Math, row),
            sum = util.sumArray(row);

        return Math.max(Math.pow(length, 2) * max / Math.pow(sum, 2), Math.pow(sum, 2) / (Math.pow(length, 2) * min));
    }

    // sumMultidimensionalArray - sums the values in a nested array (aka [[0,1],[[2,3]]])
    function sumMultidimensionalArray(arr) {
        var total = 0;

        if(_.typeCheck("array", arr[0])) {
            for(var i = 0; i < arr.length; i++) {
                total += sumMultidimensionalArray(arr[i]);
            }
        } else {
            total = util.sumArray(arr);
        }

        return total;
    }

    return treemapMultidimensional;
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.brush.treemap",
    extend: "chart.brush.core",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");
        var Calculator = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("chart.brush.treemap.calculator");
        var NodeManager = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("chart.brush.treemap.nodemanager");

        var TEXT_MARGIN_LEFT = 3;

        /**
         * @class chart.brush.treemap
         *
         * @extends chart.brush.core
         */
        var TreemapBrush = function() {
            var nodes = new NodeManager(),
                titleKeys = {};

            function convertNodeToArray(key, nodes, result, now) {
                if(!now) now = [];

                for(var i = 0; i < nodes.length; i++) {
                    if(nodes[i].children.length == 0) {
                        now.push(nodes[i][key]);
                    } else {
                        convertNodeToArray(key, nodes[i].children, result, []);
                    }
                }

                result.push(now);
                return result;
            }

            function mergeArrayToNode(keys, values) {
                for(var i = 0; i < keys.length; i++) {
                    if(_.typeCheck("array", keys[i])) {
                        mergeArrayToNode(keys[i], values[i]);
                    } else {
                        var node = nodes.getNode(keys[i]);
                        node.x = values[i][0];
                        node.y = values[i][1];
                        node.width = values[i][2] - values[i][0];
                        node.height = values[i][3] - values[i][1];
                    }
                }
            }

            function isDrawNode(node) {
                if(node.width == 0 && node.height == 0 && node.x == 0 && node.y == 0) {
                    return false;
                }

                return true;
            }

            function getMinimumXY(node, dx, dy) {
                if(node.children.length == 0) {
                    return {
                        x: Math.min(dx, node.x),
                        y: Math.min(dy, node.y)
                    };
                } else {
                    for(var i = 0; i < node.children.length; i++) {
                        return getMinimumXY(node.children[i], dx, dy);
                    }
                }
            }

            function createTitleDepth(self, g, node, sx, sy) {
                var fontSize = self.chart.theme("treemapTitleFontSize"),
                    w = self.axis.area("width"),
                    h = self.axis.area("height"),
                    xy = getMinimumXY(node, w, h);

                var text = self.chart.text({
                    "font-size": fontSize,
                    "font-weight": "bold",
                    fill: self.chart.theme("treemapTitleFontColor"),
                    x: sx + xy.x + TEXT_MARGIN_LEFT,
                    y: sy + xy.y + fontSize,
                    "text-anchor": "start"
                }, (_.typeCheck("function", self.brush.format) ? self.format(node) : node.text));

                g.append(text);
                titleKeys[node.index] = true;
            }

            function getRootNodeSeq(node) {
                if(node.parent.depth > 0) {
                    return getRootNodeSeq(node.parent);
                }

                return node.nodenum;
            }

            this.drawBefore = function() {
                for(var i = 0; i < this.axis.data.length; i++) {
                    var d = this.axis.data[i],
                        k = this.getValue(d, "index");

                    nodes.insertNode(k, {
                        text: this.getValue(d, "text", ""),
                        value: this.getValue(d, "value", 0),
                        x: this.getValue(d, "x", 0),
                        y: this.getValue(d, "y", 0),
                        width: this.getValue(d, "width", 0),
                        height: this.getValue(d, "height", 0)
                    });
                }

                var nodeList = nodes.getNode(),
                    preData = convertNodeToArray("value", nodeList, []),
                    preKeys = convertNodeToArray("index", nodeList, []),
                    afterData = Calculator(preData, this.axis.area("width"), this.axis.area("height"));

                mergeArrayToNode(preKeys, afterData);
            }

            this.draw = function() {
                var g = this.svg.group(),
                    sx = this.axis.area("x"),
                    sy = this.axis.area("y"),
                    nodeList = nodes.getNodeAll();

                for(var i = 0; i < nodeList.length; i++) {
                    if(this.brush.titleDepth == nodeList[i].depth) {
                        createTitleDepth(this, g, nodeList[i], sx, sy);
                    }

                    if(!isDrawNode(nodeList[i])) continue;

                    var x = sx + nodeList[i].x,
                        y = sy + nodeList[i].y,
                        w = nodeList[i].width,
                        h = nodeList[i].height;

                    if(this.brush.showText && !titleKeys[nodeList[i].index]) {
                        var cx = x + (w / 2),
                            cy = y + (h / 2),
                            fontSize = this.chart.theme("treemapTextFontSize");

                        if(this.brush.textOrient == "top") {
                            cy = y + fontSize;
                        } else if(this.brush.textOrient == "bottom") {
                            cy = y + h - fontSize/2;
                        }

                        if(this.brush.textAlign == "start") {
                            cx = x + TEXT_MARGIN_LEFT;
                        } else if(this.brush.textAlign == "end") {
                            cx = x + w - TEXT_MARGIN_LEFT;
                        }

                        var text = this.chart.text({
                            "font-size": fontSize,
                            fill: this.chart.theme("treemapTextFontColor"),
                            x: cx,
                            y: cy,
                            "text-anchor": this.brush.textAlign
                        }, (_.typeCheck("function", this.brush.format) ? this.format(nodeList[i]) : nodeList[i].text));

                        g.append(text);
                    }

                    var elem = this.svg.rect({
                        stroke: this.chart.theme("treemapNodeBorderColor"),
                        "stroke-width": this.chart.theme("treemapNodeBorderWidth"),
                        x: x,
                        y: y,
                        width: w,
                        height: h,
                        fill: this.color(getRootNodeSeq(nodeList[i]))
                    });

                    if(_.typeCheck("function", this.brush.nodeColor)) {
                        var color = this.brush.nodeColor.call(this.chart, nodeList[i]);
                        elem.attr({ fill: this.color(color) });
                    }

                    this.addEvent(elem, nodeList[i]);
                    g.prepend(elem);
                }

                return g;
            }
        }

        TreemapBrush.setup = function() {
            return {
                /** @cfg {"top"/"center"/"bottom" } [orient="top"]  Determines the side on which the tool tip is displayed (top, center, bottom). */
                textOrient: "top", // or bottom
                /** @cfg {"start"/"middle"/"end" } [align="center"] Aligns the title message (start, middle, end).*/
                textAlign: "middle",
                showText: true,
                titleDepth: 1,
                nodeColor: null,
                clip: false,
                format: null
            };
        }

        return TreemapBrush;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/main.js":
/*!**********************************************!*\
  !*** ./node_modules/juijs-chart/src/main.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var juijs_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! juijs-graph */ "./node_modules/juijs-graph/dist/jui-graph.esm.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (juijs_graph__WEBPACK_IMPORTED_MODULE_0__.default);

/***/ }),

/***/ "./node_modules/juijs-chart/src/theme/classic.js":
/*!*******************************************************!*\
  !*** ./node_modules/juijs-chart/src/theme/classic.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.theme.classic",
    extend: null,
    component: function () {
        var themeColors = [
            "#7977C2",
            "#7BBAE7",
            "#FFC000",
            "#FF7800",
            "#87BB66",
            "#1DA8A0",
            "#929292",
            "#555D69",
            "#0298D5",
            "#FA5559",
            "#F5A397",
            "#06D9B6",
            "#C6A9D9",
            "#6E6AFC",
            "#E3E766",
            "#C57BC3",
            "#DF328B",
            "#96D7EB",
            "#839CB5",
            "#9228E4"
        ];

        return {
            fontFamily : "arial,Tahoma,verdana",
            backgroundColor : "#fff",
            colors : themeColors,

            // Axis styles
            axisBackgroundColor : "#fff",
            axisBackgroundOpacity : 0,
            axisBorderColor : "#fff",
            axisBorderWidth : 0,
            axisBorderRadius : 0,

            // Grid styles
            gridXFontSize : 11,
            gridYFontSize : 11,
            gridZFontSize : 10,
            gridCFontSize : 11,
            gridXFontColor : "#333",
            gridYFontColor : "#333",
            gridZFontColor : "#333",
            gridCFontColor : "#333",
            gridXFontWeight : "normal",
            gridYFontWeight : "normal",
            gridZFontWeight : "normal",
            gridCFontWeight : "normal",
            gridXAxisBorderColor : "#bfbfbf",
            gridYAxisBorderColor : "#bfbfbf",
            gridZAxisBorderColor : "#bfbfbf",
            gridXAxisBorderWidth : 2,
            gridYAxisBorderWidth : 2,
            gridZAxisBorderWidth : 2,

            // Full 3D 전용 테마
            gridFaceBackgroundColor: "#dcdcdc",
            gridFaceBackgroundOpacity: 0.3,

            gridActiveFontColor : "#ff7800",
            gridActiveBorderColor : "#ff7800",
            gridActiveBorderWidth : 1,
            gridPatternColor : "#ababab",
            gridPatternOpacity : 0.1,
            gridBorderColor : "#ebebeb",
            gridBorderWidth : 1,
            gridBorderDashArray : "none",
            gridBorderOpacity : 1,
            gridTickBorderSize : 3,
            gridTickBorderWidth : 1.5,
            gridTickPadding : 5,

            // Brush styles
            tooltipPointRadius : 5, // common
            tooltipPointBorderWidth : 1, // common
            tooltipPointFontWeight : "bold", // common
            tooltipPointFontSize : 11,
            tooltipPointFontColor : "#333",
            barFontSize : 11,
            barFontColor : "#333",
            barBorderColor : "none",
            barBorderWidth : 0,
            barBorderOpacity : 0,
            barBorderRadius : 3,
            barPointBorderColor : "#fff",
            barDisableBackgroundOpacity : 0.4,
            barStackEdgeBorderWidth : 1,
            rateBarFontSize : 11,
            rateBarFontColor : "#333",
            rateBarBorderColor : "none",
            rateBarBorderWidth : 0,
            rateBarBorderOpacity : 0,
            rateBarBorderRadius : 5,
            rateBarDisableBackgroundOpacity : 0.7,
            rateBarTooltipFontSize: 10,
            rateBarTooltipFontColor: "#333",
            rateBarTooltipBackgroundColor: "#fff",
            rateBarTooltipBorderColor: "#666666",
            gaugeBackgroundColor : "#ececec",
            gaugeArrowColor : "#a9a9a9",
            gaugeFontColor : "#666666",
            gaugeFontSize : 20,
            gaugeFontWeight : "bold",
            gaugeTitleFontSize : 12,
            gaugeTitleFontWeight : "normal",
            gaugeTitleFontColor : "#333",
            gaugePaddingAngle : 2,
            bargaugeBackgroundColor : "#ececec",
            bargaugeFontSize : 11,
            bargaugeFontColor : "#333333",
            pieBorderColor : "#ececec",
            pieBorderWidth : 1,
            pieOuterFontSize : 11,
            pieOuterFontColor : "#333",
            pieOuterLineColor : "#a9a9a9",
            pieOuterLineSize : 8,
            pieOuterLineRate : 1.3,
            pieOuterLineWidth : 0.7,
            pieInnerFontSize : 11,
            pieInnerFontColor : "#333",
            pieActiveDistance : 5,
            pieNoDataBackgroundColor : "#E9E9E9",
            pieTotalValueFontSize : 36,
            pieTotalValueFontColor : "#dcdcdc",
            pieTotalValueFontWeight : "bold",
            pieDisableBackgroundOpacity: 0.5,
            areaBackgroundOpacity : 0.5,
            areaSplitBackgroundColor : "#929292",
            bubbleBackgroundOpacity : 0.5,
            bubbleBorderWidth : 1,
            bubbleFontSize : 12,
            bubbleFontColor : "#fff",
            candlestickBorderColor : "#000",
            candlestickBackgroundColor : "#fff",
            candlestickInvertBorderColor : "#ff0000",
            candlestickInvertBackgroundColor : "#ff0000",
            ohlcBorderColor : "#000",
            ohlcInvertBorderColor : "#ff0000",
            ohlcBorderRadius : 5,
            lineBorderWidth : 2,
            lineBorderDashArray : "none",
            lineBorderOpacity : 1,
            lineDisableBorderOpacity : 0.3,
            linePointBorderColor : "#fff",
            lineSplitBorderColor : null,
            lineSplitBorderOpacity : 0.5,
            pathBackgroundOpacity : 0.5,
            pathBorderWidth : 1,
            scatterBorderColor : "#fff",
            scatterBorderWidth : 1,
            scatterHoverColor : "#fff",
            waterfallBackgroundColor : "#87BB66",
            waterfallInvertBackgroundColor : "#FF7800",
            waterfallEdgeBackgroundColor : "#7BBAE7",
            waterfallLineColor : "#a9a9a9",
            waterfallLineDashArray : "0.9",
            focusBorderColor : "#FF7800",
            focusBorderWidth : 1,
            focusBackgroundColor : "#FF7800",
            focusBackgroundOpacity : 0.1,
            pinFontColor : "#FF7800",
            pinFontSize : 10,
            pinBorderColor : "#FF7800",
            pinBorderWidth : 0.7,
            topologyNodeRadius : 12.5,
            topologyNodeFontSize : 14,
            topologyNodeFontColor : "#fff",
            topologyNodeTitleFontSize : 11,
            topologyNodeTitleFontColor : "#333",
            topologyEdgeWidth : 1,
            topologyActiveEdgeWidth : 2,
            topologyHoverEdgeWidth : 2,
            topologyEdgeColor : "#b2b2b2",
            topologyActiveEdgeColor : "#905ed1",
            topologyHoverEdgeColor : "#d3bdeb",
            topologyEdgeFontSize : 10,
            topologyEdgeFontColor : "#666",
            topologyEdgePointRadius : 3,
            topologyEdgeOpacity : 1,
            topologyTooltipBackgroundColor : "#fff",
            topologyTooltipBorderColor : "#ccc",
            topologyTooltipFontSize : 11,
            topologyTooltipFontColor : "#333",

            timelineTitleFontSize: 10,
            timelineTitleFontColor: "#333",
            timelineTitleFontWeight: 700,
            timelineColumnFontSize: 10,
            timelineColumnFontColor: "#333",
            timelineColumnBackgroundColor: "#fff",
            timelineHoverRowBackgroundColor: "#f4f0f9",
            timelineEvenRowBackgroundColor: "#f8f8f8",
            timelineOddRowBackgroundColor: "#fff",
            timelineActiveBarBackgroundColor: "#9262cf",
            timelineActiveBarFontColor: "#fff",
            timelineActiveBarFontSize: 9,
            timelineHoverBarBackgroundColor: null,
            timelineLayerBackgroundOpacity: 0.15,
            timelineActiveLayerBackgroundColor: "#A75CFF",
            timelineActiveLayerBorderColor: "#caa4f5",
            timelineHoverLayerBackgroundColor: "#DEC2FF",
            timelineHoverLayerBorderColor: "#caa4f5",
            timelineVerticalLineColor: "#f0f0f0",
            timelineHorizontalLineColor: "#ddd",

            // hudColumnGridPointRadius: 7,
            // hudColumnGridPointBorderColor: "#868686",
            // hudColumnGridPointBorderWidth: 2,
            // hudColumnGridFontColor: "#868686",
            // hudColumnGridFontSize: 12,
            // hudColumnGridFontWeight: "normal",
            // hudColumnLeftBackgroundColor: "#3C3C3C",
            // hudColumnRightBackgroundColor: "#838383",
            // hudBarGridFontColor: "#868686",
            // hudBarGridFontSize: 16,
            // hudBarGridLineColor: "#868686",
            // hudBarGridLineWidth: 1,
            // hudBarGridLineOpacity: 0.8,
            // hudBarGridBackgroundColor: "#868686",
            // hudBarGridBackgroundOpacity: 0.5,
            // hudBarTextLineColor: "#B2A6A6",
            // hudBarTextLineWidth: 1.5,
            // hudBarTextLinePadding: 12,
            // hudBarTextLineFontColor: "#868686",
            // hudBarTextLineFontSize: 13,
            // hudBarBackgroundOpacity: 0.6,
            // hudBarTopBackgroundColor: "#bbb",
            // hudBarBottomBackgroundColor: "#3C3C3C",

            heatmapBackgroundColor: "#fff",
            heatmapBackgroundOpacity: 1,
            heatmapHoverBackgroundOpacity: 0.2,
            heatmapBorderColor: "#000",
            heatmapBorderWidth: 0.5,
            heatmapBorderOpacity: 1,
            heatmapFontSize: 11,
            heatmapFontColor: "#000",

            pyramidLineColor: "#fff",
            pyramidLineWidth: 1,
            pyramidTextLineColor: "#a9a9a9",
            pyramidTextLineWidth: 1,
            pyramidTextLineSize: 30,
            pyramidTextFontSize: 10,
            pyramidTextFontColor: "#333",

            heatmapscatterBorderWidth: 0.5,
            heatmapscatterBorderColor: "#fff",
            heatmapscatterActiveBackgroundColor: "#fff",

            treemapNodeBorderWidth: 0.5,
            treemapNodeBorderColor: "#333",
            treemapTextFontSize: 11,
            treemapTextFontColor: "#333",
            treemapTitleFontSize: 12,
            treemapTitleFontColor: "#333",

            arcEqualizerBorderColor: "#fff",
            arcEqualizerBorderWidth: 1,
            arcEqualizerFontSize: 13,
            arcEqualizerFontColor: "#333",
            arcEqualizerBackgroundColor: "#a9a9a9",

            flameNodeBorderWidth: 0.5,
            flameNodeBorderColor: "#fff",
            flameDisableBackgroundOpacity: 0.4,
            flameTextFontSize: 11,
            flameTextFontColor: "#333",

            selectBoxBackgroundColor: "#666",
            selectBoxBackgroundOpacity: 0.1,
            selectBoxBorderColor: "#666",
            selectBoxBorderOpacity: 0.2,

            // Widget styles
            titleFontColor : "#333",
            titleFontSize : 13,
            titleFontWeight : "normal",
            legendFontColor : "#333",
            legendFontSize : 12,
            legendSwitchCircleColor : "#fff",
            legendSwitchDisableColor : "#c8c8c8",
            tooltipFontColor : "#333",
            tooltipFontSize : 12,
            tooltipBackgroundColor : "#fff",
            tooltipBackgroundOpacity : 0.7,
            tooltipBorderColor : null,
            tooltipBorderWidth : 2,
            tooltipLineColor : null,
            tooltipLineWidth : 0.7,
            scrollBackgroundSize : 7,
            scrollBackgroundColor : "#dcdcdc",
            scrollThumbBackgroundColor : "#b2b2b2",
            scrollThumbBorderColor : "#9f9fa4",
            zoomBackgroundColor : "#ff0000",
            zoomFocusColor : "#808080",
            zoomScrollBackgroundSize : 45,
            zoomScrollButtonSize : 18,
            zoomScrollAreaBackgroundColor : "#fff",
            zoomScrollAreaBackgroundOpacity : 0.7,
            zoomScrollAreaBorderColor : "#d4d4d4",
            zoomScrollAreaBorderWidth : 1,
            zoomScrollAreaBorderRadius : 3,
            zoomScrollGridFontSize : 10,
            zoomScrollGridTickPadding : 4,
            zoomScrollBrushAreaBackgroundOpacity : 0.7,
            zoomScrollBrushLineBorderWidth : 1,
            crossBorderColor : "#a9a9a9",
            crossBorderWidth : 1,
            crossBorderOpacity : 0.8,
            crossBalloonFontSize : 11,
            crossBalloonFontColor : "#fff",
            crossBalloonBackgroundColor : "#000",
            crossBalloonBackgroundOpacity : 0.5,
            dragSelectBackgroundColor : "#7BBAE7",
            dragSelectBackgroundOpacity : 0.3,
            dragSelectBorderColor : "#7BBAE7",
            dragSelectBorderWidth : 1,

            guidelineBorderColor : "#a9a9a9",
            guidelineBorderWidth : 1,
            guidelineBorderOpacity : 0.8,
            guidelineBalloonFontSize : 11,
            guidelineBalloonFontColor : "#fff",
            guidelineBalloonBackgroundColor : "#000",
            guidelineBalloonBackgroundOpacity : 0.5,
            guidelineBorderDashArray : "2,2",
            guidelinePointRadius : 3,
            guidelinePointBorderColor : "#fff",
            guidelinePointBorderWidth : 1,
            guidelineTooltipFontColor : "#333",
            guidelineTooltipFontSize : 12,
            guidelineTooltipPointRadius : 3,
            guidelineTooltipBackgroundColor : "#fff",
            guidelineTooltipBackgroundOpacity : 0.7,
            guidelineTooltipBorderColor : "#a9a9a9",
            guidelineTooltipBorderWidth : 1,

            // mapPathBackgroundColor : "#67B7DC",
            // mapPathBackgroundOpacity : 1,
            // mapPathBorderColor : "#fff",
            // mapPathBorderWidth : 1,
            // mapPathBorderOpacity : 1,
            // mapBubbleBackgroundOpacity : 0.5,
            // mapBubbleBorderWidth : 1,
            // mapBubbleFontSize : 11,
            // mapBubbleFontColor : "#fff",
            // mapSelectorHoverColor : "#5a73db",
            // mapSelectorActiveColor : "#CC0000",
            // mapFlightRouteAirportSmallColor : "#CC0000",
            // mapFlightRouteAirportLargeColor : "#000",
            // mapFlightRouteAirportBorderWidth : 2,
            // mapFlightRouteAirportRadius : 8,
            // mapFlightRouteLineColor : "#ff0000",
            // mapFlightRouteLineWidth : 1,
            // mapWeatherBackgroundColor : "#fff",
            // mapWeatherBorderColor : "#a9a9a9",
            // mapWeatherFontSize : 11,
            // mapWeatherTitleFontColor : "#666",
            // mapWeatherInfoFontColor : "#ff0000",
            // mapCompareBubbleMaxLineColor : "#fff",
            // mapCompareBubbleMaxLineDashArray : "2,2",
            // mapCompareBubbleMaxBorderColor : "#fff",
            // mapCompareBubbleMaxFontSize : 36,
            // mapCompareBubbleMaxFontColor : "#fff",
            // mapCompareBubbleMinBorderColor : "#ffff00",
            // mapCompareBubbleMinFontSize : 24,
            // mapCompareBubbleMinFontColor : "#000",
            // mapControlButtonColor : "#3994e2",
            // mapControlLeftButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAP///wAAACH5BAUAAAEALAAAAAALAAsAAAIQjI9poMcdXpOKTujw0pGjAgA7",
            // mapControlRightButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAP///wAAACH5BAUAAAEALAAAAAALAAsAAAIQjI8JycvonomSKhksxBqbAgA7",
            // mapControlTopButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAP///wAAACH5BAUAAAEALAAAAAALAAsAAAIQjI+pCmvd2IkzUYqw27yfAgA7",
            // mapControlBottomButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAP///wAAACH5BAUAAAEALAAAAAALAAsAAAIQjI+pyw37TDxTUhhq0q2fAgA7",
            // mapControlHomeButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAAAAAAAAACH5BAUAAAEALAAAAAALAAsAAAIZjI8ZoAffIERzMVMxm+9KvIBh6Imb2aVMAQA7",
            // mapControlUpButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAP///wAAACH5BAUAAAEALAAAAAALAAsAAAISjI8ZoMhtHpQH2HsV1TD29SkFADs=",
            // mapControlDownButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAP///wAAACH5BAUAAAEALAAAAAALAAsAAAIMjI+py+0BopSv2qsKADs=",
            // mapControlScrollColor : "#000",
            // mapControlScrollLineColor : "#fff",
            // mapMinimapBackgroundColor : "transparent",
            // mapMinimapBorderColor : "transparent",
            // mapMinimapBorderWidth : 1,
            // mapMinimapPathBackgroundColor : "#67B7DC",
            // mapMinimapPathBackgroundOpacity : 0.5,
            // mapMinimapPathBorderColor : "#67B7DC",
            // mapMinimapPathBorderWidth : 0.5,
            // mapMinimapPathBorderOpacity : 0.1,
            // mapMinimapDragBackgroundColor : "#7CC7C3",
            // mapMinimapDragBackgroundOpacity : 0.3,
            // mapMinimapDragBorderColor : "#56B4AF",
            // mapMinimapDragBorderWidth : 1,

            // Polygon Brushes
            polygonColumnBackgroundOpacity: 0.6,
            polygonColumnBorderOpacity: 0.5,
            polygonScatterRadialOpacity: 0.7,
            polygonScatterBackgroundOpacity: 0.8,
            polygonLineBackgroundOpacity: 0.6,
            polygonLineBorderOpacity: 0.7,

            // Animation Brushes
            bubbleCloudFontColor: "#fff",
            bubbleCloudFontSize: 11,
            bubbleCloudFontWeight: "bold",

            equalizerColumnErrorBackgroundColor: "#ff0000",
            equalizerColumnErrorFontColor: "#fff"
        }
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/theme/dark.js":
/*!****************************************************!*\
  !*** ./node_modules/juijs-chart/src/theme/dark.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.theme.dark",
    extend: null,
    component: function () {
        var themeColors = [
            "#12f2e8",
            "#26f67c",
            "#e9f819",
            "#b78bf9",
            "#f94590",
            "#8bccf9",
            "#9228e4",
            "#06d9b6",
            "#fc6d65",
            "#f199ff",
            "#c8f21d",
            "#16a6e5",
            "#00ba60",
            "#91f2a1",
            "#fc9765",
            "#f21d4f"
        ];

        return {
            fontFamily : "arial,Tahoma,verdana",
            backgroundColor : "#222222",
            colors : themeColors,

            // Axis styles
            axisBackgroundColor : "#222222",
            axisBackgroundOpacity : 0,
            axisBorderColor : "#222222",
            axisBorderWidth : 0,
            axisBorderRadius : 0,

            // Grid styles
            gridXFontSize : 11,
            gridYFontSize : 11,
            gridZFontSize : 10,
            gridCFontSize : 11,
            gridXFontColor : "#868686",
            gridYFontColor : "#868686",
            gridZFontColor : "#868686",
            gridCFontColor : "#868686",
            gridXFontWeight : "normal",
            gridYFontWeight : "normal",
            gridZFontWeight : "normal",
            gridCFontWeight : "normal",
            gridXAxisBorderColor : "#464646",
            gridYAxisBorderColor : "#464646",
            gridZAxisBorderColor : "#464646",
            gridXAxisBorderWidth : 2,
            gridYAxisBorderWidth : 2,
            gridZAxisBorderWidth : 2,

            // Full 3D 전용 테마
            gridFaceBackgroundColor: "#dcdcdc",
            gridFaceBackgroundOpacity: 0.3,

            gridActiveFontColor : "#ff762d",
            gridActiveBorderColor : "#ff7800",
            gridActiveBorderWidth : 1,
            gridPatternColor : "#ababab",
            gridPatternOpacity : 0.1,
            gridBorderColor : "#868686",
            gridBorderWidth : 1,
            gridBorderDashArray : "none",
            gridBorderOpacity : 1,
            gridTickBorderSize : 3,
            gridTickBorderWidth : 1.5,
            gridTickPadding : 5,

            // Brush styles
            tooltipPointRadius : 5, // common
            tooltipPointBorderWidth : 1, // common
            tooltipPointFontWeight : "bold", // common
            tooltipPointFontSize : 11,
            tooltipPointFontColor : "#868686",
            barFontSize : 11,
            barFontColor : "#868686",
            barBorderColor : "none",
            barBorderWidth : 0,
            barBorderOpacity : 0,
            barBorderRadius : 3,
            barActiveBackgroundColor : "#fc6d65",
            barPointBorderColor : "#fff",
            barDisableBackgroundOpacity : 0.4,
            barStackEdgeBorderWidth : 1,
            rateBarFontSize : 11,
            rateBarFontColor : "#868686",
            rateBarBorderColor : "none",
            rateBarBorderWidth : 0,
            rateBarBorderOpacity : 0,
            rateBarBorderRadius : 5,
            rateBarDisableBackgroundOpacity : 0.7,
            rateBarTooltipFontSize: 10,
            rateBarTooltipFontColor: "#868686",
            rateBarTooltipBackgroundColor: "#222",
            rateBarTooltipBorderColor: "#666666",
            gaugeBackgroundColor : "#3e3e3e",
            gaugeArrowColor : "#a6a6a6",
            gaugeFontColor : "#c5c5c5",
            gaugeFontSize : 20,
            gaugeFontWeight : "bold",
            gaugeTitleFontSize : 12,
            gaugeTitleFontWeight : "normal",
            gaugeTitleFontColor : "#c5c5c5",
            gaugePaddingAngle : 2,
            bargaugeBackgroundColor : "#3e3e3e",
            bargaugeFontSize : 11,
            bargaugeFontColor : "#c5c5c5",
            pieBorderColor : "#232323",
            pieBorderWidth : 1,
            pieOuterFontSize : 11,
            pieOuterFontColor : "#868686",
            pieOuterLineColor : "#a9a9a9",
            pieOuterLineSize : 8,
            pieOuterLineRate : 1.3,
            pieOuterLineWidth : 0.7,
            pieInnerFontSize : 11,
            pieInnerFontColor : "#868686",
            pieActiveDistance : 5,
            pieNoDataBackgroundColor : "#E9E9E9",
            pieTotalValueFontSize : 36,
            pieTotalValueFontColor : "#dcdcdc",
            pieTotalValueFontWeight : "bold",
            pieDisableBackgroundOpacity: 0.5,
            areaBackgroundOpacity : 0.5,
            areaSplitBackgroundColor : "#ebebeb",
            bubbleBackgroundOpacity : 0.5,
            bubbleBorderWidth : 1,
            bubbleFontSize : 12,
            bubbleFontColor : "#868686",
            candlestickBorderColor : "#14be9d",
            candlestickBackgroundColor : "#14be9d",
            candlestickInvertBorderColor : "#ff4848",
            candlestickInvertBackgroundColor : "#ff4848",
            ohlcBorderColor : "#14be9d",
            ohlcInvertBorderColor : "#ff4848",
            ohlcBorderRadius : 5,
            lineBorderWidth : 2,
            lineBorderDashArray : "none",
            lineBorderOpacity : 1,
            lineDisableBorderOpacity : 0.3,
            linePointBorderColor : "#fff",
            lineSplitBorderColor : null,
            lineSplitBorderOpacity : 0.5,
            pathBackgroundOpacity : 0.2,
            pathBorderWidth : 1,
            scatterBorderColor : "none",
            scatterBorderWidth : 1,
            scatterHoverColor : "#222222",
            waterfallBackgroundColor : "#26f67c",
            waterfallInvertBackgroundColor : "#f94590",
            waterfallEdgeBackgroundColor : "#8bccf9",
            waterfallLineColor : "#a9a9a9",
            waterfallLineDashArray : "0.9",
            focusBorderColor : "#FF7800",
            focusBorderWidth : 1,
            focusBackgroundColor : "#FF7800",
            focusBackgroundOpacity : 0.1,
            pinFontColor : "#FF7800",
            pinFontSize : 10,
            pinBorderColor : "#FF7800",
            pinBorderWidth : 0.7,

            topologyNodeRadius : 12.5,
            topologyNodeFontSize : 14,
            topologyNodeFontColor : "#c5c5c5",
            topologyNodeTitleFontSize : 11,
            topologyNodeTitleFontColor : "#c5c5c5",
            topologyEdgeWidth : 1,
            topologyActiveEdgeWidth : 2,
            topologyHoverEdgeWidth : 2,
            topologyEdgeColor : "#b2b2b2",
            topologyActiveEdgeColor : "#905ed1",
            topologyHoverEdgeColor : "#d3bdeb",
            topologyEdgeFontSize : 10,
            topologyEdgeFontColor : "#c5c5c5",
            topologyEdgePointRadius : 3,
            topologyEdgeOpacity : 1,
            topologyTooltipBackgroundColor : "#222222",
            topologyTooltipBorderColor : "#ccc",
            topologyTooltipFontSize : 11,
            topologyTooltipFontColor : "#c5c5c5",

            timelineTitleFontSize: 11,
            timelineTitleFontColor: "#d5d5d5",
            timelineTitleFontWeight: 700,
            timelineColumnFontSize: 10,
            timelineColumnFontColor: "#d5d5d5",
            timelineColumnBackgroundColor: "#1c1c1c",
            timelineHoverRowBackgroundColor: "#2f2f2f",
            timelineEvenRowBackgroundColor: "#202020",
            timelineOddRowBackgroundColor: "#1c1c1c",
            timelineActiveBarBackgroundColor: "#6f32ba",
            timelineActiveBarFontColor: "#fff",
            timelineActiveBarFontSize: 9,
            timelineHoverBarBackgroundColor: null,
            timelineLayerBackgroundOpacity: 0.1,
            timelineActiveLayerBackgroundColor: "#7F5FA4",
            timelineActiveLayerBorderColor: "#7f5fa4",
            timelineHoverLayerBackgroundColor: "#7F5FA4",
            timelineHoverLayerBorderColor: "#7f5fa4",
            timelineVerticalLineColor: "#2f2f2f",
            timelineHorizontalLineColor: "#4d4d4d",

            // hudColumnGridPointRadius: 7,
            // hudColumnGridPointBorderColor: "#868686",
            // hudColumnGridPointBorderWidth: 2,
            // hudColumnGridFontColor: "#868686",
            // hudColumnGridFontSize: 12,
            // hudColumnGridFontWeight: "normal",
            // hudColumnLeftBackgroundColor: "#3C3C3C",
            // hudColumnRightBackgroundColor: "#838383",
            // hudBarGridFontColor: "#868686",
            // hudBarGridFontSize: 16,
            // hudBarGridLineColor: "#868686",
            // hudBarGridLineWidth: 1,
            // hudBarGridLineOpacity: 0.8,
            // hudBarGridBackgroundColor: "#868686",
            // hudBarGridBackgroundOpacity: 0.5,
            // hudBarTextLineColor: "#B2A6A6",
            // hudBarTextLineWidth: 1.5,
            // hudBarTextLinePadding: 12,
            // hudBarTextLineFontColor: "#868686",
            // hudBarTextLineFontSize: 13,
            // hudBarBackgroundOpacity: 0.6,
            // hudBarTopBackgroundColor: "#bbb",
            // hudBarBottomBackgroundColor: "#3C3C3C",

            heatmapBackgroundColor: "#222222",
            heatmapBackgroundOpacity: 1,
            heatmapHoverBackgroundOpacity: 0.2,
            heatmapBorderColor: "#fff",
            heatmapBorderWidth: 0.5,
            heatmapBorderOpacity: 1,
            heatmapFontSize: 11,
            heatmapFontColor: "#868686",

            pyramidLineColor: "#464646",
            pyramidLineWidth: 1,
            pyramidTextLineColor: "#B2A6A6",
            pyramidTextLineWidth: 1,
            pyramidTextLineSize: 30,
            pyramidTextFontSize: 10,
            pyramidTextFontColor: "#222",

            heatmapscatterBorderWidth: 0.5,
            heatmapscatterBorderColor: "#222222",
            heatmapscatterActiveBackgroundColor: "#222222",

            treemapNodeBorderWidth: 0.5,
            treemapNodeBorderColor: "#222222",
            treemapTextFontSize: 11,
            treemapTextFontColor: "#868686",
            treemapTitleFontSize: 12,
            treemapTitleFontColor: "#868686",

            arcEqualizerBorderColor: "#222222",
            arcEqualizerBorderWidth: 1,
            arcEqualizerFontSize: 13,
            arcEqualizerFontColor: "#868686",
            arcEqualizerBackgroundColor: "#222222",

            flameNodeBorderWidth: 0.5,
            flameNodeBorderColor: "#222",
            flameDisableBackgroundOpacity: 0.4,
            flameTextFontSize: 12,
            flameTextFontColor: "#868686",

            selectBoxBackgroundColor: "#fff",
            selectBoxBackgroundOpacity: 0.1,
            selectBoxBorderColor: "#fff",
            selectBoxBorderOpacity: 0.2,

            // widget styles
            titleFontColor : "#ffffff",
            titleFontSize : 14,
            titleFontWeight : "normal",
            legendFontColor : "#ffffff",
            legendFontSize : 11,
            legendSwitchCircleColor : "#fff",
            legendSwitchDisableColor : "#c8c8c8",
            tooltipFontColor : "#333333",
            tooltipFontSize : 12,
            tooltipBackgroundColor : "#fff",
            tooltipBackgroundOpacity : 1,
            tooltipBorderColor : null,
            tooltipBorderWidth : 2,
            tooltipLineColor : null,
            tooltipLineWidth : 1,
            scrollBackgroundSize : 7,
            scrollBackgroundColor : "#3e3e3e",
            scrollThumbBackgroundColor : "#666666",
            scrollThumbBorderColor : "#686868",
            zoomBackgroundColor : "#ff0000",
            zoomFocusColor : "#808080",
            zoomScrollBackgroundSize : 45,
            zoomScrollButtonSize : 18,
            zoomScrollAreaBackgroundColor : "#fff",
            zoomScrollAreaBackgroundOpacity : 0.7,
            zoomScrollAreaBorderColor : "#d4d4d4",
            zoomScrollAreaBorderWidth : 1,
            zoomScrollAreaBorderRadius : 3,
            zoomScrollGridFontSize : 10,
            zoomScrollGridTickPadding : 4,
            zoomScrollBrushAreaBackgroundOpacity : 0.7,
            zoomScrollBrushLineBorderWidth : 1,
            crossBorderColor : "#a9a9a9",
            crossBorderWidth : 1,
            crossBorderOpacity : 0.8,
            crossBalloonFontSize : 11,
            crossBalloonFontColor : "#333",
            crossBalloonBackgroundColor : "#fff",
            crossBalloonBackgroundOpacity : 1,
            dragSelectBackgroundColor : "#7BBAE7",
            dragSelectBackgroundOpacity : 0.3,
            dragSelectBorderColor : "#7BBAE7",
            dragSelectBorderWidth : 1,

            guidelineBorderColor : "#a9a9a9",
            guidelineBorderWidth : 1,
            guidelineBorderOpacity : 0.8,
            guidelineBalloonFontSize : 11,
            guidelineBalloonFontColor : "#fff",
            guidelineBalloonBackgroundColor : "#000",
            guidelineBalloonBackgroundOpacity : 0.5,
            guidelineBorderDashArray : "2,2",
            guidelinePointRadius : 3,
            guidelinePointBorderColor : "#fff",
            guidelinePointBorderWidth : 1,
            guidelineTooltipFontColor : "#333",
            guidelineTooltipFontSize : 12,
            guidelineTooltipPointRadius : 3,
            guidelineTooltipBackgroundColor : "#fff",
            guidelineTooltipBackgroundOpacity : 0.7,
            guidelineTooltipBorderColor : "#a9a9a9",
            guidelineTooltipBorderWidth : 1,

            // mapPathBackgroundColor : "#67B7DC",
            // mapPathBackgroundOpacity : 1,
            // mapPathBorderColor : "#fff",
            // mapPathBorderWidth : 1,
            // mapPathBorderOpacity : 1,
            // mapBubbleBackgroundOpacity : 0.5,
            // mapBubbleBorderWidth : 1,
            // mapBubbleFontSize : 11,
            // mapBubbleFontColor : "#868686",
            // mapSelectorHoverColor : "#5a73db",
            // mapSelectorActiveColor : "#CC0000",
            // mapFlightRouteAirportSmallColor : "#CC0000",
            // mapFlightRouteAirportLargeColor : "#000",
            // mapFlightRouteAirportBorderWidth : 2,
            // mapFlightRouteAirportRadius : 8,
            // mapFlightRouteLineColor : "#ff0000",
            // mapFlightRouteLineWidth : 1,
            // mapWeatherBackgroundColor : "#fff",
            // mapWeatherBorderColor : "#a9a9a9",
            // mapWeatherFontSize : 11,
            // mapWeatherTitleFontColor : "#666",
            // mapWeatherInfoFontColor : "#ff0000",
            // mapCompareBubbleMaxLineColor : "#fff",
            // mapCompareBubbleMaxLineDashArray : "2,2",
            // mapCompareBubbleMaxBorderColor : "#fff",
            // mapCompareBubbleMaxFontSize : 36,
            // mapCompareBubbleMaxFontColor : "#fff",
            // mapCompareBubbleMinBorderColor : "#ffff00",
            // mapCompareBubbleMinFontSize : 24,
            // mapCompareBubbleMinFontColor : "#000",
            // mapControlButtonColor : "#3994e2",
            // mapControlLeftButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAP///wAAACH5BAUAAAEALAAAAAALAAsAAAIQjI9poMcdXpOKTujw0pGjAgA7",
            // mapControlRightButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAP///wAAACH5BAUAAAEALAAAAAALAAsAAAIQjI8JycvonomSKhksxBqbAgA7",
            // mapControlTopButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAP///wAAACH5BAUAAAEALAAAAAALAAsAAAIQjI+pCmvd2IkzUYqw27yfAgA7",
            // mapControlBottomButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAP///wAAACH5BAUAAAEALAAAAAALAAsAAAIQjI+pyw37TDxTUhhq0q2fAgA7",
            // mapControlHomeButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAAAAAAAAACH5BAUAAAEALAAAAAALAAsAAAIZjI8ZoAffIERzMVMxm+9KvIBh6Imb2aVMAQA7",
            // mapControlUpButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAP///wAAACH5BAUAAAEALAAAAAALAAsAAAISjI8ZoMhtHpQH2HsV1TD29SkFADs=",
            // mapControlDownButtonImage : "data:image/gif;base64,R0lGODlhCwALAPABAP///wAAACH5BAUAAAEALAAAAAALAAsAAAIMjI+py+0BopSv2qsKADs=",
            // mapControlScrollColor : "#000",
            // mapControlScrollLineColor : "#fff",
            // mapMinimapBackgroundColor : "transparent",
            // mapMinimapBorderColor : "transparent",
            // mapMinimapBorderWidth : 1,
            // mapMinimapPathBackgroundColor : "#67B7DC",
            // mapMinimapPathBackgroundOpacity : 0.5,
            // mapMinimapPathBorderColor : "#67B7DC",
            // mapMinimapPathBorderWidth : 0.5,
            // mapMinimapPathBorderOpacity : 0.1,
            // mapMinimapDragBackgroundColor : "#7CC7C3",
            // mapMinimapDragBackgroundOpacity : 0.3,
            // mapMinimapDragBorderColor : "#56B4AF",
            // mapMinimapDragBorderWidth : 1,

            // Polygon Brushes
            polygonColumnBackgroundOpacity: 0.6,
            polygonColumnBorderOpacity: 0.5,
            polygonScatterRadialOpacity: 0.7,
            polygonScatterBackgroundOpacity: 0.8,
            polygonLineBackgroundOpacity: 0.6,
            polygonLineBorderOpacity: 0.7,

            // Animation Brushes
            bubbleCloudFontColor: "#fff",
            bubbleCloudFontSize: 11,
            bubbleCloudFontWeight: "bold",

            equalizerColumnErrorBackgroundColor: "#ff0000",
            equalizerColumnErrorFontColor: "#fff"
        }
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/widget/canvas/picker.js":
/*!**************************************************************!*\
  !*** ./node_modules/juijs-chart/src/widget/canvas/picker.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../main */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.widget.canvas.picker",
    extend: "chart.widget.core",
    component: function() {
        const _ = _main__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");

        const CanvasPickerWidget = function() {
            this.emitActiveEvent = function(brush, eventType) {
                this.on(`axis.${eventType}`, function(e) {
                    let checker = this.chart.getCache('picker');

                    if(checker != null) {
                        let data = checker.func.call(checker.obj, e.chartX, e.chartY);

                        if(data != null) {
                            this.chart.emit(`picker.${eventType}`, [{
                                brush: brush,
                                data: data
                            }, e]);
                        }
                    }
                }, brush.axis);
            }

            this.setCanvasEvents = function(brush) {
                if(this.widget.hover) {
                    this.on('axis.mousemove', function (e) {
                        let checker = this.chart.getCache('picker');

                        if (checker != null) {
                            checker.func.call(checker.obj, e.chartX, e.chartY);
                        }
                    }, brush.axis);
                }

                this.emitActiveEvent(brush, 'click');
                this.emitActiveEvent(brush, 'dblclick');
            }

            this.draw = function() {
                let g = this.chart.svg.group(),
                    bIndex = this.widget.brush,
                    bIndexes = (_.typeCheck("array", bIndex) ? bIndex : [ bIndex ]);

                for(let i = 0; i < bIndexes.length; i++) {
                    let brush = this.chart.get("brush", bIndexes[i]);
                    this.setCanvasEvents(brush);
                }

                return g;
            }
        }

        CanvasPickerWidget.setup = function() {
            return {
                hover: false,
                brush: [ 0 ]
            }
        }

        return CanvasPickerWidget;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/widget/cross.js":
/*!******************************************************!*\
  !*** ./node_modules/juijs-chart/src/widget/cross.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.widget.cross",
    extend: "chart.widget.core",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");

        var CrossWidget = function(chart, axis, widget) {
            var self = this;
            var tw = 50, th = 18, ta = tw / 10; // 툴팁 넓이, 높이, 앵커 크기
            var pl = 0, pt = 0; // 엑시스까지의 여백
            var g, xline, yline, xTooltip, yTooltip;
            var tspan = [];

            function printTooltip(index, text, message) {
                if(!tspan[index]) {
                    var elem = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
                    text.element.appendChild(elem);
                    tspan[index] = elem;
                }

                tspan[index].textContent = message;
            }

            this.drawBefore = function() {
                // 위젯 옵션에 따라 엑시스 변경
                axis = this.chart.axis(widget.axis);

                // 엑시스 여백 값 가져오기
                pl = chart.padding("left") + axis.area("x");
                pt = chart.padding("top") + axis.area("y");

                g = chart.svg.group({
                    visibility: "hidden"
                }, function() {
                    // 포맷 옵션이 없을 경우, 툴팁을 생성하지 않음
                    if(_.typeCheck("function", widget.yFormat)) {
                        xline = chart.svg.line({
                            x1: 0,
                            y1: 0,
                            x2: axis.area("width"),
                            y2: 0,
                            stroke: chart.theme("crossBorderColor"),
                            "stroke-width": chart.theme("crossBorderWidth"),
                            opacity: chart.theme("crossBorderOpacity")
                        });

                        yTooltip = chart.svg.group({}, function () {
                            chart.svg.polygon({
                                fill: chart.theme("crossBalloonBackgroundColor"),
                                "fill-opacity": chart.theme("crossBalloonBackgroundOpacity"),
                                points: self.balloonPoints("left", tw, th, ta)
                            });

                            chart.text({
                                "font-size": chart.theme("crossBalloonFontSize"),
                                "fill": chart.theme("crossBalloonFontColor"),
                                "text-anchor": "middle",
                                x: tw / 2,
                                y: 12
                            });
                        }).translate(-(tw + ta), 0);
                    }

                    if(_.typeCheck("function", widget.xFormat)) {
                        yline = chart.svg.line({
                            x1: 0,
                            y1: 0,
                            x2: 0,
                            y2: axis.area("height"),
                            stroke: chart.theme("crossBorderColor"),
                            "stroke-width": chart.theme("crossBorderWidth"),
                            opacity: chart.theme("crossBorderOpacity")
                        });

                        xTooltip = chart.svg.group({}, function () {
                            chart.svg.polygon({
                                fill: chart.theme("crossBalloonBackgroundColor"),
                                "fill-opacity": chart.theme("crossBalloonBackgroundOpacity"),
                                points: self.balloonPoints("bottom", tw, th, ta)
                            });

                            chart.text({
                                "font-size": chart.theme("crossBalloonFontSize"),
                                "fill": chart.theme("crossBalloonFontColor"),
                                "text-anchor": "middle",
                                x: tw / 2,
                                y: 17
                            });
                        }).translate(0, axis.area("height") + ta);
                    }
                }).translate(pl, pt);
            }

            this.draw = function() {
                this.on("axis.mouseover", function(e) {
                    g.attr({ visibility: "visible" });
                }, widget.axis);

                this.on("axis.mouseout", function(e) {
                    g.attr({ visibility: "hidden" });
                }, widget.axis);

                this.on("axis.mousemove", function(e) {
                    g.attr({ visibility: "visible" });
                    var offset=3;

                    var left = e.bgX - pl + offset,
                        top = e.bgY - pt + offset;

                    if(xline) {
                        xline.attr({
                            y1: top,
                            y2: top
                        });
                    }

                    if(yline) {
                        yline.attr({
                            x1: left,
                            x2: left
                        });
                    }

                    // 포맷 옵션이 없을 경우, 처리하지 않음
                    if(yTooltip) {
                        yTooltip.translate(-(tw + ta), top - (th / 2));

                        var value = axis.y.invert(e.chartY+offset),
                            message = widget.yFormat.call(self.chart, value);
                        printTooltip(0, yTooltip.get(1), message);
                    }

                    if(xTooltip) {
                        xTooltip.translate(left - (tw / 2), axis.area("height") + ta);

                        var value = axis.x.invert(e.chartX+offset),
                            message = widget.xFormat.call(self.chart, value);
                        printTooltip(1, xTooltip.get(1), message);
                    }
                }, widget.axis);

                return g;
            }
        }

        CrossWidget.setup = function() {
            return {
                axis: 0,

                /**
                 * @cfg {Function} [xFormat=null] Sets the format for the value on the X axis shown on the tooltip.
                 */
                xFormat: null,
                /**
                 * @cfg {Function} [yFormat=null] Sets the format for the value on the Y axis shown on the tooltip.
                 */
                yFormat: null
            };
        }

        return CrossWidget;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/widget/legend.js":
/*!*******************************************************!*\
  !*** ./node_modules/juijs-chart/src/widget/legend.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.widget.legend",
    extend: "chart.widget.core",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");
        var WIDTH = 17, HEIGHT = 13, PADDING = 5, RADIUS = 5.5, RATIO = 1.2, POINT = 2;

        var LegendWidget = function(chart, axis, widget) {
            var columns = [];
            var colorIndex = {};

            function getIndexArray(brush) {
                var list = [ 0 ];

                if(_.typeCheck("array", brush)) {
                    list = brush;
                } else if(_.typeCheck("integer", brush)) {
                    list = [ brush ];
                }

                return list;
            }

            function getBrushAll() {
                var list = getIndexArray(widget.brush),
                    result = [];

                for(var i = 0; i < list.length; i++) {
                    result[i] = chart.get("brush", list[i]);
                }

                return result;
            }

            function setLegendStatus(brush) {
                if(!widget.filter) return;

                if(!columns[brush.index]) {
                    columns[brush.index] = {};
                }

                for(var i = 0; i < brush.target.length; i++) {
                    columns[brush.index][brush.target[i]] = true;
                }
            }

            function changeTargetOption(brushList) {
                var target = [],
                    colors = [],
                    index = brushList[0].index;

                for(var key in columns[index]) {
                    if(columns[index][key]) {
                        target.push(key);
                        colors.push(colorIndex[key]);
                    }
                }

                for(var i = 0; i < brushList.length; i++) {
                    chart.updateBrush(brushList[i].index, {
                        target: target,
                        colors: colors
                    });
                }

                // 차트 렌더링이 활성화되지 않았을 경우
                if(!chart.isRender()) {
                    chart.render();
                }

                chart.setCache(`legend_target`, target);
                chart.emit("legend.filter", [ target ]);
            }

            this.getLegendIcon = function(brush) {
                var arr = [],
                    data = brush.target,
                    count = data.length;

                for(var i = 0; i < count; i++) {
                    var group = chart.svg.group(),
                        target = brush.target[i],
                        text = target,
                        color = chart.color(i, widget.colors || brush.colors);

                    // 컬러 인덱스 설정
                    colorIndex[target] = color;

                    // 타겟 별 포맷 설정
                    if(_.typeCheck("function", widget.format)) {
                        text = this.format(target);
                    }

                    // 텍스트 길이 구하기
                    var rect = chart.svg.getTextSize(text, {
                        fontSize : chart.theme('legendFontSize')
                    });

                    if(widget.filter) {
                        group.append(chart.svg.line({
                            x1: 0,
                            x2: WIDTH,
                            y1: -(RADIUS / 2),
                            y2: -(RADIUS / 2),
                            stroke: color,
                            "stroke-width": HEIGHT,
                            "stroke-linecap": "round"
                        }));

                        group.append(chart.svg.circle({
                            cx : WIDTH,
                            cy : -(RADIUS / 2),
                            r : RADIUS,
                            fill : chart.theme("legendSwitchCircleColor")
                        }));

                        group.append(chart.text({
                            x : WIDTH + (PADDING * 2),
                            y : 0,
                            "font-size" : chart.theme("legendFontSize"),
                            "fill" : chart.theme("legendFontColor"),
                            "text-anchor" : "start"
                        }, text));

                        arr.push({
                            icon : group,
                            width : WIDTH + rect.width + (PADDING * 2.5),
                            height : HEIGHT + (PADDING / 2)
                        });

                        (function(key, element) {
                            element.attr({
                                cursor: "pointer"
                            });

                            element.on("click", function(e) {
                                if(columns[brush.index][key]) {
                                    element.get(0).attr({ stroke: chart.theme("legendSwitchDisableColor") });
                                    element.get(2).attr({ fill: chart.theme("legendSwitchDisableColor") });
                                    element.get(1).attr({ cx: 0 });
                                    columns[brush.index][key] = false;
                                } else {
                                    element.get(0).attr({ stroke: colorIndex[key] });
                                    element.get(2).attr({ fill: chart.theme("legendFontColor") });
                                    element.get(1).attr({ cx: WIDTH });
                                    columns[brush.index][key] = true;
                                }

                                changeTargetOption((widget.brushSync) ? getBrushAll() : [ brush ]);
                            });
                        })(target, group);
                    } else {
                        var size = chart.theme("legendFontSize");

                        if(widget.icon != null) {
                            var icon = _.typeCheck("function", widget.icon) ? widget.icon.apply(chart, [ target ]) : widget.icon;

                            group.append(chart.text({
                                x: 0,
                                y: POINT,
                                "font-size": size,
                                "fill": color
                            }, icon));
                        } else {
                            group.append(chart.svg.circle({
                                cx : size / 2,
                                cy : -POINT,
                                r : size / 2,
                                fill : color
                            }));
                        }

                        group.append(chart.text({
                            x : size * RATIO,
                            y : 0,
                            "font-size" : size,
                            "fill" : chart.theme("legendFontColor"),
                            "text-anchor" : "start"
                        }, text));

                        arr.push({
                            icon : group,
                            width : size + rect.width + (PADDING * 2),
                            height : HEIGHT + (PADDING / 2)
                        });
                    }
                }

                return arr;
            }

            this.draw = function() {
                var group = chart.svg.group();

                var x = 0,
                    y = 0,
                    total_width = 0,
                    total_height = 0,
                    max_width = 0,
                    max_height = 0,
                    brushes = getIndexArray(widget.brush);

                var total_widthes = [];

                for(var i = 0; i < brushes.length; i++) {
                    var index = brushes[i];

                    // brushSync가 true일 경우, 한번만 실행함
                    if(widget.brushSync && i > 0) continue;

                    var brush = chart.get("brush", index),
                        arr = this.getLegendIcon(brush);

                    for(var k = 0; k < arr.length; k++) {
                        group.append(arr[k].icon);
                        arr[k].icon.translate(x, y);

                        if (widget.orient == "bottom" || widget.orient == "top") {

                            if (x + arr[k].width > chart.area("x2")) {
                                x = 0;
                                y += arr[k].height;
                                max_height += arr[k].height;
                                arr[k].icon.translate(x, y); // HERE
                                total_widthes.push(total_width);
                                total_width = 0;
                            }

                            // @thanks to canelia04
                            x += arr[k].width + (PADDING * 2.5);
                            total_width += arr[k].width + (PADDING * 2.5);

                            if (max_height < arr[k].height) {
                                max_height = arr[k].height;
                            }
                        } else {
                            y += arr[k].height;
                            total_height += arr[k].height;

                            if (max_width < arr[k].width) {
                                max_width = arr[k].width;
                            }
                        }
                    }

                    if (total_width > 0) {
                        total_widthes.push(total_width);
                    }

                    if (total_widthes.length > 0) {
                        total_width = Math.max.apply(Math, total_widthes);
                    }

                    setLegendStatus(brush);
                }

                // legend 위치  선정
                if (widget.orient == "bottom" || widget.orient == "top") {
                    var y = ((widget.orient == "bottom") ?
                        chart.area("y2") + chart.padding("bottom") - max_height :
                        chart.area("y") - chart.padding("top")) + PADDING;

                    if (widget.align == "start") {
                        x = chart.area("x");
                    } else if (widget.align == "center") {
                        x = chart.area("x") + (chart.area("width")/2 - total_width / 2);
                    } else if (widget.align == "end") {
                        x = chart.area("x2") - total_width;
                    }
                } else {
                    var x = ((widget.orient == "left") ?
                        chart.area("x") - chart.padding("left") :
                        chart.area("x2") + chart.padding("right") - max_width) + PADDING;

                    if (widget.align == "start") {
                        y = chart.area("y");
                    } else if (widget.align == "center") {
                        y = chart.area("y") + (chart.area("height") / 2 - total_height / 2);
                    } else if (widget.align == "end") {
                        y = chart.area("y2") - total_height;
                    }
                }

                group.translate(Math.floor(x) + widget.dx, Math.floor(y) + widget.dy);

                return group;
            }
        }

        LegendWidget.setup = function() {
            return {
                /** @cfg {"bottom"/"top"/"left"/"right" } Sets the location where the label is displayed (top, bottom). */
                orient: "bottom",
                /** @cfg {"start"/"center"/"end" } Aligns the label (center, start, end). */
                align: "center", // or start, end
                /** @cfg {Boolean} [filter=false] Performs filtering so that only label(s) selected by the brush can be shown. */
                filter: false,
                /** @cfg {Function/String} [icon=null]   */
                icon: null,
                /** @cfg {Number} [dx=0] Moves the x coordinate by a set value from the location where the chart is drawn.  */
                dx: 0,
                /** @cfg {Number} [dy=0] Moves the y coordinate by a set value from the location where the chart is drawn. */
                dy: 0,
                /** @cfg {Array} [colors=null]   */
                colors: null,
                /** @cfg {Boolean} [brushSync=false] Applies all brushes equally when using a filter function. */
                brushSync: false,
                /** @cfg {Number/Array} [brush=0] Specifies a brush index for which a widget is used. */
                brush: 0,
                /** @cfg {Function} [format=null] Sets the format of the key that is displayed on the legend. */
                format: null
            };
        }

        /**
         * @event legend_filter
         * Event that occurs when the filter function of the legend widget is activated. (real name ``` legend.filter ```)
         * @param {String} target The selected data field.
         */

        return LegendWidget;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/widget/polygon/rotate3d.js":
/*!*****************************************************************!*\
  !*** ./node_modules/juijs-chart/src/widget/polygon/rotate3d.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../main.js */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.widget.polygon.rotate3d",
    extend: "chart.widget.polygon.core",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");
        var DEGREE_LIMIT = 180;

        var PolygonRotate3DWidget = function() {
            var self = this;

            function setScrollEvent(axisIndex) {
                var axis = self.chart.axis(axisIndex),
                    isMove = false,
                    mouseStartX = 0,
                    mouseStartY = 0,
                    sdx = 0,
                    sdy = 0,
                    cacheXY = null,
                    unit = self.widget.unit,
                    w = axis.area("width"),
                    h = axis.area("height");

                self.on("axis.mousedown", mousedown, axisIndex);
                self.on("axis.mousemove", mousemove, axisIndex);
                self.on("axis.mouseup", mouseup, axisIndex);
                self.on("bg.mouseup", mouseup);
                self.on("chart.mouseup", mouseup);

                function mousedown(e) {
                    if(isMove) return;

                    isMove = true;
                    mouseStartX = e.chartX;
                    mouseStartY = e.chartY;
                    sdx = axis.degree.x;
                    sdy = axis.degree.y;
                }

                function mousemove(e) {
                    if(!isMove) return;

                    var gapX = e.chartX - mouseStartX,
                        gapY = e.chartY - mouseStartY,
                        dx = sdx + Math.floor((gapY / h) * DEGREE_LIMIT),
                        dy = sdy - Math.floor((gapX / w) * DEGREE_LIMIT);

                    // 각도 Interval이 맞을 경우, 렌더링하지 않음
                    if(dx % unit != 0 && dy % unit != 0) return;

                    // 이전 각도와 동일할 경우, 렌더링하지 않음
                    var newCacheXY = dx + ":" + dy;
                    if(cacheXY == newCacheXY) return;

                    axis.set("degree", {
                        x: dx,
                        y: dy
                    });

                    self.chart.render();
                    cacheXY = newCacheXY;
                }

                function mouseup(e) {
                    if(!isMove) return;

                    isMove = false;
                    mouseStartX = 0;
                    mouseStartY = 0;
                }
            }

            this.draw = function() {
                var indexes = (_.typeCheck("array", this.widget.axis) ? this.widget.axis : [ this.widget.axis ]);

                for(var i = 0; i < indexes.length; i++) {
                    setScrollEvent(indexes[i]);
                }
            }
        }

        PolygonRotate3DWidget.setup = function() {
            return {
                unit: 5, // 회전 최소 각도
                axis: [ 0 ]
            }
        }

        return PolygonRotate3DWidget;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/widget/raycast.js":
/*!********************************************************!*\
  !*** ./node_modules/juijs-chart/src/widget/raycast.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.widget.raycast",
    extend: "chart.widget.core",
    component: function() {
        const _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");

        const DragSelectWidget = function() {
            this.emitBlockAndRangeEvent = function(eventType, datas, brush, blockAxis, rangeAxis, e) {
                const blockValue = blockAxis.invert(e.chartX) - 1;
                const area = this.chart.getCache(`raycast_area_${blockValue}`);

                if(area != null) {
                    if(e.chartX >= area.x1 && e.chartX <= area.x2 && e.chartY >= area.y1 && e.chartY <= area.y2) {
                        this.chart.emit(eventType, [{
                            brush: brush,
                            data: datas[blockValue],
                            dataIndex: blockValue
                        }, e]);
                    }
                }
            }

            this.setRayCastEvent = function(brush) {
                const axis = this.chart.axis(brush.axis);
                const xType = axis.x.type;
                const yType = axis.y.type;
                const blockAxis = (xType == "block") ? axis.x : ((yType == "block") ? axis.y : null);
                const rangeAxis = (xType == "range") ? axis.x : ((yType == "range") ? axis.y : null);

                if(blockAxis != null && rangeAxis != null) {
                    this.on("axis.click", function(e) {
                        this.emitBlockAndRangeEvent("raycast.click", axis.data, brush, blockAxis, rangeAxis, e);
                    }, brush.axis);

                    this.on("axis.dblclick", function(e) {
                        this.emitBlockAndRangeEvent("raycast.dblclick", axis.data, brush, blockAxis, rangeAxis, e);
                    }, brush.axis);

                    this.on("axis.rclick", function(e) {
                        this.emitBlockAndRangeEvent("raycast.rclick", axis.data, brush, blockAxis, rangeAxis, e);
                    }, brush.axis);
                }
            }

            this.draw = function() {
                let g = this.chart.svg.group(),
                    bIndex = this.widget.brush,
                    bIndexes = (_.typeCheck("array", bIndex) ? bIndex : [ bIndex ]);

                for(let i = 0; i < bIndexes.length; i++) {
                    let brush = this.chart.get("brush", bIndexes[i]);
                    this.setRayCastEvent(brush);
                }

                return g;
            }
        }

        DragSelectWidget.setup = function() {
            return {
                brush: [ 0 ]
            }
        }

        return DragSelectWidget;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/widget/title.js":
/*!******************************************************!*\
  !*** ./node_modules/juijs-chart/src/widget/title.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.widget.title",
    extend: "chart.widget.core",
    component: function() {
        var TOP_PADDING = 25, PADDING = 20;

        var TitleWidget = function(chart, axis, widget) {
            var x = 0, y = 0, anchor = "middle";

            this.drawBefore = function() {
                var axis = chart.axis(widget.axis);

                if(axis) {
                    if (widget.orient == "bottom") {
                        y = axis.area("y2") + axis.padding("bottom") - PADDING;
                    } else if (widget.orient == "top") {
                        y = axis.area("y") - axis.padding("top") + TOP_PADDING;
                    } else {
                        y = axis.area("y") + axis.area("height") / 2;
                    }

                    if (widget.align == "middle") {
                        x = axis.area("x") + axis.area("width") / 2;
                        anchor = "middle";
                    } else if (widget.align == "start") {
                        x = axis.area("x") - axis.padding("left") + PADDING;
                        anchor = "start";
                    } else {
                        x = axis.area("x2") + axis.padding("right") - PADDING;
                        anchor = "end";
                    }

                    x += chart.area("x");
                    y += chart.area("y");
                } else {
                    // @Deprecated 나중에 제거하기 (모든 샘플 axis 기반으로 변경할 것)
                    if (widget.orient == "bottom") {
                        y = chart.area("y2") + chart.padding("bottom") - PADDING;
                    } else if (widget.orient == "top") {
                        y = PADDING;
                    } else {
                        y = chart.area("y") + chart.area("height") / 2
                    }

                    if (widget.align == "middle") {
                        x = chart.area("x") + chart.area("width") / 2;
                        anchor = "middle";
                    } else if (widget.align == "start") {
                        x = chart.area("x");
                        anchor = "start";
                    } else {
                        x = chart.area("x2");
                        anchor = "end";
                    }
                }
            }

            this.draw = function() {
                var obj = chart.svg.getTextSize(widget.text);

                var half_text_width = obj.width / 2,
                    half_text_height = obj.height / 2;

                var text =  chart.text({
                    x : x + widget.dx,
                    y : y + widget.dy,
                    "text-anchor" : anchor,
                    "fill" : widget.color || chart.theme("titleFontColor"),
                    "font-size" : widget.size || chart.theme("titleFontSize"),
                    "font-weight" : chart.theme("titleFontWeight")
                }, widget.text);

                if (widget.orient == "center") {
                    if (widget.align == "start") {
                        text.rotate(-90, x + widget.dx + half_text_width, y + widget.dy + half_text_height)
                    } else if (widget.align == "end") {
                        text.rotate(90, x + widget.dx - half_text_width, y + widget.dy + half_text_height)
                    }
                }

                return text;
            }
        }

        TitleWidget.setup = function() {
            return {
                axis: null,
                /** @cfg {"top"/"center"/"bottom" } [orient="top"]  Determines the side on which the tool tip is displayed (top, center, bottom). */
                orient: "top", // or bottom
                /** @cfg {"start"/"middle"/"end" } [align="center"] Aligns the title message (start, middle, end).*/
                align: "middle",
                /** @cfg {String} [text=""] Sets the title message. */
                text: "",
                /** @cfg {Number} [dx=0] Moves the x coordinate by a set value from the location where the chart is drawn.  */
                dx: 0,
                /** @cfg {Number} [dy=0] Moves the y coordinate by a set value from the location where the chart is drawn. */
                dy: 0,
                /** @cfg {Number} [size=null] Sets the title message size. */
                size: null,
                /** @cfg {String} [string=null] Sets the title message color. */
                color: null
            }
        }

        return TitleWidget;
    }
});

/***/ }),

/***/ "./node_modules/juijs-chart/src/widget/tooltip.js":
/*!********************************************************!*\
  !*** ./node_modules/juijs-chart/src/widget/tooltip.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "chart.widget.tooltip",
    extend: "chart.widget.core",
    component: function() {
        var _ = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.base");
        var ColorUtil = _main_js__WEBPACK_IMPORTED_MODULE_0__.default.include("util.color");
        var PADDING = 7, ANCHOR = 7, RATIO = 1.2;

        var TooltipWidget = function(chart, axis, widget) {
            var self = this,
                tooltips = {},
                lineHeight = 0;

            function getFormat(k, d) {
                var key = null,
                    value = null;

                if(_.typeCheck("function", widget.format)) {
                    var obj = self.format(d, k);

                    if(_.typeCheck("object", obj)) {
                        key = obj.key;
                        value = obj.value;
                    } else {
                        value = obj;
                    }
                } else {
                    if(k && !d) {
                        value = k;
                    }

                    if(k && d) {
                        key = k;
                        value = self.format(d[k]);
                    }
                }

                return {
                    key: key,
                    value: value
                }
            }

            function printTooltip(obj) {
                var tooltip = tooltips[obj.brush.index],
                    texts = tooltip.get(1).get(1),
                    width = 0,
                    height = 0,
                    onlyValue = false;

                if(obj.dataKey && widget.all === false) {
                    setTextInTooltip([ obj.dataKey ]);
                } else {
                    setTextInTooltip(obj.brush.target);
                }

                function setTextInTooltip(targets) {
                    for(var i = 0; i < targets.length; i++) {
                        var key = targets[i],
                            msg = getFormat(key, obj.data);

                        texts.get(i).attr({ x: PADDING });

                        if(msg.key) {
                            texts.get(i).get(0).text(msg.key);
                        } else {
                            texts.get(i).get(1).attr({ "text-anchor": "middle" });
                            onlyValue = true;
                        }

                        if(!_.typeCheck([ "null", "undefined" ], msg.value)) {
                            texts.get(i).get(1).attr({ x: 0 }).text(msg.value);
                        }

                        width = Math.max(width, texts.get(i).size().width);
                    }

                    height = targets.length * lineHeight;
                }

                return {
                    width: width + PADDING * 3,
                    height: height + PADDING,
                    onlyValue: onlyValue
                };
            }

            function existBrush(index) {
                var list = self.getIndexArray(self.widget.brush);

                return (_.inArray(index, list) == -1) ? false : true;
            }

            function getColorByKey(obj) {
                var targets = obj.brush.target;

                for(var i = 0; i < targets.length; i++) {
                    if(targets[i] == obj.dataKey) {
                        return ColorUtil.lighten(self.chart.color(i, obj.brush.colors));
                    }
                }

                return null;
            }

            function getTooltipXY(e, size, orient) {
                var x = e.bgX - (size.width / 2),
                    y = e.bgY - size.height - ANCHOR - (PADDING / 2),
                    lineX = 2;

                if(orient == "left" || orient == "right") {
                    y = e.bgY - (size.height / 2) - (PADDING / 2);
                }

                if(orient == "left") {
                    x = e.bgX - size.width - ANCHOR;
                } else if(orient == "right") {
                    x = e.bgX + ANCHOR;
                    lineX = -2;
                } else if(orient == "bottom") {
                    y = e.bgY + (ANCHOR * 2);
                }

                return {
                    x: x,
                    y: y,
                    c: lineX
                }
            }

            function setTooltipEvent() {
                var isActive = false,
                    size = null,
                    orient = null,
                    axis = null;

                self.on("mouseover", function(obj, e) {
                    if(isActive || !existBrush(obj.brush.index)) return;
                    if(!obj.dataKey && !obj.data) return;

                    // 툴팁 크기 가져오기
                    size = printTooltip(obj);
                    orient = widget.orient;
                    axis = chart.axis(obj.brush.axis);

                    // 툴팁 좌표 가져오기
                    var xy = getTooltipXY(e, size, orient),
                        x = xy.x - chart.padding("left"),
                        y = xy.y - chart.padding("top");

                    // 엑시스 범위를 넘었을 경우 처리
                    if(widget.flip) {
                        if (orient == "left" && x < 0) {
                            orient = "right";
                        } else if (orient == "right" && x + size.width > axis.area("width")) {
                            orient = "left";
                        } else if (orient == "top" && y < 0) {
                            orient = "bottom";
                        } else if (orient == "bottom" && y + size.height > axis.area("height")) {
                            orient = "top";
                        }
                    }

                    // 툴팁 엘리먼트 가져오기
                    var tooltip = tooltips[obj.brush.index],
                        line = tooltip.get(0),
                        target = tooltip.get(1),
                        rect = tooltip.get(1).get(0),
                        text = tooltip.get(1).get(1).translate(0, (orient != "bottom") ? lineHeight : lineHeight + ANCHOR),
                        borderColor = chart.theme("tooltipBorderColor") || getColorByKey(obj),
                        lineColor = chart.theme("tooltipLineColor") || getColorByKey(obj);

                    rect.attr({
                        points: self.balloonPoints(orient, size.width, size.height, (widget.anchor) ? ANCHOR : null),
                        stroke: borderColor
                    });
                    line.attr({ stroke: lineColor });
                    text.each(function(i, elem) {
                        elem.get(1).attr({ x: (size.onlyValue) ? size.width / 2 : size.width - PADDING });
                    });
                    tooltip.attr({ visibility: "visible" });
                    target.translate(xy.x, xy.y);

                    isActive = true;
                });

                self.on("mousemove", function(obj, e) {
                    if(!isActive) return;

                    var tooltip = tooltips[obj.brush.index],
                        line = tooltip.get(0),
                        target = tooltip.get(1),
                        xy = getTooltipXY(e, size, orient);

                    line.attr({
                        x1: e.bgX + xy.c,
                        y1: chart.padding("top") + axis.area("y"),
                        x2: e.bgX + xy.c,
                        y2: chart.padding("top") + axis.area("y2")
                    });

                    target.translate(xy.x, xy.y);
                });

                self.on("mouseout", function(obj, e) {
                    if(!isActive) return;

                    var tooltip = tooltips[obj.brush.index];
                    tooltip.attr({ visibility: "hidden" });

                    isActive = false;
                });
            }

            this.drawBefore = function() {
                lineHeight = chart.theme("tooltipFontSize") * RATIO;
            }

            this.draw = function() {
                var group = chart.svg.group(),
                    list = this.getIndexArray(this.widget.brush);

                for(var i = 0; i < list.length; i++) {
                    var brush = chart.get("brush", list[i]),
                        words = [ "" ];

                    // 모든 타겟을 툴팁에 보여주는 옵션일 경우
                    if(widget.all && brush.target.length > 1) {
                        for (var j = 1; j < brush.target.length; j++) {
                            words.push("");
                        }
                    }

                    tooltips[brush.index] = chart.svg.group({ visibility: "hidden" }, function() {
                        chart.svg.line({
                            "stroke-width": chart.theme("tooltipLineWidth"),
                            visibility: (widget.line) ? "visible" : "hidden"
                        });

                        chart.svg.group({}, function () {
                            chart.svg.polygon({
                                fill: chart.theme("tooltipBackgroundColor"),
                                "fill-opacity": chart.theme("tooltipBackgroundOpacity"),
                                "stroke-width": chart.theme("tooltipBorderWidth")
                            });

                            var text = chart.texts({
                                "font-size": chart.theme("tooltipFontSize"),
                                "fill": chart.theme("tooltipFontColor")
                            }, words, RATIO);

                            for(var i = 0; i < words.length; i++) {
                                text.get(i).append(chart.svg.tspan({ "text-anchor": "start", "font-weight": "bold", "x": PADDING }));
                                text.get(i).append(chart.svg.tspan({ "text-anchor": "end" }));
                            }
                        });
                    });

                    group.append(tooltips[brush.index]);
                }

                setTooltipEvent();

                return group;
            }
        }

        TooltipWidget.setup = function() {
            return {
                /** @cfg {"bottom"/"top"/"left"/"right"} Determines the side on which the tool tip is displayed (top, bottom, left, right). */
                orient: "top",
                /** @cfg {Boolean} [anchor=true] Remove tooltip's anchor */
                anchor: true,
                /** @cfg {Boolean} [all=false] Determines whether to show all values of row data.*/
                all: false,
                /** @cfg {Boolean} [line=false] Visible Guidelines. */
                line: false,
                /** @cfg {Boolean} [flip=false] When I went out of the area, reversing the tooltip. */
                flip: false,
                /** @cfg {Function} [format=null] Sets the format of the value that is displayed on the tool tip. */
                format: null,
                /** @cfg {Number} [brush=0] Specifies a brush index for which a widget is used. */
                brush: 0
            };
        }

        return TooltipWidget;
    }
});

/***/ }),

/***/ "./node_modules/juijs-graph/dist/jui-graph.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/juijs-graph/dist/jui-graph.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var global$1 = {},
    globalFunc = {},
    globalClass = {};

/**
 * @class util.base
 *
 * jui 에서 공통적으로 사용하는 유틸리티 함수 모음
 *
 * ```
 * var _ = jui.include("util.base");
 *
 * console.warn(_.browser.webkit);
 * ```
 *
 * @singleton
 */
var utility = global$1["util.base"] = {

    /**
     * @property browser check browser agent
     * @property {Boolean} browser.webkit  Webkit 브라우저 체크
     * @property {Boolean} browser.mozilla  Mozilla 브라우저 체크
     * @property {Boolean} browser.msie  IE 브라우저 체크 */
    browser: {
        webkit: 'WebkitAppearance' in document.documentElement.style ? true : false,
        mozilla: typeof window.mozInnerScreenX != "undefined" ? true : false,
        msie: window.navigator.userAgent.indexOf("Trident") != -1 ? true : false
    },

    /**
     * @property {Boolean} isTouch
     * check touch device
     */
    isTouch: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(window.navigator.userAgent),

    /**
     * @method inherit
     *
     * 프로토타입 기반의 상속 제공
     *
     * @param {Function} ctor base Class
     * @param {Function} superCtor super Class
     */
    inherit: function inherit(ctor, superCtor) {
        if (!this.typeCheck("function", ctor) || !this.typeCheck("function", superCtor)) return;

        ctor.parent = superCtor;
        ctor.prototype = new superCtor();
        ctor.prototype.constructor = ctor;
        ctor.prototype.parent = ctor.prototype;

        /**
         * @method super
         * call parent method
         * @param {String} method  parent method name
         * @param {Array} args
         * @returns {Mixed}
         */
        ctor.prototype.super = function (method, args) {
            return this.constructor.prototype[method].apply(this, args);
        };
    },

    /**
     * @method extend
     *
     * implements object extend
     *
     * @param {Object|Function} origin
     * @param {Object|Function} add
     * @param {Boolean} skip
     * @return {Object}
     */
    extend: function extend(origin, add, skip) {
        if (!this.typeCheck(["object", "function"], origin)) origin = {};
        if (!this.typeCheck(["object", "function"], add)) return origin;

        for (var key in add) {
            if (skip === true) {
                if (isRecursive(origin[key])) {
                    this.extend(origin[key], add[key], skip);
                } else if (this.typeCheck("undefined", origin[key])) {
                    origin[key] = add[key];
                }
            } else {
                if (isRecursive(origin[key])) {
                    this.extend(origin[key], add[key], skip);
                } else {
                    origin[key] = add[key];
                }
            }
        }

        function isRecursive(value) {
            return utility.typeCheck("object", value);
        }

        return origin;
    },

    /**
     * convert px to integer
     * @param {String or Number} px
     * @return {Number}
     */
    pxToInt: function pxToInt(px) {
        if (this.typeCheck("string", px) && px.indexOf("px") != -1) {
            return parseInt(px.split("px").join(""));
        }

        return px;
    },

    /**
     * @method clone
     * implements object clone
     * @param {Array/Object} obj 복사할 객체
     * @return {Array}
     */
    clone: function clone(obj) {
        var clone = this.typeCheck("array", obj) ? [] : {};

        for (var i in obj) {
            if (this.typeCheck("object", obj[i])) clone[i] = this.clone(obj[i]);else clone[i] = obj[i];
        }

        return clone;
    },

    /**
     * @method deepClone
     * implements object deep clone
     * @param obj
     * @param emit
     * @return {*}
     */
    deepClone: function deepClone(obj, emit) {
        var value = null;
        emit = emit || {};

        if (this.typeCheck("array", obj)) {
            value = new Array(obj.length);

            for (var i = 0, len = obj.length; i < len; i++) {
                value[i] = this.deepClone(obj[i], emit);
            }
        } else if (this.typeCheck("date", obj)) {
            value = obj;
        } else if (this.typeCheck("object", obj)) {
            value = {};

            for (var key in obj) {
                if (emit[key]) {
                    value[key] = obj[key];
                } else {
                    value[key] = this.deepClone(obj[key], emit);
                }
            }
        } else {
            value = obj;
        }

        return value;
    },

    /**
     * @method runtime
     *
     * caculate callback runtime
     *
     * @param {String} name
     * @param {Function} callback
     */
    runtime: function runtime(name, callback) {
        var nStart = new Date().getTime();
        callback();
        var nEnd = new Date().getTime();

        console.warn(name + " : " + (nEnd - nStart) + "ms");
    },

    /**
     * @method resize
     * add event in window resize event
     * @param {Function} callback
     * @param {Number} ms delay time
     */
    resize: function resize(callback, ms) {
        var after_resize = function () {
            var timer = 0;

            return function () {
                clearTimeout(timer);
                timer = setTimeout(callback, ms);
            };
        }();

        if (window.addEventListener) {
            window.addEventListener("resize", after_resize);
        } else if (object.attachEvent) {
            window.attachEvent("onresize", after_resize);
        } else {
            window["onresize"] = after_resize;
        }
    },

    /**
     * @method typeCheck
     * check data  type
     * @param {String} t  type string
     * @param {Object} v value object
     * @return {Boolean}
     */
    typeCheck: function typeCheck(t, v) {
        function check(type, value) {
            if (typeof type != "string") return false;

            if (type == "string") {
                return typeof value == "string";
            } else if (type == "integer") {
                return typeof value == "number" && value % 1 == 0;
            } else if (type == "float") {
                return typeof value == "number" && value % 1 != 0;
            } else if (type == "number") {
                return typeof value == "number";
            } else if (type == "boolean") {
                return typeof value == "boolean";
            } else if (type == "undefined") {
                return typeof value == "undefined";
            } else if (type == "null") {
                return value === null;
            } else if (type == "array") {
                return value instanceof Array;
            } else if (type == "date") {
                return value instanceof Date;
            } else if (type == "function") {
                return typeof value == "function";
            } else if (type == "object") {
                // typeCheck에 정의된 타입일 경우에는 object 체크시 false를 반환 (date, array, null)
                return (typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value !== null && !(value instanceof Array) && !(value instanceof Date) && !(value instanceof RegExp);
            }

            return false;
        }

        if ((typeof t === "undefined" ? "undefined" : _typeof(t)) == "object" && t.length) {
            var typeList = t;

            for (var i = 0; i < typeList.length; i++) {
                if (check(typeList[i], v)) return true;
            }

            return false;
        } else {
            return check(t, v);
        }
    },
    typeCheckObj: function typeCheckObj(uiObj, list) {
        if ((typeof uiObj === "undefined" ? "undefined" : _typeof(uiObj)) != "object") return;
        var self = this;

        for (var key in uiObj) {
            var func = uiObj[key];

            if (typeof func == "function") {
                (function (funcName, funcObj) {
                    uiObj[funcName] = function () {
                        var args = arguments,
                            params = list[funcName];

                        for (var i = 0; i < args.length; i++) {
                            if (!self.typeCheck(params[i], args[i])) {
                                throw new Error("JUI_CRITICAL_ERR: the " + i + "th parameter is not a " + params[i] + " (" + name + ")");
                            }
                        }

                        return funcObj.apply(this, args);
                    };
                })(key, func);
            }
        }
    },

    /**
     * @method dateFormat
     *
     * implements date format function
     *
     * yyyy : 4 digits year
     * yy : 2 digits year
     * y : 1 digit year
     *
     * @param {Date} date
     * @param {String} format   date format string
     * @param utc
     * @return {string}
     */
    dateFormat: function dateFormat(date, format, utc) {
        var MMMM = ["\x00", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        var MMM = ["\x01", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        var dddd = ["\x02", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        var ddd = ["\x03", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

        function ii(i, len) {
            var s = i + "";
            len = len || 2;
            while (s.length < len) {
                s = "0" + s;
            }return s;
        }

        var y = utc ? date.getUTCFullYear() : date.getFullYear();
        format = format.replace(/(^|[^\\])yyyy+/g, "$1" + y);
        format = format.replace(/(^|[^\\])yy/g, "$1" + y.toString().substr(2, 2));
        format = format.replace(/(^|[^\\])y/g, "$1" + y);

        var M = (utc ? date.getUTCMonth() : date.getMonth()) + 1;
        format = format.replace(/(^|[^\\])MMMM+/g, "$1" + MMMM[0]);
        format = format.replace(/(^|[^\\])MMM/g, "$1" + MMM[0]);
        format = format.replace(/(^|[^\\])MM/g, "$1" + ii(M));
        format = format.replace(/(^|[^\\])M/g, "$1" + M);

        var d = utc ? date.getUTCDate() : date.getDate();
        format = format.replace(/(^|[^\\])dddd+/g, "$1" + dddd[0]);
        format = format.replace(/(^|[^\\])ddd/g, "$1" + ddd[0]);
        format = format.replace(/(^|[^\\])dd/g, "$1" + ii(d));
        format = format.replace(/(^|[^\\])d/g, "$1" + d);

        var H = utc ? date.getUTCHours() : date.getHours();
        format = format.replace(/(^|[^\\])HH+/g, "$1" + ii(H));
        format = format.replace(/(^|[^\\])H/g, "$1" + H);

        var h = H > 12 ? H - 12 : H == 0 ? 12 : H;
        format = format.replace(/(^|[^\\])hh+/g, "$1" + ii(h));
        format = format.replace(/(^|[^\\])h/g, "$1" + h);

        var m = utc ? date.getUTCMinutes() : date.getMinutes();
        format = format.replace(/(^|[^\\])mm+/g, "$1" + ii(m));
        format = format.replace(/(^|[^\\])m/g, "$1" + m);

        var s = utc ? date.getUTCSeconds() : date.getSeconds();
        format = format.replace(/(^|[^\\])ss+/g, "$1" + ii(s));
        format = format.replace(/(^|[^\\])s/g, "$1" + s);

        var f = utc ? date.getUTCMilliseconds() : date.getMilliseconds();
        format = format.replace(/(^|[^\\])fff+/g, "$1" + ii(f, 3));
        f = Math.round(f / 10);
        format = format.replace(/(^|[^\\])ff/g, "$1" + ii(f));
        f = Math.round(f / 10);
        format = format.replace(/(^|[^\\])f/g, "$1" + f);

        var T = H < 12 ? "AM" : "PM";
        format = format.replace(/(^|[^\\])TT+/g, "$1" + T);
        format = format.replace(/(^|[^\\])T/g, "$1" + T.charAt(0));

        var t = T.toLowerCase();
        format = format.replace(/(^|[^\\])tt+/g, "$1" + t);
        format = format.replace(/(^|[^\\])t/g, "$1" + t.charAt(0));

        var tz = -date.getTimezoneOffset();
        var K = utc || !tz ? "Z" : tz > 0 ? "+" : "-";
        if (!utc) {
            tz = Math.abs(tz);
            var tzHrs = Math.floor(tz / 60);
            var tzMin = tz % 60;
            K += ii(tzHrs) + ":" + ii(tzMin);
        }
        format = format.replace(/(^|[^\\])K/g, "$1" + K);

        var day = (utc ? date.getUTCDay() : date.getDay()) + 1;
        format = format.replace(new RegExp(dddd[0], "g"), dddd[day]);
        format = format.replace(new RegExp(ddd[0], "g"), ddd[day]);

        format = format.replace(new RegExp(MMMM[0], "g"), MMMM[M]);
        format = format.replace(new RegExp(MMM[0], "g"), MMM[M]);

        format = format.replace(/\\(.)/g, "$1");

        return format;
    },
    /**
     * @method createId
     *
     * 유니크 아이디 생성
     *
     * @param {String} key  prefix string
     * @return {String} 생성된 아이디 문자열
     */
    createId: function createId(key) {
        return [key || "id", +new Date(), Math.round(Math.random() * 100) % 100].join("-");
    },

    /**
     * implement async loop without blocking ui
     *
     * @param total
     * @param context
     * @returns {Function}
     */
    timeLoop: function timeLoop(total, context) {

        return function (callback, lastCallback) {
            function TimeLoopCallback(i) {

                if (i < 1) return;

                if (i == 1) {
                    callback.call(context, i);
                    lastCallback.call(context);
                } else {
                    setTimeout(function () {
                        if (i > -1) callback.call(context, i--);
                        if (i > -1) TimeLoopCallback(i);
                    }, 1);
                }
            }

            TimeLoopCallback(total);
        };
    },
    /**
     * @method loop
     *
     * 최적화된 루프 생성 (5단계로 나눔)
     *
     * @param {Number} total
     * @param {Object} [context=null]
     * @return {Function} 최적화된 루프 콜백 (index, groupIndex 2가지 파라미터를 받는다.)
     */
    loop: function loop(total, context) {
        var start = 0,
            end = total,
            unit = Math.ceil(total / 5);

        return function (callback) {
            var first = start,
                second = unit * 1,
                third = unit * 2,
                fourth = unit * 3,
                fifth = unit * 4,
                firstMax = second,
                secondMax = third,
                thirdMax = fourth,
                fourthMax = fifth,
                fifthMax = end;

            while (first < firstMax && first < end) {
                callback.call(context, first, 1);
                first++;

                if (second < secondMax && second < end) {
                    callback.call(context, second, 2);
                    second++;
                }
                if (third < thirdMax && third < end) {
                    callback.call(context, third, 3);
                    third++;
                }
                if (fourth < fourthMax && fourth < end) {
                    callback.call(context, fourth, 4);
                    fourth++;
                }
                if (fifth < fifthMax && fifth < end) {
                    callback.call(context, fifth, 5);
                    fifth++;
                }
            }
        };
    },

    /**
     * @method loopArray
     *
     * 배열을 사용해서 최적화된 루프로 생성한다.
     *
     *
     * @param {Array} data 루프로 생성될 배열
     * @param {Object} [context=null]
     * @return {Function} 최적화된 루프 콜백 (data, index, groupIndex 3가지 파라미터를 받는다.)
     */
    loopArray: function loopArray(data, context) {
        var total = data.length,
            start = 0,
            end = total,
            unit = Math.ceil(total / 5);

        return function (callback) {
            var first = start,
                second = unit * 1,
                third = unit * 2,
                fourth = unit * 3,
                fifth = unit * 4,
                firstMax = second,
                secondMax = third,
                thirdMax = fourth,
                fourthMax = fifth,
                fifthMax = end;

            while (first < firstMax && first < end) {
                callback.call(context, data[first], first, 1);
                first++;
                if (second < secondMax && second < end) {
                    callback.call(context, data[second], second, 2);
                    second++;
                }
                if (third < thirdMax && third < end) {
                    callback.call(context, data[third], third, 3);
                    third++;
                }
                if (fourth < fourthMax && fourth < end) {
                    callback.call(context, data[fourth], fourth, 4);
                    fourth++;
                }
                if (fifth < fifthMax && fifth < end) {
                    callback.call(context, data[fifth], fifth, 5);
                    fifth++;
                }
            }
        };
    },

    /**
     * @method startsWith
     * Check that it matches the starting string search string.
     *
     * @param {String} string
     * @param {String} searchString
     * @return {Integer} position
     */
    startsWith: function startsWith(string, searchString, position) {
        position = position || 0;

        return string.lastIndexOf(searchString, position) === position;
    },

    /**
     * @method endsWith
     * Check that it matches the end of a string search string.
     *
     * @param {String} string
     * @param {String} searchString
     * @return {Integer} position
     */
    endsWith: function endsWith(string, searchString, position) {
        var subjectString = string;

        if (position === undefined || position > subjectString.length) {
            position = subjectString.length;
        }

        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);

        return lastIndex !== -1 && lastIndex === position;
    },

    inArray: function inArray(target, list) {
        if (this.typeCheck(["undefined", "null"], target) || !this.typeCheck("array", list)) return -1;

        for (var i = 0, len = list.length; i < len; i++) {
            if (list[i] == target) return i;
        }

        return -1;
    },

    trim: function trim(text) {
        var whitespace = "[\\x20\\t\\r\\n\\f]",
            rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g");

        return text == null ? "" : (text + "").replace(rtrim, "");
    },

    param: function param(data) {
        var r20 = /%20/g,
            s = [],
            add = function add(key, value) {
            // If value is a function, invoke it and return its value
            value = utility.typeCheck("function", value) ? value() : value == null ? "" : value;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };

        for (var key in data) {
            add(key, data[key]);
        }

        return s.join("&").replace(r20, "+");
    },

    ajax: function ajax(data) {
        var xhr = null,
            paramStr = "",
            callback = null;

        var opts = utility.extend({
            url: null,
            type: "GET",
            data: null,
            async: true,
            success: null,
            fail: null
        }, data);

        if (!this.typeCheck("string", opts.url) || !this.typeCheck("function", opts.success)) return;

        if (this.typeCheck("object", opts.data)) paramStr = this.param(opts.data);

        if (!this.typeCheck("undefined", XMLHttpRequest)) {
            xhr = new XMLHttpRequest();
        } else {
            var versions = ["MSXML2.XmlHttp.5.0", "MSXML2.XmlHttp.4.0", "MSXML2.XmlHttp.3.0", "MSXML2.XmlHttp.2.0", "Microsoft.XmlHttp"];

            for (var i = 0, len = versions.length; i < len; i++) {
                try {
                    xhr = new ActiveXObject(versions[i]);
                    break;
                } catch (e) {}
            }
        }

        if (xhr != null) {
            xhr.open(opts.type, opts.url, opts.async);
            xhr.send(paramStr);

            callback = function callback() {
                if (xhr.readyState === 4 && xhr.status == 200) {
                    opts.success(xhr);
                } else {
                    if (utility.typeCheck("function", opts.fail)) {
                        opts.fail(xhr);
                    }
                }
            };

            if (!opts.async) {
                callback();
            } else {
                xhr.onreadystatechange = callback;
            }
        }
    },

    ready: function () {
        var readyList,
            _DOMContentLoaded2,
            class2type = {};

        class2type["[object Boolean]"] = "boolean";
        class2type["[object Number]"] = "number";
        class2type["[object String]"] = "string";
        class2type["[object Function]"] = "function";
        class2type["[object Array]"] = "array";
        class2type["[object Date]"] = "date";
        class2type["[object RegExp]"] = "regexp";
        class2type["[object Object]"] = "object";

        var ReadyObj = {
            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,
            // A counter to track how many items to wait for before
            // the ready event fires. See #6781
            readyWait: 1,
            // Hold (or release) the ready event
            holdReady: function holdReady(hold) {
                if (hold) {
                    ReadyObj.readyWait++;
                } else {
                    ReadyObj.ready(true);
                }
            },
            // Handle when the DOM is ready
            ready: function ready(wait) {
                // Either a released hold or an DOMready/load event and not yet ready
                if (wait === true && ! --ReadyObj.readyWait || wait !== true && !ReadyObj.isReady) {
                    // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                    if (!document.body) {
                        return setTimeout(ReadyObj.ready, 1);
                    }

                    // Remember that the DOM is ready
                    ReadyObj.isReady = true;
                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if (wait !== true && --ReadyObj.readyWait > 0) {
                        return;
                    }
                    // If there are functions bound, to execute
                    readyList.resolveWith(document, [ReadyObj]);

                    // Trigger any bound ready events
                    //if ( ReadyObj.fn.trigger ) {
                    //  ReadyObj( document ).trigger( "ready" ).unbind( "ready" );
                    //}
                }
            },
            bindReady: function bindReady() {
                if (readyList) {
                    return;
                }
                readyList = ReadyObj._Deferred();

                // Catch cases where $(document).ready() is called after the
                // browser event has already occurred.
                if (document.readyState === "complete") {
                    // Handle it asynchronously to allow scripts the opportunity to delay ready
                    return setTimeout(ReadyObj.ready, 1);
                }

                // Mozilla, Opera and webkit nightlies currently support this event
                if (document.addEventListener) {
                    // Use the handy event callback
                    document.addEventListener("DOMContentLoaded", _DOMContentLoaded2, false);
                    // A fallback to window.onload, that will always work
                    window.addEventListener("load", ReadyObj.ready, false);

                    // If IE event model is used
                } else if (document.attachEvent) {
                    // ensure firing before onload,
                    // maybe late but safe also for iframes
                    document.attachEvent("onreadystatechange", _DOMContentLoaded2);

                    // A fallback to window.onload, that will always work
                    window.attachEvent("onload", ReadyObj.ready);

                    // If IE and not a frame
                    // continually check to see if the document is ready
                    var toplevel = false;

                    try {
                        toplevel = window.frameElement == null;
                    } catch (e) {}

                    if (document.documentElement.doScroll && toplevel) {
                        doScrollCheck();
                    }
                }
            },
            _Deferred: function _Deferred() {
                var // callbacks list
                callbacks = [],

                // stored [ context , args ]
                fired,

                // to avoid firing when already doing so
                firing,

                // flag to know if the deferred has been cancelled
                cancelled,

                // the deferred itself
                deferred = {

                    // done( f1, f2, ...)
                    done: function done() {
                        if (!cancelled) {
                            var args = arguments,
                                i,
                                length,
                                elem,
                                type,
                                _fired;
                            if (fired) {
                                _fired = fired;
                                fired = 0;
                            }
                            for (i = 0, length = args.length; i < length; i++) {
                                elem = args[i];
                                type = ReadyObj.type(elem);
                                if (type === "array") {
                                    deferred.done.apply(deferred, elem);
                                } else if (type === "function") {
                                    callbacks.push(elem);
                                }
                            }
                            if (_fired) {
                                deferred.resolveWith(_fired[0], _fired[1]);
                            }
                        }
                        return this;
                    },

                    // resolve with given context and args
                    resolveWith: function resolveWith(context, args) {
                        if (!cancelled && !fired && !firing) {
                            // make sure args are available (#8421)
                            args = args || [];
                            firing = 1;
                            try {
                                while (callbacks[0]) {
                                    callbacks.shift().apply(context, args); //shifts a callback, and applies it to document
                                }
                            } finally {
                                fired = [context, args];
                                firing = 0;
                            }
                        }
                        return this;
                    },

                    // resolve with this as context and given arguments
                    resolve: function resolve() {
                        deferred.resolveWith(this, arguments);
                        return this;
                    },

                    // Has this deferred been resolved?
                    isResolved: function isResolved() {
                        return !!(firing || fired);
                    },

                    // Cancel
                    cancel: function cancel() {
                        cancelled = 1;
                        callbacks = [];
                        return this;
                    }
                };

                return deferred;
            },
            type: function type(obj) {
                return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || "object";
            }
            // The DOM ready check for Internet Explorer
        };function doScrollCheck() {
            if (ReadyObj.isReady) {
                return;
            }

            try {
                // If IE is used, use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                document.documentElement.doScroll("left");
            } catch (e) {
                setTimeout(doScrollCheck, 1);
                return;
            }

            // and execute any waiting functions
            ReadyObj.ready();
        }
        // Cleanup functions for the document ready method
        if (document.addEventListener) {
            _DOMContentLoaded2 = function DOMContentLoaded() {
                document.removeEventListener("DOMContentLoaded", _DOMContentLoaded2, false);
                ReadyObj.ready();
            };
        } else if (document.attachEvent) {
            _DOMContentLoaded2 = function _DOMContentLoaded() {
                // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                if (document.readyState === "complete") {
                    document.detachEvent("onreadystatechange", _DOMContentLoaded2);
                    ReadyObj.ready();
                }
            };
        }
        function ready(fn) {
            // Attach the listeners
            ReadyObj.bindReady();

            var type = ReadyObj.type(fn);

            // Add the callback
            readyList.done(fn); //readyList is result of _Deferred()
        }

        return ready;
    }()

    /*
     * Module related functions
     *
     */
};var getDepends = function getDepends(depends) {
    var args = [];

    for (var i = 0; i < depends.length; i++) {
        var module = global$1[depends[i]];

        if (!utility.typeCheck(["function", "object"], module)) {
            var modules = getModules(depends[i]);

            if (modules == null) {
                console.warn("JUI_WARNING_MSG: '" + depends[i] + "' is not loaded");
                args.push(null);
            } else {
                args.push(modules);
            }
        } else {
            args.push(module);
        }
    }

    return args;
};

var getModules = function getModules(parent) {
    var modules = null,
        parent = parent + ".";

    for (var key in global$1) {
        if (key.indexOf(parent) != -1) {
            if (utility.typeCheck(["function", "object"], global$1[key])) {
                var child = key.split(parent).join("");

                if (child.indexOf(".") == -1) {
                    if (modules == null) {
                        modules = {};
                    }

                    modules[child] = global$1[key];
                }
            }
        }
    }

    return modules;
};

/**
 * @class jui
 *
 * Global Object
 *
 * @singleton
 */
var jui$1 = {

    /**
     * @method ready
     *
     * ready 타임에 실행될 callback 정의
     *
     * @param {Function} callback
     */
    ready: function ready() {
        var args = [],
            callback = arguments.length == 2 ? arguments[1] : arguments[0],
            depends = arguments.length == 2 ? arguments[0] : null;

        if (!utility.typeCheck(["array", "null"], depends) || !utility.typeCheck("function", callback)) {
            throw new Error("JUI_CRITICAL_ERR: Invalid parameter type of the function");
        }

        utility.ready(function () {
            if (depends) {
                args = getDepends(depends);
            }

            callback.apply(null, args);
        });
    },

    /**
     * @method defineUI
     *
     * 사용자가 실제로 사용할 수 있는 UI 클래스를 정의
     *
     * @param {String} name 모듈 로드와 상속에 사용될 이름을 정한다.
     * @param {Array} depends 'define'이나 'defineUI'로 정의된 클래스나 객체를 인자로 받을 수 있다.
     * @param {Function} callback UI 클래스를 해당 콜백 함수 내에서 클래스 형태로 구현하고 리턴해야 한다.
     */
    defineUI: function defineUI(name, depends, callback, parent) {
        if (!utility.typeCheck("string", name) || !utility.typeCheck("array", depends) || !utility.typeCheck("function", callback) || !utility.typeCheck(["string", "undefined"], parent)) {
            throw new Error("JUI_CRITICAL_ERR: Invalid parameter type of the function");
        }

        if (utility.typeCheck("function", globalClass[name])) {
            throw new Error("JUI_CRITICAL_ERR: '" + name + "' is already exist");
        }

        if (utility.typeCheck("undefined", parent)) {
            parent = "core";
        }

        if (!utility.typeCheck("function", globalClass[parent])) {
            throw new Error("JUI_CRITICAL_ERR: Parents are the only function");
        } else {
            if (globalFunc[parent] !== true) {
                throw new Error("JUI_CRITICAL_ERR: UI function can not be inherited");
            }
        }

        var args = getDepends(depends),
            uiFunc = callback.apply(null, args);

        // 상속
        utility.inherit(uiFunc, globalClass[parent]);

        // TODO: 차트 빌더를 제외하고, 무조건 event 클래스에 정의된 init 메소드를 호출함
        global$1[name] = globalClass[parent].init({
            type: name,
            "class": uiFunc
        });

        globalClass[name] = uiFunc;
        globalFunc[name] = true;

        /**
         * @deprecated
         // support AMD module
         if (typeof define == "function" && define.amd) {
        define(name, function () {
        return global[name]
        });
        }
         */
    },

    /**
     * @method redefineUI
     *
     * UI 클래스에서 사용될 클래스를 정의하고, 자유롭게 상속할 수 있는 클래스를 정의
     *
     * @param {String} name 모듈 로드와 상속에 사용될 이름을 정한다.
     * @param {Array} depends 'define'이나 'defineUI'로 정의된 클래스나 객체를 인자로 받을 수 있다.
     * @param {Function} callback UI 클래스를 해당 콜백 함수 내에서 클래스 형태로 구현하고 리턴해야 한다.
     * @param {String} parent 상속받을 클래스
     */
    redefineUI: function redefineUI(name, depends, callback, parent, skip) {
        if (!skip && globalFunc[name] === true) {
            global$1[name] = null;
            globalClass[name] = null;
            globalFunc[name] = false;
        }

        if (!skip || skip && globalFunc[name] !== true) {
            this.defineUI(name, depends, callback, parent);
        }
    },

    createUIObject: function createUIObject(UI, selector, index, elem, options, afterHook) {
        var mainObj = new UI["class"]();

        // Check Options
        var opts = jui$1.defineOptions(UI["class"], options || {});

        // Public Properties
        mainObj.init.prototype = mainObj;
        /** @property {String/HTMLElement} selector */
        mainObj.init.prototype.selector = selector;
        /** @property {HTMLElement} root */
        mainObj.init.prototype.root = elem;
        /** @property {Object} options */
        mainObj.init.prototype.options = opts;
        /** @property {Array} event Custom events */
        mainObj.init.prototype.event = new Array(); // Custom Event
        /** @property {Integer} timestamp UI Instance creation time*/
        mainObj.init.prototype.timestamp = new Date().getTime();
        /** @property {Integer} index Index of UI instance*/
        mainObj.init.prototype.index = index;
        /** @property {Class} module Module class */
        mainObj.init.prototype.module = UI;

        // UI 객체 프로퍼티를 외부에서 정의할 수 있음 (jQuery 의존성 제거를 위한 코드)
        if (utility.typeCheck("function", afterHook)) {
            afterHook(mainObj, opts);
        }

        var uiObj = new mainObj.init();

        // Custom Event Setting
        for (var key in opts.event) {
            uiObj.on(key, opts.event[key]);
        }

        // 엘리먼트 객체에 jui 속성 추가
        elem.jui = uiObj;

        return uiObj;
    },

    /**
     * @method define
     *
     * UI 클래스에서 사용될 클래스를 정의하고, 자유롭게 상속할 수 있는 클래스를 정의
     *
     * @param {String} name 모듈 로드와 상속에 사용될 이름을 정한다.
     * @param {Array} depends 'define'이나 'defineUI'로 정의된 클래스나 객체를 인자로 받을 수 있다.
     * @param {Function} callback UI 클래스를 해당 콜백 함수 내에서 클래스 형태로 구현하고 리턴해야 한다.
     * @param {String} parent 상속받을 클래스
     */
    define: function define(name, depends, callback, parent) {
        if (!utility.typeCheck("string", name) || !utility.typeCheck("array", depends) || !utility.typeCheck("function", callback) || !utility.typeCheck(["string", "undefined", "null"], parent)) {
            throw new Error("JUI_CRITICAL_ERR: Invalid parameter type of the function");
        }

        if (utility.typeCheck("function", globalClass[name])) {
            throw new Error("JUI_CRITICAL_ERR: '" + name + "' is already exist");
        }

        var args = getDepends(depends),
            uiFunc = callback.apply(null, args);

        if (utility.typeCheck("function", globalClass[parent])) {
            if (globalFunc[parent] !== true) {
                throw new Error("JUI_CRITICAL_ERR: UI function can not be inherited");
            } else {
                utility.inherit(uiFunc, globalClass[parent]);
            }
        }

        // 함수 고유 설정
        global$1[name] = uiFunc;
        globalClass[name] = uiFunc; // original function
        globalFunc[name] = true;

        // support AMD module
        // @deprecated
        /*
        if (typeof define == "function" && define.amd) {
            define(name, function () {
                return global[name]
            });
        }*/
    },

    /**
     * @method redefine
     *
     * UI 클래스에서 사용될 클래스를 정의하고, 자유롭게 상속할 수 있는 클래스를 정의
     *
     * @param {String} name 모듈 로드와 상속에 사용될 이름을 정한다.
     * @param {Array} depends 'define'이나 'defineUI'로 정의된 클래스나 객체를 인자로 받을 수 있다.
     * @param {Function} callback UI 클래스를 해당 콜백 함수 내에서 클래스 형태로 구현하고 리턴해야 한다.
     * @param {String} parent 상속받을 클래스
     */
    redefine: function redefine(name, depends, callback, parent, skip) {
        if (!skip && globalFunc[name] === true) {
            global$1[name] = null;
            globalClass[name] = null;
            globalFunc[name] = false;
        }

        if (!skip || skip && globalFunc[name] !== true) {
            this.define(name, depends, callback, parent);
        }
    },

    /**
     * @method defineOptions
     *
     * 모듈 기본 옵션 정의
     *
     * @param {Object} Module
     * @param {Object} options
     * @param {Object} exceptOpts
     * @return {Object}
     */
    defineOptions: function defineOptions(Module, options, exceptOpts) {
        var defOpts = getOptions(Module, {});
        var defOptKeys = Object.keys(defOpts),
            optKeys = Object.keys(options);

        // 정의되지 않은 옵션 사용 유무 체크
        for (var i = 0; i < optKeys.length; i++) {
            var name = optKeys[i];

            if (utility.inArray(name, defOptKeys) == -1 && utility.inArray(name, exceptOpts) == -1) {
                throw new Error("JUI_CRITICAL_ERR: '" + name + "' is not an option");
            }
        }

        // 사용자 옵션 + 기본 옵션
        utility.extend(options, defOpts, true);

        // 상위 모듈의 옵션까지 모두 얻어오는 함수
        function getOptions(Module, options) {
            if (utility.typeCheck("function", Module)) {
                if (utility.typeCheck("function", Module.setup)) {
                    var opts = Module.setup();

                    for (var key in opts) {
                        if (utility.typeCheck("undefined", options[key])) {
                            options[key] = opts[key];
                        }
                    }
                }

                getOptions(Module.parent, options);
            }

            return options;
        }

        return options;
    },

    /**
     * define과 defineUI로 정의된 클래스 또는 객체를 가져온다.
     *
     * @param name 가져온 클래스 또는 객체의 이름
     * @return {*}
     */
    include: function include(name) {
        if (!utility.typeCheck("string", name)) {
            throw new Error("JUI_CRITICAL_ERR: Invalid parameter type of the function");
        }

        var module = global$1[name];

        if (utility.typeCheck(["function", "object"], module)) {
            return module;
        } else {
            var modules = getModules(name);

            if (modules == null) {
                console.warn("JUI_WARNING_MSG: '" + name + "' is not loaded");
                return null;
            } else {
                return modules;
            }
        }
    },

    /**
     * define과 defineUI로 정의된 모든 클래스와 객체를 가져온다.
     *
     * @return {Array}
     */
    includeAll: function includeAll() {
        var result = [];

        for (var key in global$1) {
            result.push(global$1[key]);
        }

        return result;
    },

    use: function use() {
        var modules = [];

        for (var i = 0; i < arguments.length; i++) {
            if (utility.typeCheck("array", arguments[i])) {
                var list = arguments[i];

                for (var j = 0; j < list.length; j++) {
                    if (utility.typeCheck("object", list[j])) {
                        modules.push(list[j]);
                    }
                }
            } else if (utility.typeCheck("object", arguments[i])) {
                modules.push(arguments[i]);
            }
        }

        for (var i = 0; i < modules.length; i++) {
            var module = modules[i];

            if ((typeof module === "undefined" ? "undefined" : _typeof(module)) == "object") {
                if (typeof module.name != "string") return;
                if (typeof module.component != "function") return;

                // 상속 대상 부모 클래스가 존재할 경우
                if (module.extend != null) {
                    if (jui$1.include(module.extend) == null) {
                        console.warn("JUI_WARNING_MSG: '" + module.extend + "' module should be imported in first");
                    }
                }

                if (module.extend == "core") {
                    jui$1.redefineUI(module.name, [], module.component, module.extend);
                } else {
                    jui$1.redefine(module.name, [], module.component, module.extend);
                }
            }
        }
    }
};

var dom = {
    name: "util.dom",
    extend: null,
    component: function component() {
        var _ = jui$1.include("util.base");

        return {
            find: function find() {
                var args = arguments;

                if (args.length == 1) {
                    if (_.typeCheck("string", args[0])) {
                        return document.querySelectorAll(args[0]);
                    }
                } else if (args.length == 2) {
                    if (_.typeCheck("object", args[0]) && _.typeCheck("string", args[1])) {
                        return args[0].querySelectorAll(args[1]);
                    }
                }

                return [];
            },

            each: function each(selectorOrElements, callback) {
                if (!_.typeCheck("function", callback)) return;

                var elements = null;

                if (_.typeCheck("string", selectorOrElements)) {
                    elements = document.querySelectorAll(selectorOrElements);
                } else if (_.typeCheck("array", selectorOrElements)) {
                    elements = selectorOrElements;
                }

                if (elements != null) {
                    Array.prototype.forEach.call(elements, function (el, i) {
                        callback.apply(el, [i, el]);
                    });
                }
            },

            attr: function attr(selectorOrElements, keyOrAttributes) {
                if (!_.typeCheck(["string", "array"], selectorOrElements)) return;

                var elements = document.querySelectorAll(selectorOrElements);

                if (_.typeCheck("object", keyOrAttributes)) {
                    // set
                    for (var i = 0; i < elements.length; i++) {
                        for (var key in keyOrAttributes) {
                            elements[i].setAttribute(key, keyOrAttributes[key]);
                        }
                    }
                } else if (_.typeCheck("string", keyOrAttributes)) {
                    // get
                    if (elements.length > 0) {
                        return elements[0].getAttribute(keyOrAttributes);
                    }
                }
            },

            remove: function remove(selectorOrElements) {
                this.each(selectorOrElements, function () {
                    this.parentNode.removeChild(this);
                });
            },

            offset: function offset(elem) {
                function isWindow(obj) {
                    /* jshint eqeqeq: false */
                    return obj != null && obj == obj.window;
                }

                function getWindow(elem) {
                    return isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
                }

                var docElem,
                    win,
                    box = { top: 0, left: 0 },
                    doc = elem && elem.ownerDocument;

                if (!doc) {
                    return;
                }

                docElem = doc.documentElement;

                // Make sure it's not a disconnected DOM node
                /*/
                 if ( !global.jquery.contains( docElem, elem ) ) {
                 return box;
                 }
                 /**/

                // If we don't have gBCR, just use 0,0 rather than error
                // BlackBerry 5, iOS 3 (original iPhone)
                var strundefined = "undefined";
                if (_typeof(elem.getBoundingClientRect) !== strundefined) {
                    box = elem.getBoundingClientRect();
                }
                win = getWindow(doc);

                return {
                    top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
                    left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
                };
            }
        };
    }
};

var math = {
    name: "util.math",
    extend: null,
    component: function component() {
        var _ = jui$1.include("util.base");

        // 2x1 or 3x1 or ?x1 형태의 매트릭스 연산
        function _matrix(a, b) {
            var m = [];

            for (var i = 0, len = a.length; i < len; i++) {
                var sum = 0;

                for (var j = 0, len2 = a[i].length; j < len2; j++) {
                    sum += a[i][j] * b[j];
                }

                m.push(sum);
            }

            return m;
        }

        // 2x2 or 3x3 or ?x? 형태의 매트릭스 연산
        function deepMatrix(a, b) {
            var m = [],
                nm = [];

            for (var i = 0, len = b.length; i < len; i++) {
                m[i] = [];
                nm[i] = [];
            }

            for (var i = 0, len = b.length; i < len; i++) {
                for (var j = 0, len2 = b[i].length; j < len2; j++) {
                    m[j].push(b[i][j]);
                }
            }

            for (var i = 0, len = m.length; i < len; i++) {
                var mm = _matrix(a, m[i]);

                for (var j = 0, len2 = mm.length; j < len2; j++) {
                    nm[j].push(mm[j]);
                }
            }

            return nm;
        }

        function _matrix3d(a, b) {
            var m = new Float32Array(4);

            m[0] = a[0][0] * b[0] + a[0][1] * b[1] + a[0][2] * b[2] + a[0][3] * b[3];
            m[1] = a[1][0] * b[0] + a[1][1] * b[1] + a[1][2] * b[2] + a[1][3] * b[3];
            m[2] = a[2][0] * b[0] + a[2][1] * b[1] + a[2][2] * b[2] + a[2][3] * b[3];
            m[3] = a[3][0] * b[0] + a[3][1] * b[1] + a[3][2] * b[2] + a[3][3] * b[3];

            return m;
        }

        function deepMatrix3d(a, b) {
            var nm = [new Float32Array(4), new Float32Array(4), new Float32Array(4), new Float32Array(4)];

            var m = [new Float32Array([b[0][0], b[1][0], b[2][0], b[3][0]]), new Float32Array([b[0][1], b[1][1], b[2][1], b[3][1]]), new Float32Array([b[0][2], b[1][2], b[2][2], b[3][2]]), new Float32Array([b[0][3], b[1][3], b[2][3], b[3][3]])];

            nm[0][0] = a[0][0] * m[0][0] + a[0][1] * m[0][1] + a[0][2] * m[0][2] + a[0][3] * m[0][3];
            nm[1][0] = a[1][0] * m[0][0] + a[1][1] * m[0][1] + a[1][2] * m[0][2] + a[1][3] * m[0][3];
            nm[2][0] = a[2][0] * m[0][0] + a[2][1] * m[0][1] + a[2][2] * m[0][2] + a[2][3] * m[0][3];
            nm[3][0] = a[3][0] * m[0][0] + a[3][1] * m[0][1] + a[3][2] * m[0][2] + a[3][3] * m[0][3];

            nm[0][1] = a[0][0] * m[1][0] + a[0][1] * m[1][1] + a[0][2] * m[1][2] + a[0][3] * m[1][3];
            nm[1][1] = a[1][0] * m[1][0] + a[1][1] * m[1][1] + a[1][2] * m[1][2] + a[1][3] * m[1][3];
            nm[2][1] = a[2][0] * m[1][0] + a[2][1] * m[1][1] + a[2][2] * m[1][2] + a[2][3] * m[1][3];
            nm[3][1] = a[3][0] * m[1][0] + a[3][1] * m[1][1] + a[3][2] * m[1][2] + a[3][3] * m[1][3];

            nm[0][2] = a[0][0] * m[2][0] + a[0][1] * m[2][1] + a[0][2] * m[2][2] + a[0][3] * m[2][3];
            nm[1][2] = a[1][0] * m[2][0] + a[1][1] * m[2][1] + a[1][2] * m[2][2] + a[1][3] * m[2][3];
            nm[2][2] = a[2][0] * m[2][0] + a[2][1] * m[2][1] + a[2][2] * m[2][2] + a[2][3] * m[2][3];
            nm[3][2] = a[3][0] * m[2][0] + a[3][1] * m[2][1] + a[3][2] * m[2][2] + a[3][3] * m[2][3];

            nm[0][3] = a[0][0] * m[3][0] + a[0][1] * m[3][1] + a[0][2] * m[3][2] + a[0][3] * m[3][3];
            nm[1][3] = a[1][0] * m[3][0] + a[1][1] * m[3][1] + a[1][2] * m[3][2] + a[1][3] * m[3][3];
            nm[2][3] = a[2][0] * m[3][0] + a[2][1] * m[3][1] + a[2][2] * m[3][2] + a[2][3] * m[3][3];
            nm[3][3] = a[3][0] * m[3][0] + a[3][1] * m[3][1] + a[3][2] * m[3][2] + a[3][3] * m[3][3];

            return nm;
        }

        function _inverseMatrix3d(me) {
            var te = [new Float32Array(4), new Float32Array(4), new Float32Array(4), new Float32Array(4)];

            var n11 = me[0][0],
                n12 = me[0][1],
                n13 = me[0][2],
                n14 = me[0][3];
            var n21 = me[1][0],
                n22 = me[1][1],
                n23 = me[1][2],
                n24 = me[1][3];
            var n31 = me[2][0],
                n32 = me[2][1],
                n33 = me[2][2],
                n34 = me[2][3];
            var n41 = me[3][0],
                n42 = me[3][1],
                n43 = me[3][2],
                n44 = me[3][3];

            te[0][0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
            te[0][1] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
            te[0][2] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
            te[0][3] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
            te[1][0] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
            te[1][1] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
            te[1][2] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
            te[1][3] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
            te[2][0] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
            te[2][1] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
            te[2][2] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
            te[2][3] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
            te[3][0] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
            te[3][1] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
            te[3][2] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
            te[3][4] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

            var det = 1 / (n11 * te[0][0] + n21 * te[0][1] + n31 * te[0][2] + n41 * te[0][3]);

            if (det === 0) {
                te = [new Float32Array([1, 0, 0, 0]), new Float32Array([0, 1, 0, 0]), new Float32Array([0, 0, 1, 0]), new Float32Array([0, 0, 0, 1])];
            } else {
                te[0][0] *= det;te[0][1] *= det;te[0][2] *= det;te[0][3] *= det;
                te[1][0] *= det;te[1][1] *= det;te[1][2] *= det;te[1][3] *= det;
                te[2][0] *= det;te[2][1] *= det;te[2][2] *= det;te[2][3] *= det;
                te[3][0] *= det;te[3][1] *= det;te[3][2] *= det;te[3][4] *= det;
            }

            return te;
        }

        /**
         * @class util.math
         *
         * Math Utility
         *
         * @singleton
         */
        var self = {

            /**
             * @method rotate
             *
             * 2d rotate
             *
             * @param {Number} x
             * @param {Number} y
             * @param {Number} radian	roate 할 radian
             * @return {Object}
             * @return {Number} return.x  변환된 x
             * @return {Number} return.y  변환된 y
             *
             */
            rotate: function rotate(x, y, radian) {
                return {
                    x: x * Math.cos(radian) - y * Math.sin(radian),
                    y: x * Math.sin(radian) + y * Math.cos(radian)
                };
            },

            resize: function resize(maxWidth, maxHeight, objectWidth, objectHeight) {
                var ratio = objectHeight / objectWidth;

                if (objectWidth >= maxWidth && ratio <= 1) {
                    objectWidth = maxWidth;
                    objectHeight = maxHeight * ratio;
                } else if (objectHeight >= maxHeight) {
                    objectHeight = maxHeight;
                    objectWidth = maxWidth / ratio;
                }

                return { width: objectWidth, height: objectHeight };
            },

            /**
             * @method radian
             *
             * convert degree to radian
             *
             * @param {Number} degree
             * @return {Number} radian
             */
            radian: function radian(degree) {
                return degree * Math.PI / 180;
            },

            /**
             * @method degree
             *
             * convert radian to degree
             *
             * @param {Number} radian
             * @return {Number} degree
             */
            degree: function degree(radian) {
                return radian * 180 / Math.PI;
            },

            angle: function angle(x1, y1, x2, y2) {
                var dx = x2 - x1,
                    dy = y2 - y1;

                return Math.atan2(dy, dx);
            },

            /**
             * @method interpolateNumber
             *
             * a, b 의 중간값 계산을 위한 callback 함수 만들기
             *
             * @param {Number} a	first value
             * @param {Number} b 	second value
             * @return {Function}
             */
            interpolateNumber: function interpolateNumber(a, b) {
                var dist = b - a;
                return function (t) {
                    return a + dist * t;
                };
            },

            // 중간값 round 해서 계산하기
            interpolateRound: function interpolateRound(a, b) {

                var dist = b - a;
                return function (t) {
                    return Math.round(a + dist * t);
                };
            },

            getFixed: function getFixed(a, b) {
                var aArr = (a + "").split(".");
                var aLen = aArr.length < 2 ? 0 : aArr[1].length;

                var bArr = (b + "").split(".");
                var bLen = bArr.length < 2 ? 0 : bArr[1].length;

                return aLen > bLen ? aLen : bLen;
            },

            fixed: function fixed(_fixed) {

                var fixedNumber = this.getFixed(_fixed, 0);
                var pow = Math.pow(10, fixedNumber);

                var func = function func(value) {
                    return Math.round(value * pow) / pow;
                };

                func.plus = function (a, b) {
                    return Math.round(a * pow + b * pow) / pow;
                };

                func.minus = function (a, b) {
                    return Math.round(a * pow - b * pow) / pow;
                };

                func.multi = function (a, b) {
                    return Math.round(a * pow * (b * pow)) / (pow * pow);
                };

                func.div = function (a, b) {
                    var result = a * pow / (b * pow);
                    var pow2 = Math.pow(10, this.getFixed(result, 0));
                    return Math.round(result * pow2) / pow2;
                };

                func.remain = function (a, b) {
                    return Math.round(a * pow % (b * pow)) / pow;
                };

                return func;
            },

            round: function round(num, fixed) {
                var fixedNumber = Math.pow(10, fixed);

                return Math.round(num * fixedNumber) / fixedNumber;
            },

            plus: function plus(a, b) {
                var pow = Math.pow(10, this.getFixed(a, b));

                return Math.round(a * pow + b * pow) / pow;
            },

            minus: function minus(a, b) {
                var pow = Math.pow(10, this.getFixed(a, b));
                return Math.round(a * pow - b * pow) / pow;
            },

            multi: function multi(a, b) {
                var pow = Math.pow(10, this.getFixed(a, b));
                return Math.round(a * pow * (b * pow)) / (pow * pow);
            },

            div: function div(a, b) {
                var pow = Math.pow(10, this.getFixed(a, b));

                var result = a * pow / (b * pow);
                var pow2 = Math.pow(10, this.getFixed(result, 0));
                return Math.round(result * pow2) / pow2;
            },

            remain: function remain(a, b) {
                var pow = Math.pow(10, this.getFixed(a, b));
                return Math.round(a * pow % (b * pow)) / pow;
            },

            /**
             * 특정 구간의 값을 자동으로 계산
             *
             * @param {Object} min
             * @param {Object} max
             * @param {Object} ticks
             * @param {Object} isNice
             */
            nice: function nice(min, max, ticks, isNice) {
                isNice = isNice || false;

                if (min > max) {
                    var _max = min;
                    var _min = max;
                } else {
                    var _min = min;
                    var _max = max;
                }

                var _ticks = ticks;
                var _tickSpacing = 0;
                var _range = [];
                var _niceMin;
                var _niceMax;

                function niceNum(range, round) {
                    var exponent = Math.floor(Math.log(range) / Math.LN10);
                    var fraction = range / Math.pow(10, exponent);

                    if (round) {
                        if (fraction < 1.5) niceFraction = 1;else if (fraction < 3) niceFraction = 2;else if (fraction < 7) niceFraction = 5;else niceFraction = 10;
                    } else {
                        if (fraction <= 1) niceFraction = 1;else if (fraction <= 2) niceFraction = 2;else if (fraction <= 5) niceFraction = 5;else niceFraction = 10;

                        //console.log(niceFraction)
                    }

                    return niceFraction * Math.pow(10, exponent);
                }

                function caculate() {
                    _range = isNice ? niceNum(_max - _min, false) : _max - _min;
                    _tickSpacing = isNice ? niceNum(_range / _ticks, true) : _range / _ticks;
                    _niceMin = isNice ? Math.floor(_min / _tickSpacing) * _tickSpacing : _min;
                    _niceMax = isNice ? Math.floor(_max / _tickSpacing) * _tickSpacing : _max;
                }

                caculate();

                return {
                    min: _niceMin,
                    max: _niceMax,
                    range: _range,
                    spacing: _tickSpacing
                };
            },

            matrix: function matrix(a, b) {
                if (_.typeCheck("array", b[0])) {
                    return deepMatrix(a, b);
                }

                return _matrix(a, b);
            },

            matrix3d: function matrix3d(a, b) {
                if (b[0] instanceof Array || b[0] instanceof Float32Array) {
                    return deepMatrix3d(a, b);
                }

                return _matrix3d(a, b);
            },

            inverseMatrix3d: function inverseMatrix3d(a) {
                return _inverseMatrix3d(a);
            },

            scaleValue: function scaleValue(value, minValue, maxValue, minScale, maxScale) {
                // 최소/최대 값이 같을 경우 처리
                minValue = minValue == maxValue ? 0 : minValue;

                var range = maxScale - minScale,
                    tg = range * getPer();

                function getPer() {
                    var range = maxValue - minValue,
                        tg = value - minValue,
                        per = tg / range;

                    return per;
                }

                return tg + minScale;
            }
        };

        return self;
    }
};

jui$1.use(math);

var color = {
    name: "util.color",
    extend: null,
    component: function component() {
        var _ = jui$1.include("util.base");
        var math$$1 = jui$1.include("util.math");

        function generateHash(name) {
            // Return a vector (0.0->1.0) that is a hash of the input string.
            // The hash is computed to favor early characters over later ones, so
            // that strings with similar starts have similar vectors. Only the first
            // 6 characters are considered.
            var hash = 0,
                weight = 1,
                max_hash = 0,
                mod = 10,
                max_char = 6;

            if (name) {
                for (var i = 0; i < name.length; i++) {
                    if (i > max_char) {
                        break;
                    }
                    hash += weight * (name.charCodeAt(i) % mod);
                    max_hash += weight * (mod - 1);
                    weight *= 0.70;
                }
                if (max_hash > 0) {
                    hash = hash / max_hash;
                }
            }
            return hash;
        }

        /**
         *  @class util.color
         *
         * color utility
         *
         * @singleton
         */
        var self = {

            regex: /(linear|radial)\((.*)\)(.*)/i,

            /**
             * @method format
             *
             * convert color to format string
             *
             *     // hex
             *     color.format({ r : 255, g : 255, b : 255 }, 'hex')  // #FFFFFF
             *
             *     // rgb
             *     color.format({ r : 255, g : 255, b : 255 }, 'rgb') // rgba(255, 255, 255, 0.5);
             *
             *     // rgba
             *     color.format({ r : 255, g : 255, b : 255, a : 0.5 }, 'rgb') // rgba(255, 255, 255, 0.5);
             *
             * @param {Object} obj  obj has r, g, b and a attributes
             * @param {"hex"/"rgb"} type  format string type
             * @returns {*}
             */
            format: function format(obj, type) {
                if (type == 'hex') {
                    var r = obj.r.toString(16);
                    if (obj.r < 16) r = "0" + r;

                    var g = obj.g.toString(16);
                    if (obj.g < 16) g = "0" + g;

                    var b = obj.b.toString(16);
                    if (obj.b < 16) b = "0" + b;

                    return "#" + [r, g, b].join("").toUpperCase();
                } else if (type == 'rgb') {
                    if (typeof obj.a == 'undefined') {
                        return "rgb(" + [obj.r, obj.g, obj.b].join(",") + ")";
                    } else {
                        return "rgba(" + [obj.r, obj.g, obj.b, obj.a].join(",") + ")";
                    }
                }

                return obj;
            },

            /**
             * @method scale
             *
             * get color scale
             *
             * 		var c = color.scale().domain('#FF0000', '#00FF00');
             *
             * 		// get middle color
             * 		c(0.5)   ==  #808000
             *
             * 		// get middle color list
             * 		c.ticks(20);  // return array ,    [startColor, ......, endColor ]
             *
             * @returns {func} scale function
             */
            scale: function scale() {
                var startColor, endColor;

                function func(t, type) {

                    var obj = {
                        r: parseInt(startColor.r + (endColor.r - startColor.r) * t, 10),
                        g: parseInt(startColor.g + (endColor.g - startColor.g) * t, 10),
                        b: parseInt(startColor.b + (endColor.b - startColor.b) * t, 10)
                    };

                    return self.format(obj, type);
                }

                func.domain = function (start, end) {
                    startColor = self.rgb(start);
                    endColor = self.rgb(end);

                    return func;
                };

                func.ticks = function (n) {
                    var unit = 1 / n;

                    var start = 0;
                    var colors = [];
                    while (start <= 1) {
                        var c = func(start, 'hex');
                        colors.push(c);
                        start = math$$1.plus(start, unit);
                    }

                    return colors;
                };

                return func;
            },

            /**
             * @method map
             *
             * create color map
             *
             * 		var colorList = color.map(['#352a87', '#0f5cdd', '#00b5a6', '#ffc337', '#fdff00'], count)
             *
             * @param {Array} color_list
             * @param {Number} count  a divide number
             * @returns {Array} converted color list
             */
            map: function map(color_list, count) {

                var colors = [];
                count = count || 5;
                var scale = self.scale();
                for (var i = 0, len = color_list.length - 1; i < len; i++) {
                    if (i == 0) {
                        colors = scale.domain(color_list[i], color_list[i + 1]).ticks(count);
                    } else {
                        var colors2 = scale.domain(color_list[i], color_list[i + 1]).ticks(count);
                        colors2.shift();
                        colors = colors.concat(colors2);
                    }
                }

                return colors;
            },

            /**
             * @method rgb
             *
             * parse string to rgb color
             *
             * 		color.rgb("#FF0000") === { r : 255, g : 0, b : 0 }
             *
             * 		color.rgb("rgb(255, 0, 0)") == { r : 255, g : 0, b : }
             *
             * @param {String} str color string
             * @returns {Object}  rgb object
             */
            rgb: function rgb(str) {

                if (typeof str == 'string') {
                    if (str.indexOf("rgb(") > -1) {
                        var arr = str.replace("rgb(", "").replace(")", "").split(",");

                        for (var i = 0, len = arr.length; i < len; i++) {
                            arr[i] = parseInt(_.trim(arr[i]), 10);
                        }

                        return { r: arr[0], g: arr[1], b: arr[2], a: 1 };
                    } else if (str.indexOf("rgba(") > -1) {
                        var arr = str.replace("rgba(", "").replace(")", "").split(",");

                        for (var i = 0, len = arr.length; i < len; i++) {

                            if (len - 1 == i) {
                                arr[i] = parseFloat(_.trim(arr[i]));
                            } else {
                                arr[i] = parseInt(_.trim(arr[i]), 10);
                            }
                        }

                        return { r: arr[0], g: arr[1], b: arr[2], a: arr[3] };
                    } else if (str.indexOf("#") == 0) {

                        str = str.replace("#", "");

                        var arr = [];
                        if (str.length == 3) {
                            for (var i = 0, len = str.length; i < len; i++) {
                                var char = str.substr(i, 1);
                                arr.push(parseInt(char + char, 16));
                            }
                        } else {
                            for (var i = 0, len = str.length; i < len; i += 2) {
                                arr.push(parseInt(str.substr(i, 2), 16));
                            }
                        }

                        return { r: arr[0], g: arr[1], b: arr[2], a: 1 };
                    }
                }

                return str;
            },

            /**
             * @method HSVtoRGB
             *
             * convert hsv to rgb
             *
             * 		color.HSVtoRGB(0,0,1) === #FFFFF === { r : 255, g : 0, b : 0 }
             *
             * @param {Number} H  hue color number  (min : 0, max : 360)
             * @param {Number} S  Saturation number  (min : 0, max : 1)
             * @param {Number} V  Value number 		(min : 0, max : 1 )
             * @returns {Object}
             */
            HSVtoRGB: function HSVtoRGB(H, S, V) {

                if (H == 360) {
                    H = 0;
                }

                var C = S * V;
                var X = C * (1 - Math.abs(H / 60 % 2 - 1));
                var m = V - C;

                var temp = [];

                if (0 <= H && H < 60) {
                    temp = [C, X, 0];
                } else if (60 <= H && H < 120) {
                    temp = [X, C, 0];
                } else if (120 <= H && H < 180) {
                    temp = [0, C, X];
                } else if (180 <= H && H < 240) {
                    temp = [0, X, C];
                } else if (240 <= H && H < 300) {
                    temp = [X, 0, C];
                } else if (300 <= H && H < 360) {
                    temp = [C, 0, X];
                }

                return {
                    r: Math.ceil((temp[0] + m) * 255),
                    g: Math.ceil((temp[1] + m) * 255),
                    b: Math.ceil((temp[2] + m) * 255)
                };
            },

            /**
             * @method RGBtoHSV
             *
             * convert rgb to hsv
             *
             * 		color.RGBtoHSV(0, 0, 255) === { h : 240, s : 1, v : 1 } === '#FFFF00'
             *
             * @param {Number} R  red color value
             * @param {Number} G  green color value
             * @param {Number} B  blue color value
             * @return {Object}  hsv color code
             */
            RGBtoHSV: function RGBtoHSV(R, G, B) {

                var R1 = R / 255;
                var G1 = G / 255;
                var B1 = B / 255;

                var MaxC = Math.max(R1, G1, B1);
                var MinC = Math.min(R1, G1, B1);

                var DeltaC = MaxC - MinC;

                var H = 0;

                if (DeltaC == 0) {
                    H = 0;
                } else if (MaxC == R1) {
                    H = 60 * ((G1 - B1) / DeltaC % 6);
                } else if (MaxC == G1) {
                    H = 60 * ((B1 - R1) / DeltaC + 2);
                } else if (MaxC == B1) {
                    H = 60 * ((R1 - G1) / DeltaC + 4);
                }

                if (H < 0) {
                    H = 360 + H;
                }

                var S = 0;

                if (MaxC == 0) S = 0;else S = DeltaC / MaxC;

                var V = MaxC;

                return { h: H, s: S, v: V };
            },

            trim: function trim(str) {
                return (str || "").replace(/^\s+|\s+$/g, '');
            },

            /**
             * @method lighten
             *
             * rgb 컬러 밝은 농도로 변환
             *
             * @param {String} color   RGB color code
             * @param {Number} rate 밝은 농도
             * @return {String}
             */
            lighten: function lighten(color, rate) {
                color = color.replace(/[^0-9a-f]/gi, '');
                rate = rate || 0;

                var rgb = [],
                    c,
                    i;
                for (i = 0; i < 6; i += 2) {
                    c = parseInt(color.substr(i, 2), 16);
                    c = Math.round(Math.min(Math.max(0, c + c * rate), 255)).toString(16);
                    rgb.push(("00" + c).substr(c.length));
                }

                return "#" + rgb.join("");
            },

            /**
             * @method darken
             *
             * rgb 컬러 어두운 농도로 변환
             *
             * @param {String} color   RGB color code
             * @param {Number} rate 어두운 농도
             * @return {String}
             */
            darken: function darken(color, rate) {
                return this.lighten(color, -rate);
            },

            /**
             * @method parse
             *
             * gradient color string parsing
             *
             * @param {String} color
             * @returns {*}
             */
            parse: function parse(color) {
                return this.parseGradient(color);
            },

            /**
             * @method parseGrident
             *
             * gradient parser
             *
             *      linear(left) #fff,#000
             *      linear(right) #fff,50 yellow,black
             *      radial(50%,50%,50%,50,50)
             *
             * @param {String} color
             */
            parseGradient: function parseGradient(color) {
                var matches = color.match(this.regex);

                if (!matches) return color;

                var type = this.trim(matches[1]);
                var attr = this.parseAttr(type, this.trim(matches[2]));
                var stops = this.parseStop(this.trim(matches[3]));

                var obj = { type: type + "Gradient", attr: attr, children: stops };

                return obj;
            },

            parseStop: function parseStop(stop) {
                var stop_list = stop.split(",");

                var stops = [];

                for (var i = 0, len = stop_list.length; i < len; i++) {
                    var stop = stop_list[i];

                    var arr = stop.split(" ");

                    if (arr.length == 0) continue;

                    if (arr.length == 1) {
                        stops.push({ type: "stop", attr: { "stop-color": arr[0] } });
                    } else if (arr.length == 2) {
                        stops.push({ type: "stop", attr: { "offset": arr[0], "stop-color": arr[1] } });
                    } else if (arr.length == 3) {
                        stops.push({ type: "stop", attr: { "offset": arr[0], "stop-color": arr[1], "stop-opacity": arr[2] } });
                    }
                }

                var start = -1;
                var end = -1;
                for (var i = 0, len = stops.length; i < len; i++) {
                    var stop = stops[i];

                    if (i == 0) {
                        if (!stop.offset) stop.offset = 0;
                    } else if (i == len - 1) {
                        if (!stop.offset) stop.offset = 1;
                    }

                    if (start == -1 && typeof stop.offset == 'undefined') {
                        start = i;
                    } else if (end == -1 && typeof stop.offset == 'undefined') {
                        end = i;

                        var count = end - start;

                        var endOffset = stops[end].offset.indexOf("%") > -1 ? parseFloat(stops[end].offset) / 100 : stops[end].offset;
                        var startOffset = stops[start].offset.indexOf("%") > -1 ? parseFloat(stops[start].offset) / 100 : stops[start].offset;

                        var dist = endOffset - startOffset;
                        var value = dist / count;

                        var offset = startOffset + value;
                        for (var index = start + 1; index < end; index++) {
                            stops[index].offset = offset;

                            offset += value;
                        }

                        start = end;
                        end = -1;
                    }
                }

                return stops;
            },

            parseAttr: function parseAttr(type, str) {

                if (type == 'linear') {
                    switch (str) {
                        case "":
                        case "left":
                            return { x1: 0, y1: 0, x2: 1, y2: 0, direction: str || "left" };
                        case "right":
                            return { x1: 1, y1: 0, x2: 0, y2: 0, direction: str };
                        case "top":
                            return { x1: 0, y1: 0, x2: 0, y2: 1, direction: str };
                        case "bottom":
                            return { x1: 0, y1: 1, x2: 0, y2: 0, direction: str };
                        case "top left":
                            return { x1: 0, y1: 0, x2: 1, y2: 1, direction: str };
                        case "top right":
                            return { x1: 1, y1: 0, x2: 0, y2: 1, direction: str };
                        case "bottom left":
                            return { x1: 0, y1: 1, x2: 1, y2: 0, direction: str };
                        case "bottom right":
                            return { x1: 1, y1: 1, x2: 0, y2: 0, direction: str };
                        default:
                            var arr = str.split(",");
                            for (var i = 0, len = arr.length; i < len; i++) {
                                if (arr[i].indexOf("%") == -1) arr[i] = parseFloat(arr[i]);
                            }

                            return { x1: arr[0], y1: arr[1], x2: arr[2], y2: arr[3] };
                    }
                } else {
                    var arr = str.split(",");
                    for (var i = 0, len = arr.length; i < len; i++) {

                        if (arr[i].indexOf("%") == -1) arr[i] = parseFloat(arr[i]);
                    }

                    return { cx: arr[0], cy: arr[1], r: arr[2], fx: arr[3], fy: arr[4] };
                }
            },

            colorHash: function colorHash(name, callback) {
                // Return an rgb() color string that is a hash of the provided name,
                // and with a warm palette.
                var vector = 0;

                if (name) {
                    name = name.replace(/.*`/, ""); // drop module name if present
                    name = name.replace(/\(.*/, ""); // drop extra info
                    vector = generateHash(name);
                }

                if (typeof callback == "function") {
                    return callback(vector);
                }

                return {
                    r: 200 + Math.round(55 * vector),
                    g: 0 + Math.round(230 * (1 - vector)),
                    b: 0 + Math.round(55 * (1 - vector))
                };
            }

        };

        self.map.parula = function (count) {
            return self.map(['#352a87', '#0f5cdd', '#00b5a6', '#ffc337', '#fdff00'], count);
        };
        self.map.jet = function (count) {
            return self.map(['#00008f', '#0020ff', '#00ffff', '#51ff77', '#fdff00', '#ff0000', '#800000'], count);
        };
        self.map.hsv = function (count) {
            return self.map(['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#0000ff', '#ff00ff', '#ff0000'], count);
        };
        self.map.hot = function (count) {
            return self.map(['#0b0000', '#ff0000', '#ffff00', '#ffffff'], count);
        };
        self.map.pink = function (count) {
            return self.map(['#1e0000', '#bd7b7b', '#e7e5b2', '#ffffff'], count);
        };
        self.map.bone = function (count) {
            return self.map(['#000000', '#4a4a68', '#a6c6c6', '#ffffff'], count);
        };
        self.map.copper = function (count) {
            return self.map(['#000000', '#3d2618', '#9d623e', '#ffa167', '#ffc77f'], count);
        };

        return self;
    }
};

var collection = {
    name: "collection",
    extend: null,
    component: function component() {
        var UICollection = function UICollection(type, selector, options, list) {
            this.type = type;
            this.selector = selector;
            this.options = options;

            this.destroy = function () {
                for (var i = 0; i < list.length; i++) {
                    list[i].destroy();
                }
            };

            for (var i = 0; i < list.length; i++) {
                this.push(list[i]);
            }
        };

        UICollection.prototype = Object.create(Array.prototype);

        return UICollection;
    }
};

var manager = {
    name: "manager",
    extend: null,
    component: function component() {
        var _ = jui$1.include("util.base");

        var UIManager = new function () {
            var instances = [],
                classes = [];

            /**
             * @method add
             * Adds a component object created
             *
             * @param {Object} ui UI instance
             */
            this.add = function (uiIns) {
                instances.push(uiIns);
            };

            /**
             * @method emit
             * Generates a custom event to an applicable component
             *
             * @param {String} key Selector or UI type
             * @param {String} type Event type
             * @param {Array} args Event arguments
             */
            this.emit = function (key, type, args) {
                var targets = [];

                for (var i = 0; i < instances.length; i++) {
                    var uiSet = instances[i];

                    if (key == uiSet.selector || key == uiSet.type) {
                        targets.push(uiSet);
                    }
                }

                for (var i = 0; i < targets.length; i++) {
                    var uiSet = targets[i];

                    for (var j = 0; j < uiSet.length; j++) {
                        uiSet[j].emit(type, args);
                    }
                }
            };

            /**
             * @method get
             * Gets a component currently created
             *
             * @param {Integer/String} key
             * @returns {Object/Array} UI instance
             */
            this.get = function (key) {
                if (_.typeCheck("integer", key)) {
                    return instances[key];
                } else if (_.typeCheck("string", key)) {
                    // 셀렉터 객체 검색
                    for (var i = 0; i < instances.length; i++) {
                        var uiSet = instances[i];

                        if (key == uiSet.selector) {
                            return uiSet.length == 1 ? uiSet[0] : uiSet;
                        }
                    }

                    // 모듈 객체 검색
                    var result = [];
                    for (var i = 0; i < instances.length; i++) {
                        var uiSet = instances[i];

                        if (key == uiSet.type) {
                            result.push(uiSet);
                        }
                    }

                    return result;
                }
            };

            /**
             * @method getAll
             * Gets all components currently created
             *
             * @return {Array} UI instances
             */
            this.getAll = function () {
                return instances;
            };

            /**
             * @method remove
             * Removes a component object in an applicable index from the list
             *
             * @param {Integer} index
             * @return {Object} Removed instance
             */
            this.remove = function (index) {
                if (_.typeCheck("integer", index)) {
                    // UI 객체 인덱스
                    return instances.splice(index, 1)[0];
                }
            };

            /**
             * @method shift
             * Removes the last component object from the list
             *
             * @return {Object} Removed instance
             */
            this.shift = function () {
                return instances.shift();
            };

            /**
             * @method pop
             * Removes the first component object from the list
             *
             * @return {Object} Removed instance
             */
            this.pop = function () {
                return instances.pop();
            };

            /**
             * @method size
             * Gets the number of objects currently created
             *
             * @return {Number}
             */
            this.size = function () {
                return instances.length;
            };

            /**
             * @method addClass
             * Adds a component class
             *
             * @param {Object} uiCls UI Class
             */
            this.addClass = function (uiCls) {
                classes.push(uiCls);
            };

            /**
             * @method getClass
             * Gets a component class
             *
             * @param {String/Integer} key
             * @return {Object}
             */
            this.getClass = function (key) {
                if (_.typeCheck("integer", key)) {
                    return classes[key];
                } else if (_.typeCheck("string", key)) {
                    for (var i = 0; i < classes.length; i++) {
                        if (key == classes[i].type) {
                            return classes[i];
                        }
                    }
                }

                return null;
            };

            /**
             * @method getClassAll
             * Gets all component classes
             *
             * @return {Array}
             */
            this.getClassAll = function () {
                return classes;
            };

            /**
             * @method create
             * It is possible to create a component dynamically after the ready point
             *
             * @param {String} type UI type
             * @param {String/DOMElement} selector
             * @param {Object} options
             * @return {Object}
             */
            this.create = function (type, selector, options) {
                var cls = UIManager.getClass(type);

                if (_.typeCheck("null", cls)) {
                    throw new Error("JUI_CRITICAL_ERR: '" + type + "' does not exist");
                }

                return cls["class"](selector, options);
            };
        }();

        return UIManager;
    }
};

jui$1.use(dom, manager, collection);

var UICore = {
    name: "core",
    extend: null,
    component: function component() {
        var _ = jui$1.include("util.base");
        var $ = jui$1.include("util.dom");
        var UIManager = jui$1.include("manager");
        var UICollection = jui$1.include("collection");

        var UICore = function UICore() {

            /**
             * @method emit
             * Generates a custom event. The first parameter is the type of a custom event. A function defined as an option or on method is called
             *
             * @param {String} type Event type
             * @param {Function} args Event Arguments
             * @return {Mixed}
             */
            this.emit = function (type, args) {
                if (!_.typeCheck("string", type)) return;
                var result;

                for (var i = 0; i < this.event.length; i++) {
                    var e = this.event[i];

                    if (e.type == type.toLowerCase()) {
                        var arrArgs = _.typeCheck("array", args) ? args : [args];
                        result = e.callback.apply(this, arrArgs);
                    }
                }

                return result;
            };

            /**
             * @method on
             * A callback function defined as an on method is run when an emit method is called
             *
             * @param {String} type Event type
             * @param {Function} callback
             */
            this.on = function (type, callback) {
                if (!_.typeCheck("string", type) || !_.typeCheck("function", callback)) return;
                this.event.push({ type: type.toLowerCase(), callback: callback, unique: false });
            };

            /**
             * @method off
             * Removes a custom event of an applicable type or callback handler
             *
             * @param {String} type Event type
             */
            this.off = function (type) {
                var event = [];

                for (var i = 0; i < this.event.length; i++) {
                    var e = this.event[i];

                    if (_.typeCheck("function", type) && e.callback != type || _.typeCheck("string", type) && e.type != type.toLowerCase()) {
                        event.push(e);
                    }
                }

                this.event = event;
            };

            /**
             * @method setOption
             * Dynamically defines the options of a UI
             *
             * @param {String} key
             * @param {Mixed} value
             */
            this.setOption = function (key, value) {
                if (_.typeCheck("object", key)) {
                    for (var k in key) {
                        this.options[k] = key[k];
                    }
                } else {
                    this.options[key] = value;
                }
            };

            /**
             * @method destroy
             * Removes all events set in a UI obejct and the DOM element
             *
             */
            this.destroy = function () {
                if (this.__proto__) {
                    for (var key in this.__proto__) {
                        delete this.__proto__[key];
                    }
                }
            };
        };

        UICore.build = function (UI) {

            return function (selector, options) {
                var list = [],
                    elemList = [];

                if (_.typeCheck("string", selector)) {
                    elemList = $.find(selector);
                } else if (_.typeCheck("object", selector)) {
                    elemList.push(selector);
                } else {
                    elemList.push(document.createElement("div"));
                }

                for (var i = 0, len = elemList.length; i < len; i++) {
                    list[i] = jui$1.createUIObject(UI, selector, i, elemList[i], options);
                }

                // UIManager에 데이터 입력
                UIManager.add(new UICollection(UI.type, selector, options, list));

                // 객체가 없을 경우에는 null을 반환 (기존에는 빈 배열을 반환)
                if (list.length == 0) {
                    return null;
                } else if (list.length == 1) {
                    return list[0];
                }

                return list;
            };
        };

        UICore.init = function (UI) {
            var uiObj = null;

            if ((typeof UI === "undefined" ? "undefined" : _typeof(UI)) === "object") {
                uiObj = UICore.build(UI);
                UIManager.addClass({ type: UI.type, "class": uiObj });
            }

            return uiObj;
        };

        UICore.setup = function () {
            return {
                /**
                 * @cfg {Object} [event={}]
                 * Defines a DOM event to be used in a UI
                 */
                event: {}
            };
        };

        return UICore;
    }
};

var time = {
    name: "util.time",
    extend: null,
    component: function component() {
        var _ = jui$1.include("util.base");

        var self = {

            //constant
            MILLISECOND: 1000,
            MINUTE: 1000 * 60,
            HOUR: 1000 * 60 * 60,
            DAY: 1000 * 60 * 60 * 24,

            // unit
            years: "years",
            months: "months",
            days: "days",
            hours: "hours",
            minutes: "minutes",
            seconds: "seconds",
            milliseconds: "milliseconds",
            weeks: "weeks",

            /**
             * @method diff
             *
             * caculate time difference from a to b
             *
             * @param type
             * @param a
             * @param b
             * @returns {number}
             */
            diff: function diff(type, a, b) {
                var milliseconds = +a - +b;

                if (type == 'seconds') {
                    return Math.abs(Math.floor(milliseconds / self.MILLISECOND));
                } else if (type == 'minutes') {
                    return Math.abs(Math.floor(milliseconds / self.MINUTE));
                } else if (type == 'hours') {
                    return Math.abs(Math.floor(milliseconds / self.HOUR));
                } else if (type == 'days') {
                    return Math.abs(Math.floor(milliseconds / self.DAY));
                }

                return milliseconds;
            },

            /**
             * @method add
             *
             * add time
             *
             * 		var date = new Date();
             * 		time.add(date, time.hours, 1); 		// add an hour on now
             * 		time.add(date, time.hours, 1, time.minutes, 2); 		// add an hour and 2 minutes on now
             *
             * @param {Object} date
             */
            add: function add(date) {

                if (arguments.length <= 2) {
                    return date;
                }

                if (arguments.length > 2) {
                    var d = new Date(+date);

                    for (var i = 1; i < arguments.length; i += 2) {

                        var split = typeof arguments[i] == 'string' ? this[arguments[i]] : arguments[i];
                        var time = arguments[i + 1];

                        if (this.years == split) {
                            d.setFullYear(d.getFullYear() + time);
                        } else if (this.months == split) {
                            d.setMonth(d.getMonth() + time);
                        } else if (this.days == split) {
                            d.setDate(d.getDate() + time);
                        } else if (this.hours == split) {
                            d.setHours(d.getHours() + time);
                        } else if (this.minutes == split) {
                            d.setMinutes(d.getMinutes() + time);
                        } else if (this.seconds == split) {
                            d.setSeconds(d.getSeconds() + time);
                        } else if (this.milliseconds == split) {
                            d.setMilliseconds(d.getMilliseconds() + time);
                        } else if (this.weeks == split) {
                            d.setDate(d.getDate() + time * 7);
                        }
                    }

                    return d;
                }
            },

            /**
             * @method format
             *
             * {util.dateFormat} 's alias
             *
             * @param {Object} date
             * @param {Object} format
             * @param {Object} utc
             */
            format: function format(date, _format, utc) {
                return _.dateFormat(date, _format, utc);
            }
        };

        return self;
    }
};

jui$1.use(math);

var transform = {
    name: "util.transform",
    extend: null,
    component: function component() {
        var math$$1 = jui$1.include("util.math");

        var Transform = function Transform(points) {
            function calculate(m) {
                for (var i = 0, count = points.length; i < count; i++) {
                    points[i] = math$$1.matrix(m, points[i]);
                }

                return points;
            }

            // 매트릭스 맵
            this.matrix = function () {
                var a = arguments,
                    type = a[0];

                if (type == "move") {
                    return [new Float32Array([1, 0, a[1]]), new Float32Array([0, 1, a[2]]), new Float32Array([0, 0, 1])];
                } else if (type == "scale") {
                    return [new Float32Array([a[1], 0, 0]), new Float32Array([0, a[2], 0]), new Float32Array([0, 0, 1])];
                } else if (type == "rotate") {
                    return [new Float32Array([Math.cos(math$$1.radian(a[1])), -Math.sin(math$$1.radian(a[1])), 0]), new Float32Array([Math.sin(math$$1.radian(a[1])), Math.cos(math$$1.radian(a[1])), 0]), new Float32Array([0, 0, 1])];
                } else if (type == "move3d") {
                    return [new Float32Array([1, 0, 0, a[1]]), new Float32Array([0, 1, 0, a[2]]), new Float32Array([0, 0, 1, a[3]]), new Float32Array([0, 0, 0, 1])];
                } else if (type == "scale3d") {
                    return [new Float32Array([a[1], 0, 0, 0]), new Float32Array([0, a[2], 0, 0]), new Float32Array([0, 0, a[3], 0]), new Float32Array([0, 0, 0, 1])];
                } else if (type == "rotate3dz") {
                    return [new Float32Array([Math.cos(math$$1.radian(a[1])), -Math.sin(math$$1.radian(a[1])), 0, 0]), new Float32Array([Math.sin(math$$1.radian(a[1])), Math.cos(math$$1.radian(a[1])), 0, 0]), new Float32Array([0, 0, 1, 0]), new Float32Array([0, 0, 0, 1])];
                } else if (type == "rotate3dx") {
                    return [new Float32Array([1, 0, 0, 0]), new Float32Array([0, Math.cos(math$$1.radian(a[1])), -Math.sin(math$$1.radian(a[1])), 0]), new Float32Array([0, Math.sin(math$$1.radian(a[1])), Math.cos(math$$1.radian(a[1])), 0]), new Float32Array([0, 0, 0, 1])];
                } else if (type == "rotate3dy") {
                    return [new Float32Array([Math.cos(math$$1.radian(a[1])), 0, Math.sin(math$$1.radian(a[1])), 0]), new Float32Array([0, 1, 0, 0]), new Float32Array([-Math.sin(math$$1.radian(a[1])), 0, Math.cos(math$$1.radian(a[1])), 0]), new Float32Array([0, 0, 0, 1])];
                }
            };

            // 2차원 이동
            this.move = function (dx, dy) {
                return calculate(this.matrix("move", dx, dy));
            };

            // 3차원 이동
            this.move3d = function (dx, dy, dz) {
                return calculate(this.matrix("move3d", dx, dy, dz));
            };

            // 2차원 스케일
            this.scale = function (sx, sy) {
                return calculate(this.matrix("scale", sx, sy));
            };

            // 3차원 스케일
            this.scale3d = function (sx, sy, sz) {
                return calculate(this.matrix("scale3d", sx, sy, sz));
            };

            // 2차원 회전
            this.rotate = function (angle) {
                return calculate(this.matrix("rotate", angle));
            };

            // Z축 중심 3차원 회전 - 롤(ROLL)
            this.rotate3dz = function (angle) {
                return calculate(this.matrix("rotate3dz", angle));
            };

            // X축 중심 3차원 회전 - 롤(PITCH)
            this.rotate3dx = function (angle) {
                return calculate(this.matrix("rotate3dx", angle));
            };

            // Y축 중심 3차원 회전 - 요(YAW)
            this.rotate3dy = function (angle) {
                return calculate(this.matrix("rotate3dy", angle));
            };

            // 임의의 행렬 처리
            this.custom = function (m) {
                return calculate(m);
            };

            // 행렬의 병합
            this.merge = function () {
                var a = arguments,
                    m = this.matrix.apply(this, a[0]);

                for (var i = 1; i < a.length; i++) {
                    m = math$$1.matrix(m, this.matrix.apply(this, a[i]));
                }

                return calculate(m);
            };

            // 행렬의 병합 (콜백 형태)
            this.merge2 = function (callback) {
                for (var i = 0, count = points.length; i < count; i++) {
                    var a = callback.apply(null, points[i]),
                        m = this.matrix.apply(this, a[0]);

                    for (var j = 1; j < a.length; j++) {
                        m = math$$1.matrix(m, this.matrix.apply(this, a[j]));
                    }

                    points[i] = math$$1.matrix(m, points[i]);
                }
            };
        };

        return Transform;
    }
};

var CanvasUtil = {
    name: "util.canvas.base",
    extend: null,
    component: function component() {
        var CanvasBase = function CanvasBase(context) {
            this.clearContext = function () {
                context.clearRect(0, 0, context.canvas.width, context.canvas.height);
            };

            this.drawLine = function (x1, y1, x2, y2, color) {
                var lineWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;

                color = color || '#434d6b';
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.lineWidth = lineWidth;
                context.strokeStyle = color;
                context.stroke();
            };

            this.drawCurve = function (points, minY, maxY) {
                var tension = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
                var isClosed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
                var numOfSegments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 16;

                context.beginPath();
                var pts = points.reduce(function (prev, e) {
                    prev.push(e[0], e[1]);
                    return prev;
                }, []);
                var ptsa = getCurvePoints(pts, minY, maxY, tension, isClosed, numOfSegments);
                context.moveTo(ptsa[0], ptsa[1]);
                for (var i = 2; i < ptsa.length - 1; i += 2) {
                    context.lineTo(ptsa[i], ptsa[i + 1]);
                }
            };

            this.drawDashedLine = function (x1, y1, x2, y2, color) {
                var dash = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [3, 3];
                var lineWidth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;

                color = color || '#434d6b';
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.lineWidth = lineWidth;
                context.strokeStyle = color;
                var originDash = context.getLineDash();
                context.setLineDash(dash);
                context.stroke();
                context.setLineDash(originDash);
            };

            this.drawLines = function (color) {
                color = color || '#434d6b';
                context.beginPath();

                for (var _len = arguments.length, pos = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    pos[_key - 1] = arguments[_key];
                }

                context.moveTo(pos[0][0], pos[0][1]);
                pos.slice(1).map(function (e) {
                    return context.lineTo(e[0], e[1]);
                });
                context.lineWidth = 1;
                context.strokeStyle = color;
                context.stroke();
            };

            this.drawRoundRect = function (x, y, width, height, radius) {
                context.beginPath();
                context.moveTo(x, y + radius);

                // left line
                context.lineTo(x, y + height - radius);
                context.arcTo(x, y + height, x + radius, y + height, radius);

                // bottom line
                context.lineTo(x + width - radius, y + height);
                context.arcTo(x + width, y + height, x + width, y + height - radius, radius);

                // right line
                context.lineTo(x + width, y + radius);
                context.arcTo(x + width, y, x + width - radius, y, radius);

                // top line
                context.lineTo(x + radius, y);
                context.arcTo(x, y, x, y + radius, radius);

                context.closePath();
            };

            this.drawFreeRect = function (x1, y1, x2, y2, x3, y3, x4, y4, color) {
                var borderColor = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;

                color = color || '#ffffff';
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.lineTo(x3, y3);
                context.lineTo(x4, y4);
                context.closePath();
                context.fillStyle = color;
                if (borderColor != null) {
                    context.lineWidth = 2;
                    context.strokeStyle = borderColor;
                    context.stroke();
                }
                context.fill();
            };

            this.drawFreeRectStroke = function (x1, y1, x2, y2, x3, y3, x4, y4, color) {
                color = color || '#ffffff';
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.lineTo(x3, y3);
                context.lineTo(x4, y4);
                context.lineWidth = 1;
                context.strokeStyle = color;
                context.stroke();
            };

            this.drawTriangle = function (x1, y1, d, color) {
                color = color || '#ffffff';
                context.beginPath();
                context.moveTo(x1, y1 - d);
                context.lineTo(x1 - d, y1 + d);
                context.lineTo(x1 + d, y1 + d);
                context.closePath();
                context.fillStyle = color;
                context.fill();
            };

            this.drawSquare = function (x1, y1, d, color) {
                color = color || '#ffffff';
                context.beginPath();
                context.moveTo(x1 - d, y1 - d);
                context.lineTo(x1 - d, y1 + d);
                context.lineTo(x1 + d, y1 + d);
                context.lineTo(x1 + d, y1 - d);
                context.closePath();
                context.fillStyle = color;
                context.fill();
            };

            this.drawPage = function (value, x1, y1, color) {
                var border = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

                drawFreeRect(context, value + x1, y1, value + x1 - 20, y1 + 14, value + x1 - 20, y1 + 52, value + x1, y1 + 38, color, border ? 'rgba(255,255,255,0.2)' : null);
            };

            this.drawCircle = function (x, y, d, color) {
                color = color || 'white';
                d = d || 1;
                context.beginPath();
                context.arc(x, y, d, 0, 2 * Math.PI);
                context.fillStyle = color;
                context.fill();
            };

            this.drawBullet = function (x, y) {
                var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 74;

                var grd = context.createLinearGradient(x, y, x + width, y);
                grd.addColorStop(0, '#1074fc');
                grd.addColorStop(1, 'rgba(37, 172, 254, 0)');

                context.beginPath();
                context.arc(x, y, 2, Math.PI / 2, Math.PI / 2 * 3);
                context.lineTo(x + width, y - 2);
                context.lineTo(x + width, y + 2);
                context.closePath();
                context.fillStyle = grd;
                context.fill();
                context.fillStyle = grd;
            };

            this.getCurvePoints = function (pts, minY, maxY) {
                var tension = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
                var isClosed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
                var numOfSegments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 16;

                var _pts = [],
                    res = [],
                    // clone array
                x,
                    y,
                    // our x,y coords
                t1x,
                    t2x,
                    t1y,
                    t2y,
                    // tension vectors
                c1,
                    c2,
                    c3,
                    c4,
                    // cardinal points
                st,
                    t,
                    i; // steps based on num. of segments

                // clone array so we don't change the original
                _pts = pts.slice(0);

                // The algorithm require a previous and next point to the actual point array.
                // Check if we will draw closed or open curve.
                // If closed, copy end points to beginning and first points to end
                // If open, duplicate first points to befinning, end points to end
                if (isClosed) {
                    _pts.unshift(pts[pts.length - 1]);
                    _pts.unshift(pts[pts.length - 2]);
                    _pts.unshift(pts[pts.length - 1]);
                    _pts.unshift(pts[pts.length - 2]);
                    _pts.push(pts[0]);
                    _pts.push(pts[1]);
                } else {
                    _pts.unshift(pts[1]); //copy 1. point and insert at beginning
                    _pts.unshift(pts[0]);
                    _pts.push(pts[pts.length - 2]); //copy last point and append
                    _pts.push(pts[pts.length - 1]);
                }

                // ok, lets start..

                // 1. loop goes through point array
                // 2. loop goes through each segment between the 2 pts + 1e point before and after
                for (i = 2; i < _pts.length - 4; i += 2) {
                    for (t = 0; t <= numOfSegments; t++) {

                        // calc tension vectors
                        t1x = (_pts[i + 2] - _pts[i - 2]) * tension;
                        t2x = (_pts[i + 4] - _pts[i]) * tension;

                        t1y = (_pts[i + 3] - _pts[i - 1]) * tension;
                        t2y = (_pts[i + 5] - _pts[i + 1]) * tension;

                        // calc step
                        st = t / numOfSegments;

                        // calc cardinals
                        c1 = 2 * Math.pow(st, 3) - 3 * Math.pow(st, 2) + 1;
                        c2 = -(2 * Math.pow(st, 3)) + 3 * Math.pow(st, 2);
                        c3 = Math.pow(st, 3) - 2 * Math.pow(st, 2) + st;
                        c4 = Math.pow(st, 3) - Math.pow(st, 2);

                        // calc x and y cords with common control vectors
                        x = c1 * _pts[i] + c2 * _pts[i + 2] + c3 * t1x + c4 * t2x;
                        y = c1 * _pts[i + 1] + c2 * _pts[i + 3] + c3 * t1y + c4 * t2y;

                        //store points in array
                        res.push(x);
                        if (y > maxY) res.push(maxY);else if (y < minY) res.push(minY);else res.push(y);
                    }
                }

                return res;
            };
        };

        return CanvasBase;
    }
};

var pixelRatio = function () {
    var canvas = document.createElement('canvas'),
        context = canvas.getContext('2d'),
        backingStore = context && (context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio) || 1;

    return (window.devicePixelRatio || 1) / backingStore;
}();

function polyfillForCanvasRenderingContext2D(prototype) {
    var forEach = function forEach(obj, func) {
        for (var p in obj) {
            if (obj.hasOwnProperty(p)) {
                func(obj[p], p);
            }
        }
    },
        ratioArgs = {
        'fillRect': 'all',
        'clearRect': 'all',
        'strokeRect': 'all',
        'moveTo': 'all',
        'lineTo': 'all',
        'arc': [0, 1, 2],
        'arcTo': 'all',
        'bezierCurveTo': 'all',
        'isPointinPath': 'all',
        'isPointinStroke': 'all',
        'quadraticCurveTo': 'all',
        'rect': 'all',
        'translate': 'all',
        'createRadialGradient': 'all',
        'createLinearGradient': 'all'
    };

    if (pixelRatio === 1) return;

    forEach(ratioArgs, function (value, key) {
        prototype[key] = function (_super) {
            return function () {
                var i = void 0,
                    len = void 0,
                    args = Array.prototype.slice.call(arguments);

                if (value === 'all') {
                    args = args.map(function (a) {
                        return a * pixelRatio;
                    });
                } else if (Array.isArray(value)) {
                    for (i = 0, len = value.length; i < len; i++) {
                        args[value[i]] *= pixelRatio;
                    }
                }

                return _super.apply(this, args);
            };
        }(prototype[key]);
    });

    // Stroke lineWidth adjustment
    prototype.stroke = function (_super) {
        return function () {
            this.lineWidth *= pixelRatio;
            _super.apply(this, arguments);
            this.lineWidth /= pixelRatio;
        };
    }(prototype.stroke);

    // Text
    //
    prototype.fillText = function (_super) {
        return function () {
            var args = Array.prototype.slice.call(arguments);

            args[1] *= pixelRatio; // x
            args[2] *= pixelRatio; // y

            this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
                return m * pixelRatio + u;
            });

            _super.apply(this, args);

            this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
                return m / pixelRatio + u;
            });
        };
    }(prototype.fillText);

    prototype.strokeText = function (_super) {
        return function () {
            var args = Array.prototype.slice.call(arguments);

            args[1] *= pixelRatio; // x
            args[2] *= pixelRatio; // y

            this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
                return m * pixelRatio + u;
            });

            _super.apply(this, args);

            this.font = this.font.replace(/(\d+)(px|em|rem|pt)/g, function (w, m, u) {
                return m / pixelRatio + u;
            });
        };
    }(prototype.strokeText);
}

function polyfillForHTMLCanvasElement(prototype) {
    prototype.getContext = function (_super) {
        return function (type) {
            var context = _super.call(this, type);

            if (type === '2d') {
                if (pixelRatio > 1) {
                    this.style.height = this.height + 'px';
                    this.style.width = this.width + 'px';
                    this.width *= pixelRatio;
                    this.height *= pixelRatio;
                }
            }

            return context;
        };
    }(prototype.getContext);
}

var CanvasHidpiUtil = {
    name: "util.canvas.hidpi",
    extend: null,
    component: function component() {
        return {
            polyfills: function polyfills() {
                polyfillForCanvasRenderingContext2D(CanvasRenderingContext2D.prototype);
                polyfillForHTMLCanvasElement(HTMLCanvasElement.prototype);
            },
            apply: function apply(context) {
                polyfillForCanvasRenderingContext2D(context);
            },
            pixelRatio: pixelRatio
        };
    }
};

var JUISvgElement = {
    name: "util.svg.element",
    extend: null,
    component: function component() {
        var Element = function Element() {
            var events = [];

            this.create = function (type, attr) {
                // 퍼블릭 프로퍼티
                this.element = document.createElementNS("http://www.w3.org/2000/svg", type);
                this.children = [];
                this.parent = null;
                this.styles = {};
                this.attributes = {};
                this.order = 0;

                // 기본 속성 설정
                this.attr(attr);
            };

            this.each = function (callback) {
                if (typeof callback != "function") return;

                for (var i = 0, len = this.children.length; i < len; i++) {
                    var self = this.children[i];
                    callback.apply(self, [i, self]);
                }

                return this.children;
            };

            this.get = function (index) {
                if (this.children[index]) {
                    return this.children[index];
                }

                return null;
            };

            this.index = function (obj) {
                for (var i = 0; i < this.children.length; i++) {
                    if (obj == this.children[i]) {
                        return i;
                    }
                }

                return -1;
            };

            this.append = function (elem) {
                if (elem instanceof Element) {
                    if (elem.parent) {
                        elem.remove();
                    }

                    this.children.push(elem);
                    elem.parent = this;
                }

                return this;
            };

            this.prepend = function (elem) {
                return this.insert(0, elem);
            };

            this.insert = function (index, elem) {
                if (elem.parent) {
                    elem.remove();
                }

                this.children.splice(index, 0, elem);
                elem.parent = this;

                return this;
            };

            this.remove = function () {
                var nChild = [],
                    pChild = this.parent.children;

                for (var i = 0; i < pChild.length; i++) {
                    if (pChild[i] == this) {
                        break;
                    }

                    nChild.push(pChild[i]);
                }

                this.parent.children = nChild;

                return this;
            };

            this.attr = function (attr) {
                if (typeof attr == "undefined" || !attr) return;

                if (typeof attr == "string") {
                    return this.attributes[attr] || this.element.getAttribute(attr);
                }

                for (var k in attr) {
                    this.attributes[k] = attr[k];

                    if (k.indexOf("xlink:") != -1) {
                        this.element.setAttributeNS("http://www.w3.org/1999/xlink", k, attr[k]);
                    } else {
                        this.element.setAttribute(k, attr[k]);
                    }
                }

                return this;
            };

            this.css = function (css) {
                var list = [];

                for (var k in css) {
                    this.styles[k] = css[k];
                }

                for (var k in css) {
                    list.push(k + ":" + css[k]);
                }

                this.attr({ style: list.join(";") });

                return this;
            };

            this.html = function (html) {
                // @deprecated
                this.element.innerHTML = html;

                return this;
            };

            this.text = function (text) {
                var children = this.element.childNodes;

                for (var i = 0; i < children.length; i++) {
                    this.element.removeChild(children[i]);
                }

                this.element.appendChild(document.createTextNode(text));
                return this;
            };

            this.on = function (type, handler) {
                var callback = function callback(e) {
                    if (typeof handler == "function") {
                        handler.call(this, e);
                    }
                };

                this.element.addEventListener(type, callback, false);
                events.push({ type: type, callback: callback });

                return this;
            };

            this.off = function (type) {
                if (!type) {
                    for (var i = 0, len = events.length; i < len; i++) {
                        var e = events.shift();

                        this.element.removeEventListener(e.type, e.callback, false);
                    }
                } else {
                    var newEvents = [];

                    for (var i = 0, len = events.length; i < len; i++) {
                        var e = events[i];

                        if (e.type != type) {
                            newEvents.push(e);
                        } else {
                            this.element.removeEventListener(e.type, e.callback, false);
                        }
                    }

                    events = newEvents;
                }

                return this;
            };

            this.hover = function (overHandler, outHandler) {
                var callback1 = function callback1(e) {
                    if (typeof overHandler == "function") {
                        overHandler.call(this, e);
                    }
                };

                var callback2 = function callback2(e) {
                    if (typeof outHandler == "function") {
                        outHandler.call(this, e);
                    }
                };

                this.element.addEventListener("mouseover", callback1, false);
                this.element.addEventListener("mouseout", callback2, false);
                events.push({ type: "mouseover", callback: callback1 });
                events.push({ type: "mouseout", callback: callback2 });

                return this;
            };

            this.size = function () {
                var size = { width: 0, height: 0 },
                    rect = this.element.getBoundingClientRect();

                if (!rect || rect.width == 0 && rect.height == 0) {
                    var height_list = ["height", "paddingTop", "paddingBottom", "borderTopWidth", "borderBottomWidth"],
                        width_list = ["width", "paddingLeft", "paddingRight", "borderLeftWidth", "borderRightWidth"];

                    var computedStyle = window.getComputedStyle(this.element);

                    for (var i = 0; i < height_list.length; i++) {
                        size.height += parseFloat(computedStyle[height_list[i]]);
                    }

                    for (var i = 0; i < width_list.length; i++) {
                        size.width += parseFloat(computedStyle[width_list[i]]);
                    }

                    size.width = size.width || this.element.getAttribute('width');
                    size.height = size.height || this.element.getAttribute('height');
                } else {
                    size.width = rect.width;
                    size.height = rect.height;
                }

                if (isNaN(size.width)) size.width = 0;
                if (isNaN(size.height)) size.height = 0;

                return size;
            };

            this.is = function (moduleId) {
                return this instanceof jui.include(moduleId);
            };
        };

        return Element;
    }
};

var JUISvgTransformElement = {
    name: "util.svg.element.transform",
    extend: "util.svg.element",
    component: function component() {
        var _ = jui$1.include("util.base");

        var TransElement = function TransElement() {
            var orders = {
                translate: null,
                scale: null,
                rotate: null,
                skew: null,
                matrix: null
            };

            function applyOrders(self) {
                var orderArr = [];

                for (var key in orders) {
                    if (orders[key]) orderArr.push(orders[key]);
                }

                self.attr({ transform: orderArr.join(" ") });
            }

            function getStringArgs(args) {
                var result = [];

                for (var i = 0; i < args.length; i++) {
                    result.push(args[i]);
                }

                return result.join(",");
            }

            this.translate = function () {
                orders["translate"] = "translate(" + getStringArgs(arguments) + ")";
                applyOrders(this);

                return this;
            };

            this.rotate = function (angle, x, y) {
                if (arguments.length == 1) {
                    var str = angle;
                } else if (arguments.length == 3) {
                    var str = angle + " " + x + "," + y;
                }

                orders["rotate"] = "rotate(" + str + ")";
                applyOrders(this);

                return this;
            };

            this.scale = function () {
                orders["scale"] = "scale(" + getStringArgs(arguments) + ")";
                applyOrders(this);

                return this;
            };

            this.skew = function () {
                orders["skew"] = "skew(" + getStringArgs(arguments) + ")";
                applyOrders(this);

                return this;
            };

            this.matrix = function () {
                orders["matrix"] = "matrix(" + getStringArgs(arguments) + ")";
                applyOrders(this);

                return this;
            };

            this.data = function (type) {
                var text = this.attr("transform"),
                    regex = {
                    translate: /[^translate()]+/g,
                    rotate: /[^rotate()]+/g,
                    scale: /[^scale()]+/g,
                    skew: /[^skew()]+/g,
                    matrix: /[^matrix()]+/g
                };

                if (_.typeCheck("string", text)) {
                    return text.match(regex[type])[0];
                }

                return null;
            };
        };

        return TransElement;
    }
};

var JUISvgPathElement = {
    name: "util.svg.element.path",
    extend: "util.svg.element.transform",
    component: function component() {
        var _ = jui$1.include("util.base");

        var PathElement = function PathElement() {
            var orders = [];

            this.moveTo = function (x, y, type) {
                orders.push((type || "m") + x + "," + y);
                return this;
            };
            this.MoveTo = function (x, y) {
                return this.moveTo(x, y, "M");
            };

            this.lineTo = function (x, y, type) {
                orders.push((type || "l") + x + "," + y);
                return this;
            };
            this.LineTo = function (x, y) {
                return this.lineTo(x, y, "L");
            };

            this.hLineTo = function (x, type) {
                orders.push((type || "h") + x);
                return this;
            };
            this.HLineTo = function (x) {
                return this.hLineTo(x, "H");
            };

            this.vLineTo = function (y, type) {
                orders.push((type || "v") + y);
                return this;
            };
            this.VLineTo = function (y) {
                return this.vLineTo(y, "V");
            };

            this.curveTo = function (x1, y1, x2, y2, x, y, type) {
                orders.push((type || "c") + x1 + "," + y1 + " " + x2 + "," + y2 + " " + x + "," + y);
                return this;
            };
            this.CurveTo = function (x1, y1, x2, y2, x, y) {
                return this.curveTo(x1, y1, x2, y2, x, y, "C");
            };

            this.sCurveTo = function (x2, y2, x, y, type) {
                orders.push((type || "s") + x2 + "," + y2 + " " + x + "," + y);
                return this;
            };
            this.SCurveTo = function (x2, y2, x, y) {
                return this.sCurveTo(x2, y2, x, y, "S");
            };

            this.qCurveTo = function (x1, y1, x, y, type) {
                orders.push((type || "q") + x1 + "," + y1 + " " + x + "," + y);
                return this;
            };
            this.QCurveTo = function (x1, y1, x, y) {
                return this.qCurveTo(x1, y1, x, y, "Q");
            };

            this.tCurveTo = function (x1, y1, x, y, type) {
                orders.push((type || "t") + x1 + "," + y1 + " " + x + "," + y);
                return this;
            };
            this.TCurveTo = function (x1, y1, x, y) {
                return this.tCurveTo(x1, y1, x, y, "T");
            };

            this.arc = function (rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, x, y, type) {
                large_arc_flag = large_arc_flag ? 1 : 0;
                sweep_flag = sweep_flag ? 1 : 0;

                orders.push((type || "a") + rx + "," + ry + " " + x_axis_rotation + " " + large_arc_flag + "," + sweep_flag + " " + x + "," + y);
                return this;
            };
            this.Arc = function (rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, x, y) {
                return this.arc(rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, x, y, "A");
            };

            this.closePath = function (type) {
                orders.push(type || "z");
                return this;
            };
            this.ClosePath = function () {
                return this.closePath("Z");
            };

            this.join = function () {
                if (orders.length > 0) {
                    this.attr({ d: orders.join(" ") });
                    orders = [];
                }
            };

            this.length = function () {
                var id = _.createId(),
                    d = orders.join(" ");

                var svg = document.createElement("svg"),
                    path = document.createElementNS("http://www.w3.org/2000/svg", "path");

                path.setAttributeNS(null, "id", id);
                path.setAttributeNS(null, "d", d);
                svg.appendChild(path);

                document.body.appendChild(svg);
                var length = document.getElementById(id).getTotalLength();
                document.body.removeChild(svg);

                return length;
            };
        };

        return PathElement;
    }
};

var JUISvgPathRectElement = {
    name: "util.svg.element.path.rect",
    extend: "util.svg.element.path",
    component: function component() {
        var PathRectElement = function PathRectElement() {
            this.round = function (width, height, tl, tr, br, bl) {
                tl = !tl ? 0 : tl;
                tr = !tr ? 0 : tr;
                br = !br ? 0 : br;
                bl = !bl ? 0 : bl;

                this.MoveTo(0, tl).Arc(tl, tl, 0, 0, 1, tl, 0).HLineTo(width - tr).Arc(tr, tr, 0, 0, 1, width, tr).VLineTo(height - br).Arc(br, br, 0, 0, 1, width - br, height).HLineTo(bl).Arc(bl, bl, 0, 0, 1, 0, height - bl).ClosePath().join();
            };
        };

        return PathRectElement;
    }
};

var JUISvgPathSymbolElement = {
    name: "util.svg.element.path.symbol",
    extend: "util.svg.element.path",
    component: function component() {
        var PathSymbolElement = function PathSymbolElement() {
            var ordersString = "";

            /**
             * 심볼 템플릿
             *
             */
            this.template = function (width, height) {
                var r = width,
                    half_width = half_r = width / 2,
                    half_height = height / 2;

                var start = "a" + half_r + "," + half_r + " 0 1,1 " + r + ",0",
                    end = "a" + half_r + "," + half_r + " 0 1,1 " + -r + ",0";

                var obj = {
                    triangle: ["m0," + -half_height, "l" + half_width + "," + height, "l" + -width + ",0", "l" + half_width + "," + -height].join(" "),
                    rect: ["m" + -half_width + "," + -half_height, "l" + width + ",0", "l0," + height, "l" + -width + ',0', "l0," + -height].join(" "),
                    cross: ["m" + -half_width + ',' + -half_height, "l" + width + "," + height, "m0," + -height, "l" + -width + "," + height].join(" "),
                    circle: ["m" + -r + ",0", start, end].join(" ")
                };

                obj.rectangle = obj.rect;

                return obj;
            };

            this.join = function () {
                if (ordersString.length > 0) {
                    this.attr({ d: ordersString });
                    ordersString = "";
                }
            };

            /**
             * 심볼 추가 하기 (튜닝)
             */
            this.add = function (cx, cy, tpl) {
                ordersString += " M" + cx + "," + cy + tpl;
            };

            /**
             * path 내 심볼 생성
             *
             */
            this.triangle = function (cx, cy, width, height) {
                return this.MoveTo(cx, cy).moveTo(0, -height / 2).lineTo(width / 2, height).lineTo(-width, 0).lineTo(width / 2, -height);
            };

            this.rect = this.rectangle = function (cx, cy, width, height) {
                return this.MoveTo(cx, cy).moveTo(-width / 2, -height / 2).lineTo(width, 0).lineTo(0, height).lineTo(-width, 0).lineTo(0, -height);
            };

            this.cross = function (cx, cy, width, height) {
                return this.MoveTo(cx, cy).moveTo(-width / 2, -height / 2).lineTo(width, height).moveTo(0, -height).lineTo(-width, height);
            };

            this.circle = function (cx, cy, r) {
                return this.MoveTo(cx, cy).moveTo(-r, 0).arc(r / 2, r / 2, 0, 1, 1, r, 0).arc(r / 2, r / 2, 0, 1, 1, -r, 0);
            };
        };

        return PathSymbolElement;
    }
};

var JUISvgPolyElement = {
    name: "util.svg.element.poly",
    extend: "util.svg.element.transform",
    component: function component() {
        var PolyElement = function PolyElement() {
            var orders = [];

            this.point = function (x, y) {
                orders.push(x + "," + y);
                return this;
            };

            this.join = function () {
                if (orders.length > 0) {
                    // Firefox 처리
                    var start = orders[0];
                    orders.push(start);

                    // 폴리곤 그리기
                    this.attr({ points: orders.join(" ") });
                    orders = [];
                }
            };
        };

        return PolyElement;
    }
};

jui$1.use(JUISvgElement, JUISvgTransformElement, JUISvgPathElement, JUISvgPathSymbolElement, JUISvgPathRectElement, JUISvgPolyElement);

var JUISvgBase = {
    name: "util.svg.base",
    extend: null,
    component: function component() {
        var _ = jui$1.include("util.base");
        var Element = jui$1.include("util.svg.element");
        var TransElement = jui$1.include("util.svg.element.transform");
        var PathElement = jui$1.include("util.svg.element.path");
        var PathSymbolElement = jui$1.include("util.svg.element.path.symbol");
        var PathRectElement = jui$1.include("util.svg.element.path.rect");
        var PolyElement = jui$1.include("util.svg.element.poly");

        var globalObj = null;

        /**
         * @class util.svg.base
         * SVG base module
         *
         * @requires util.base
         * @requires util.math
         * @requires util.color
         * @requires util.svg.element
         * @requires util.svg.element.transform
         * @requires util.svg.element.path
         * @requires util.svg.element.path.symbol
         * @requires util.svg.element.path.rect
         * @requires util.svg.element.poly
         * @alias SVGBase
         */
        var SVGBase = function SVGBase() {
            this.create = function (obj, type, attr, callback) {
                obj.create(type, attr);
                return obj;
            };

            this.createChild = function (obj, type, attr, callback) {
                return this.create(obj, type, attr, callback);
            };

            /**
             * @method custom
             *
             * return custom element
             *
             * @param {String} name
             * @param {Object} attr
             * @param {Function} callback
             * @return {util.svg.element}
             */
            this.custom = function (name, attr, callback) {
                return this.create(new Element(), name, attr, callback);
            };

            /**
             * @method defs
             *
             * return defs element
             *
             * @param {Function} callback
             * @return {util.svg.element}
             */
            this.defs = function (callback) {
                return this.create(new Element(), "defs", null, callback);
            };

            /**
             * @method symbol
             *
             * return symbol element
             *
             * @param {Object} attr
             * @param {Function} callback
             * @return {util.svg.element}
             */
            this.symbol = function (attr, callback) {
                return this.create(new Element(), "symbol", attr, callback);
            };

            /**
             * @method g
             *
             * return defs element
             *
             * @alias group
             * @param {Object} attr
             * @param {Function} callback
             * @return {util.svg.element.transform}
             */
            this.g = this.group = function (attr, callback) {
                return this.create(new TransElement(), "g", attr, callback);
            };

            /**
             * @method marker
             *
             * return marker element
             *
             * @param {Object} attr
             * @param {Function} callback
             * @return {util.svg.element}
             */
            this.marker = function (attr, callback) {
                return this.create(new Element(), "marker", attr, callback);
            };

            /**
             * @method a
             *
             * return a element
             *
             * @param {Object} attr
             * @param {Function} callback
             * @return {util.svg.element.transform}
             */
            this.a = function (attr, callback) {
                return this.create(new TransElement(), "a", attr, callback);
            };

            /**
             * @method switch
             *
             * return switch element
             *
             * @param {Object} attr
             * @param {Function} callback
             * @return {util.svg.element}
             */
            this.switch = function (attr, callback) {
                return this.create(new Element(), "switch", attr, callback);
            };

            /**
             * @method use
             *
             * return use element
             *
             * @param {Object} attr
             * @return {util.svg.element}
             */
            this.use = function (attr) {
                return this.create(new Element(), "use", attr);
            };

            /**
             * @method rect
             *
             * return rect element
             *
             * @param {Object} attr
             * @param {Function} callback
             * @return {util.svg.element.transform}
             */
            this.rect = function (attr, callback) {
                return this.create(new TransElement(), "rect", attr, callback);
            };

            /**
             * @method line
             *
             * return line element
             *
             * @param {Object} attr
             * @param {Function} callback
             * @return {util.svg.element.transform}
             */
            this.line = function (attr, callback) {
                return this.create(new TransElement(), "line", attr, callback);
            };

            this.circle = function (attr, callback) {
                return this.create(new TransElement(), "circle", attr, callback);
            };

            this.text = function (attr, textOrCallback) {
                if (arguments.length == 2) {
                    if (_.typeCheck("function", textOrCallback)) {
                        return this.create(new TransElement(), "text", attr, textOrCallback);
                    }

                    return this.create(new TransElement(), "text", attr).text(textOrCallback);
                }

                return this.create(new TransElement(), "text", attr);
            };

            this.textPath = function (attr, text) {
                if (_.typeCheck("string", text)) {
                    return this.create(new Element(), "textPath", attr).text(text);
                }

                return this.create(new Element(), "textPath", attr);
            };

            this.tref = function (attr, text) {
                if (_.typeCheck("string", text)) {
                    return this.create(new Element(), "tref", attr).text(text);
                }

                return this.create(new Element(), "tref", attr);
            };

            this.tspan = function (attr, text) {
                if (_.typeCheck("string", text)) {
                    return this.create(new Element(), "tspan", attr).text(text);
                }

                return this.create(new Element(), "tspan", attr);
            };

            this.ellipse = function (attr, callback) {
                return this.create(new TransElement(), "ellipse", attr, callback);
            };

            this.image = function (attr, callback) {
                return this.create(new TransElement(), "image", attr, callback);
            };

            this.path = function (attr, callback) {
                return this.create(new PathElement(), "path", attr, callback);
            };

            this.pathSymbol = function (attr, callback) {
                return this.create(new PathSymbolElement(), "path", attr, callback);
            };

            this.pathRect = function (attr, callback) {
                return this.create(new PathRectElement(), "path", attr, callback);
            };

            this.polyline = function (attr, callback) {
                return this.create(new PolyElement(), "polyline", attr, callback);
            };

            this.polygon = function (attr, callback) {
                return this.create(new PolyElement(), "polygon", attr, callback);
            };

            this.pattern = function (attr, callback) {
                return this.create(new Element(), "pattern", attr, callback);
            };

            this.mask = function (attr, callback) {
                return this.create(new Element(), "mask", attr, callback);
            };

            this.clipPath = function (attr, callback) {
                return this.create(new Element(), "clipPath", attr, callback);
            };

            this.linearGradient = function (attr, callback) {
                return this.create(new Element(), "linearGradient", attr, callback);
            };

            this.radialGradient = function (attr, callback) {
                return this.create(new Element(), "radialGradient", attr, callback);
            };

            this.filter = function (attr, callback) {
                return this.create(new Element(), "filter", attr, callback);
            };

            this.foreignObject = function (attr, callback) {
                return this.create(new TransElement(), "foreignObject", attr, callback);
            };

            /**
             * 엘리먼트 관련 메소드 (그라데이션)
             *
             */

            this.stop = function (attr) {
                return this.createChild(new Element(), "stop", attr);
            };

            /**
             * 엘리먼트 관련 메소드 (애니메이션)
             *
             */

            this.animate = function (attr) {
                return this.createChild(new Element(), "animate", attr);
            };

            this.animateColor = function (attr) {
                return this.createChild(new Element(), "animateColor", attr);
            };

            this.animateMotion = function (attr) {
                return this.createChild(new Element(), "animateMotion", attr);
            };

            this.animateTransform = function (attr) {
                return this.createChild(new Element(), "animateTransform", attr);
            };

            this.mpath = function (attr) {
                return this.createChild(new Element(), "mpath", attr);
            };

            this.set = function (attr) {
                return this.createChild(new Element(), "set", attr);
            };

            /**
             * 엘리먼트 관련 메소드 (필터)
             *
             */

            this.feBlend = function (attr) {
                return this.createChild(new Element(), "feBlend", attr);
            };

            this.feColorMatrix = function (attr) {
                return this.createChild(new Element(), "feColorMatrix", attr);
            };

            this.feComponentTransfer = function (attr) {
                return this.createChild(new Element(), "feComponentTransfer", attr);
            };

            this.feComposite = function (attr) {
                return this.createChild(new Element(), "feComposite", attr);
            };

            this.feConvolveMatrix = function (attr) {
                return this.createChild(new Element(), "feConvolveMatrix", attr);
            };

            this.feDiffuseLighting = function (attr) {
                return this.createChild(new Element(), "feDiffuseLighting", attr);
            };

            this.feDisplacementMap = function (attr) {
                return this.createChild(new Element(), "feDisplacementMap", attr);
            };

            this.feFlood = function (attr) {
                return this.createChild(new Element(), "feFlood", attr);
            };

            this.feGaussianBlur = function (attr) {
                return this.createChild(new Element(), "feGaussianBlur", attr);
            };

            this.feImage = function (attr) {
                return this.createChild(new Element(), "feImage", attr);
            };

            this.feMerge = function (attr, callback) {
                return this.createChild(new Element(), "feMerge", attr, callback);
            };

            this.feMergeNode = function (attr) {
                return this.createChild(new Element(), "feMergeNode", attr);
            };

            this.feMorphology = function (attr) {
                return this.createChild(new Element(), "feMorphology", attr);
            };

            this.feOffset = function (attr) {
                return this.createChild(new Element(), "feOffset", attr);
            };

            this.feSpecularLighting = function (attr) {
                return this.createChild(new Element(), "feSpecularLighting", attr);
            };

            this.feTile = function (attr) {
                return this.createChild(new Element(), "feTile", attr);
            };

            this.feTurbulence = function (attr) {
                return this.createChild(new Element(), "feTurbulence", attr);
            };
        };

        SVGBase.create = function (name, attr, callback) {
            if (globalObj == null) {
                globalObj = new SVGBase();
            }

            return globalObj.custom(name, attr, callback);
        };

        return SVGBase;
    }
};

jui$1.use(math, color, JUISvgBase);

var JUISvgBase3d = {
    name: "util.svg.base3d",
    extend: "util.svg.base",
    component: function component() {
        var _ = jui$1.include("util.base");
        var math$$1 = jui$1.include("util.math");
        var color$$1 = jui$1.include("util.color");

        var SVG3d = function SVG3d() {

            this.rect3d = function (fill, width, height, degree, depth) {
                var self = this;

                var radian = math$$1.radian(degree),
                    x1 = 0,
                    y1 = 0,
                    w1 = width,
                    h1 = height;

                var x2 = Math.cos(radian) * depth,
                    y2 = Math.sin(radian) * depth,
                    w2 = width + x2,
                    h2 = height + y2;

                var g = self.group({}, function () {
                    self.path({
                        fill: color$$1.lighten(fill, 0.15),
                        stroke: color$$1.lighten(fill, 0.15)
                    }).MoveTo(x2, x1).LineTo(w2, y1).LineTo(w1, y2).LineTo(x1, y2);

                    self.path({
                        fill: fill,
                        stroke: fill
                    }).MoveTo(x1, y2).LineTo(x1, h2).LineTo(w1, h2).LineTo(w1, y2);

                    self.path({
                        fill: color$$1.darken(fill, 0.2),
                        stroke: color$$1.darken(fill, 0.2)
                    }).MoveTo(w1, h2).LineTo(w2, h1).LineTo(w2, y1).LineTo(w1, y2);
                });

                return g;
            };

            this.cylinder3d = function (fill, width, height, degree, depth, rate) {
                var self = this;

                var radian = math$$1.radian(degree),
                    rate = rate == undefined ? 1 : rate == 0 ? 0.01 : rate,
                    r = width / 2,
                    tr = r * rate,
                    l = Math.cos(radian) * depth / 2,
                    d = Math.sin(radian) * depth / 2,
                    key = _.createId("cylinder3d");

                var g = self.group({}, function () {
                    self.ellipse({
                        fill: color$$1.darken(fill, 0.05),
                        "fill-opacity": 0.85,
                        stroke: color$$1.darken(fill, 0.05),
                        rx: r,
                        ry: d,
                        cx: r,
                        cy: height
                    }).translate(l, d);

                    self.path({
                        fill: "url(#" + key + ")",
                        "fill-opacity": 0.85,
                        stroke: fill
                    }).MoveTo(r - tr, d).LineTo(0, height).Arc(r, d, 0, 0, 0, width, height).LineTo(r + tr, d).Arc(r + tr, d, 0, 0, 1, r - tr, d).translate(l, d);

                    self.ellipse({
                        fill: color$$1.lighten(fill, 0.2),
                        "fill-opacity": 0.95,
                        stroke: color$$1.lighten(fill, 0.2),
                        rx: r * rate,
                        ry: d * rate,
                        cx: r,
                        cy: d
                    }).translate(l, d);

                    self.linearGradient({
                        id: key,
                        x1: "100%",
                        x2: "0%",
                        y1: "0%",
                        y2: "0%"
                    }, function () {
                        self.stop({
                            offset: "0%",
                            "stop-color": color$$1.lighten(fill, 0.15)
                        });
                        self.stop({
                            offset: "33.333333333333336%",
                            "stop-color": color$$1.darken(fill, 0.2)
                        });
                        self.stop({
                            offset: "66.66666666666667%",
                            "stop-color": color$$1.darken(fill, 0.2)
                        });
                        self.stop({
                            offset: "100%",
                            "stop-color": color$$1.lighten(fill, 0.15)
                        });
                    });
                });

                return g;
            };
        };

        return SVG3d;
    }
};

jui$1.use(JUISvgBase3d);

var svg = {
    name: "util.svg",
    extend: "util.svg.base3d",
    component: function component() {
        var _ = jui$1.include("util.base");
        var Element = jui$1.include("util.svg.element");
        var TransElement = jui$1.include("util.svg.element.transform");
        var PathElement = jui$1.include("util.svg.element.path");
        var PolyElement = jui$1.include("util.svg.element.poly");

        var SVG = function SVG(rootElem, rootAttr) {
            var self = this,
                root = null,
                main = null,
                sub = null,
                parent = {},
                depth = 0;
            var isFirst = false; // 첫번째 렌더링 체크

            function init() {
                self.root = root = new Element();
                main = new TransElement();
                sub = new TransElement();

                root.create("svg", rootAttr);
                main.create("g");
                sub.create("g");

                main.translate(0.5, 0.5);
                sub.translate(0.5, 0.5);

                rootElem.appendChild(root.element);
                root.append(main);
                root.append(sub);
            }

            function appendAll(target) {
                var childs = target.children;

                // 엘리먼트 렌더링 순서 정하기
                if (isOrderingChild(childs)) {
                    childs.sort(function (a, b) {
                        return a.order - b.order;
                    });
                }

                for (var i = 0, len = childs.length; i < len; i++) {
                    var child = childs[i];

                    if (child) {
                        if (child.children.length > 0) {
                            appendAll(child);
                        }

                        // PathElement & PathSymbolElement & PathRectElement & PolyElement auto join
                        if (child instanceof PathElement || child instanceof PolyElement) {
                            child.join();
                        }

                        if (child.parent == target) {
                            target.element.appendChild(child.element);
                        }
                    }
                }
            }

            function removeEventAll(target) {
                var childs = target.children;

                for (var i = 0, len = childs.length; i < len; i++) {
                    var child = childs[i];

                    if (child) {
                        child.off();

                        if (child.children.length > 0) {
                            removeEventAll(child);
                        }
                    }
                }
            }

            function isOrderingChild(childs) {
                // order가 0 이상인 엘리먼트가 하나라도 있을 경우
                for (var i = 0, len = childs.length; i < len; i++) {
                    if (childs[i].order > 0) {
                        return true;
                    }
                }

                return false;
            }

            this.create = function (obj, type, attr, callback) {
                obj.create(type, attr);

                if (depth == 0) {
                    main.append(obj);
                } else {
                    parent[depth].append(obj);
                }

                if (_.typeCheck("function", callback)) {
                    depth++;
                    parent[depth] = obj;

                    callback.call(obj);
                    depth--;
                }

                return obj;
            };

            this.createChild = function (obj, type, attr, callback) {
                if (obj.parent == main) {
                    throw new Error("JUI_CRITICAL_ERR: Parents are required elements of the '" + type + "'");
                }

                return this.create(obj, type, attr, callback);
            };

            /**
             * @method size
             *
             * if arguments.length is 2, set attribute width, height to root element
             * if arguments.length is zero, return svg size
             *
             * @return {Object}
             * @return {Integer} width
             * @return {Integer} height
             */
            this.size = function () {
                if (arguments.length == 2) {
                    var w = arguments[0],
                        h = arguments[1];

                    root.attr({ width: w, height: h });
                } else {
                    return root.size();
                }
            };

            /**
             * @method clear
             * @param isAll
             */
            this.clear = function (isAll) {
                main.each(function () {
                    if (this.element.parentNode) {
                        main.element.removeChild(this.element);
                    }
                });

                removeEventAll(main);

                if (isAll === true) {
                    sub.each(function () {
                        if (this.element.parentNode) {
                            sub.element.removeChild(this.element);
                        }
                    });

                    removeEventAll(sub);
                }
            };

            /**
             * @method reset
             * @param isAll
             */
            this.reset = function (isAll) {
                this.clear(isAll);
                main.children = [];

                if (isAll === true) {
                    sub.children = [];
                }
            };

            /**
             * @method render
             * @param isAll
             */
            this.render = function (isAll) {
                this.clear();

                if (isFirst === false || isAll === true) {
                    appendAll(root);
                } else {
                    appendAll(main);
                }

                isFirst = true;
            };

            /**
             * @method
             * implements svg image file download used by canvas
             * @param name
             */
            this.download = function (name) {
                if (_.typeCheck("string", name)) {
                    name = name.split(".")[0];
                }

                var a = document.createElement("a");
                a.download = name ? name + ".svg" : "svg.svg";
                a.href = this.toDataURI(); //;_.svgToBase64(rootElem.innerHTML);

                document.body.appendChild(a);
                a.click();
                a.parentNode.removeChild(a);
            };

            this.downloadImage = function (name, type) {
                type = type || "image/png";

                var img = new Image();
                var size = this.size();
                var uri = this.toDataURI().replace('width="100%"', 'width="' + size.width + '"').replace('height="100%"', 'height="' + size.height + '"');
                img.onload = function () {
                    var canvas = document.createElement("canvas");
                    canvas.width = img.width;
                    canvas.height = img.height;

                    var context = canvas.getContext('2d');
                    context.drawImage(img, 0, 0);

                    var png = canvas.toDataURL(type);

                    if (_.typeCheck("string", name)) {
                        name = name.split(".")[0];
                    }

                    var a = document.createElement('a');
                    a.download = name ? name + ".png" : "svg.png";
                    a.href = png;

                    document.body.appendChild(a);
                    a.click();
                    a.parentNode.removeChild(a);
                };

                img.src = uri;
            };

            /**
             * @method exportCanvas
             *
             * convert svg image to canvas
             *
             * @param {Canvas} canvas
             */
            this.exportCanvas = function (canvas) {
                var img = new Image(),
                    size = this.size();

                var uri = this.toDataURI().replace('width="100%"', 'width="' + size.width + '"').replace('height="100%"', 'height="' + size.height + '"');

                img.onload = function () {
                    canvas.width = img.width;
                    canvas.height = img.height;

                    var context = canvas.getContext('2d');
                    context.drawImage(img, 0, 0);
                };

                img.src = uri;
            };

            /**
             * @method toXML
             *
             * convert xml string
             *
             * @return {String} xml
             */
            this.toXML = function () {
                var text = rootElem.innerHTML;

                text = text.replace('xmlns="http://www.w3.org/2000/svg"', '');

                return ['<?xml version="1.0" encoding="utf-8"?>', text.replace("<svg ", '<svg xmlns="http://www.w3.org/2000/svg" ')].join("\n");
            };

            /**
             * @method toDataURI
             *
             * convert svg to datauri format
             *
             * @return {String}
             */
            this.toDataURI = function () {
                var xml = this.toXML();

                if (_.browser.mozilla || _.browser.msie) {
                    xml = encodeURIComponent(xml);
                }

                if (_.browser.msie) {
                    return "data:image/svg+xml," + xml;
                } else {
                    return "data:image/svg+xml;utf8," + xml;
                }
            };

            /**
             * @method autoRender
             *
             * @param {util.svg.element} elem
             * @param {Boolean} isAuto
             */
            this.autoRender = function (elem, isAuto) {
                if (depth > 0) return;

                if (!isAuto) {
                    sub.append(elem);
                } else {
                    main.append(elem);
                }
            };

            /**
             * @method getTextSize
             *
             * caculate real pixel size of text element
             *
             * @param {String} text target text
             * @return {Object}
             * @return {Integer} return.width  text element's width (px)
             * @return {Integer} return.height text element's height(px)
             */
            this.getTextSize = function (text, opt) {
                if (text == "") {
                    return { width: 0, height: 0 };
                }

                opt = opt || {};

                var bodyElement = document.body || root.element;

                var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg.setAttributeNS(null, "width", 500);
                svg.setAttributeNS(null, "height", 100);
                svg.setAttributeNS(null, "x", -20000);
                svg.setAttributeNS(null, "y", -20000);

                var el = document.createElementNS("http://www.w3.org/2000/svg", "text");
                el.setAttributeNS(null, "x", -200);
                el.setAttributeNS(null, "y", -200);
                el.appendChild(document.createTextNode(text));

                if (opt.fontSize) {
                    el.setAttributeNS(null, "font-size", opt.fontSize);
                }

                if (opt.fontFamily) {
                    el.setAttributeNS(null, "font-family", opt.fontFamily);
                }

                if (opt.bold) {
                    el.setAttributeNS(null, "font-weight", opt.bold);
                }

                if (opt.style) {
                    el.setAttributeNS(null, "font-style", opt.style);
                }

                svg.appendChild(el);

                bodyElement.appendChild(svg);
                var rect = el.getBoundingClientRect();
                bodyElement.removeChild(svg);

                return { width: rect.width, height: rect.height };
            };

            init();
        };

        /**
         * @method create
         *
         * create nested elements by json
         *
         *      @example
         *      SVG.create({
        *          tag : "pattern",
        *          attr : { x : 0, y : 0, width : 20, height : 20  },
        *          children : [
        *              { tag : 'rect', attr : {width : 20, height : 20, fill : 'black', stroke : 'blue', 'stroke-width' : 2 } ,
        *              { tag : 'rect', attr : {width : 20, height : 20, fill : 'black', stroke : 'blue', 'stroke-width' : 2 } ,
        *              { tag : 'rect', attr : {width : 20, height : 20, fill : 'black', stroke : 'blue', 'stroke-width' : 2 } ,
        *              { tag : 'rect', attr : {width : 20, height : 20, fill : 'black', stroke : 'blue', 'stroke-width' : 2 }
        *          ]
        *      });
        *
        * is equals to
        *
         *      @example
         *      <pattern x="0" y="0" width="20" height="20">
         *          <rect width="20" height="20" fill="black" stroke="blue" stroke-width="2" />
         *          <rect width="20" height="20" fill="black" stroke="blue" stroke-width="2" />
         *          <rect width="20" height="20" fill="black" stroke="blue" stroke-width="2" />
         *          <rect width="20" height="20" fill="black" stroke="blue" stroke-width="2" />
         *      </pattern>
         *
         * @param {Object} obj json literal
         * @param {String} obj.type  svg element name
         * @param {Object} obj.attr  svg element's attributes
         * @param {Array} [obj.children=null] svg element's children
         * @static
         * @return {util.svg.element}
         *
         */
        SVG.createObject = function (obj) {
            var el = new Element();

            el.create(obj.type, obj.attr);

            if (obj.children instanceof Array) {
                for (var i = 0, len = obj.children.length; i < len; i++) {
                    el.append(SVG.createObject(obj.children[i]));
                }
            }

            return el;
        };

        return SVG;
    }
};

jui$1.use([math]);

var LinearScaleUtil = {
    name: "util.scale.linear",
    extend: null,
    component: function component() {
        var math$$1 = jui$1.include("util.math");

        var linear = function linear() {
            var _domain = [0, 1];
            var _range = [0, 1];
            var _isRound = false;
            var _isClamp = false;
            var _cache = {};

            var roundFunction = null;
            var numberFunction = null;

            var domainMin = null;
            var domainMax = null;

            var rangeMin = null;
            var rangeMax = null;

            var distDomain = null;
            var distRange = null;
            var rate = 0;

            var callFunction = null;
            var _rangeBand = null;

            function func(x) {
                if (domainMax < x) {
                    if (_isClamp) {
                        return func(domainMax);
                    }

                    return _range[0] + Math.abs(x - _domain[0]) * rate;
                } else if (domainMin > x) {
                    if (_isClamp) {
                        return func(domainMin);
                    }

                    return _range[0] - Math.abs(x - _domain[0]) * rate;
                } else {
                    var pos = (x - _domain[0]) / distDomain;

                    return callFunction(pos);
                }
            }

            func.cache = function () {
                return _cache;
            };

            /**
             * @method min
             * @static
             *
             * @returns {number}
             */
            func.min = function () {
                return Math.min.apply(Math, _domain);
            };

            func.max = function () {
                return Math.max.apply(Math, _domain);
            };

            func.rangeMin = function () {
                return Math.min.apply(Math, _range);
            };

            func.rangeMax = function () {
                return Math.max.apply(Math, _range);
            };

            func.rate = function (value, max) {
                return func(func.max() * (value / max));
            };

            func.clamp = function (isClamp) {
                _isClamp = isClamp || false;
            };

            func.domain = function (values) {

                if (!arguments.length) {
                    return _domain;
                }

                for (var i = 0; i < values.length; i++) {
                    _domain[i] = values[i];
                }

                domainMin = func.min();
                domainMax = func.max();

                distDomain = _domain[1] - _domain[0];

                return this;
            };

            func.range = function (values) {

                if (!arguments.length) {
                    return _range;
                }

                for (var i = 0; i < values.length; i++) {
                    _range[i] = values[i];
                }

                roundFunction = math$$1.interpolateRound(_range[0], _range[1]);
                numberFunction = math$$1.interpolateNumber(_range[0], _range[1]);

                rangeMin = func.rangeMin();
                rangeMax = func.rangeMax();

                distRange = Math.abs(rangeMax - rangeMin);

                rate = distRange / distDomain;

                callFunction = _isRound ? roundFunction : numberFunction;

                return this;
            };

            func.rangeRound = function (values) {
                _isRound = true;

                return func.range(values);
            };

            func.rangeBand = function () {
                return _rangeBand;
            };

            func.invert = function (y) {
                var f = linear().domain(_range).range(_domain);
                return f(y);
            };

            func.ticks = function (count, isNice, /** @deprecated */intNumber, reverse) {

                //intNumber = intNumber || 10000;
                reverse = reverse || false;
                var max = func.max();

                if (_domain[0] == 0 && _domain[1] == 0) {
                    return [];
                }

                var obj = math$$1.nice(_domain[0], _domain[1], count || 10, isNice || false);

                var arr = [];

                var start = reverse ? obj.max : obj.min;
                var end = reverse ? obj.min : obj.max;
                var unit = obj.spacing;
                var fixed = math$$1.fixed(unit);

                while (reverse ? end <= start : start <= end) {
                    arr.push(start /* / intNumber*/);

                    if (reverse) {
                        start = fixed.minus(start, unit);
                    } else {
                        start = fixed.plus(start, unit);
                    }
                }

                if (reverse) {
                    if (arr[0] != max) {
                        arr.unshift(max);
                    }

                    for (var i = 0, len = arr.length; i < len; i++) {
                        arr[i] = Math.abs(arr[i] - max);
                    }
                    //arr.reverse();
                } else {
                    if (arr[arr.length - 1] != end && start > end) {
                        arr.push(end);
                    }

                    if (_domain[0] > _domain[1]) {
                        arr.reverse();
                    }
                }

                var first = func(arr[0]);
                var second = func(arr[1]);

                _rangeBand = Math.abs(second - first);

                return arr;
            };

            return func;
        };

        return linear;
    }
};

var CircleScaleUtil = {
    name: "util.scale.circle",
    extend: null,
    component: function component() {
        var circle = function circle() {

            var _domain = [];
            var _range = [];
            var _rangeBand = 0;

            function func(t) {}

            /**
             * @method domain
             * @static
             *
             * @param values
             * @returns {*}
             */
            func.domain = function (values) {

                if (typeof values == 'undefined') {
                    return _domain;
                }

                for (var i = 0; i < values.length; i++) {
                    _domain[i] = values[i];
                }

                return this;
            };

            func.range = function (values) {

                if (typeof values == 'undefined') {
                    return _range;
                }

                for (var i = 0; i < values.length; i++) {
                    _range[i] = values[i];
                }

                return this;
            };

            func.rangePoints = function (interval, padding) {

                padding = padding || 0;

                var step = _domain.length;
                var unit = (interval[1] - interval[0] - padding) / step;

                var range = [];
                for (var i = 0; i < _domain.length; i++) {
                    if (i == 0) {
                        range[i] = interval[0] + padding / 2 + unit / 2;
                    } else {
                        range[i] = range[i - 1] + unit;
                    }
                }

                _range = range;
                _rangeBand = unit;

                return func;
            };

            func.rangeBands = function (interval, padding, outerPadding) {
                padding = padding || 0;
                outerPadding = outerPadding || 0;

                var count = _domain.length;
                var step = count - 1;
                var band = (interval[1] - interval[0]) / step;

                var range = [];
                for (var i = 0; i < _domain.length; i++) {
                    if (i == 0) {
                        range[i] = interval[0];
                    } else {
                        range[i] = band + range[i - 1];
                    }
                }

                _rangeBand = band;
                _range = range;

                return func;
            };

            func.rangeBand = function () {
                return _rangeBand;
            };

            return func;
        };

        return circle;
    }
};

var LogScaleUtil = {
    name: "util.scale.log",
    extend: null,
    component: function component() {
        var _ = jui$1.include("util.base");
        var linear = jui$1.include("util.scale.linear");

        var log = function log(base) {
            var _base = base || 10;

            var func = linear();
            var _domain = [];
            var _domainMax = null;
            var _domainMin = null;

            function log(value) {
                if (value < 0) {
                    return -(Math.log(Math.abs(value)) / Math.log(_base));
                } else if (value > 0) {
                    return Math.log(value) / Math.log(_base);
                }

                return 0;
            }

            function pow(value) {
                if (value < 0) {
                    return -Math.pow(_base, Math.abs(value));
                } else if (value > 0) {
                    return Math.pow(_base, value);
                }

                return 0;
            }

            function checkMax(value) {
                return Math.pow(_base, (value + "").length - 1) < value;
            }

            function getNextMax(value) {
                return Math.pow(_base, (value + "").length);
            }

            var newFunc = function newFunc(x) {
                var value = x;

                if (x > _domainMax) {
                    value = _domainMax;
                } else if (x < _domainMin) {
                    value = _domainMin;
                }

                return func(log(value));
            };

            _.extend(newFunc, func);

            newFunc.log = function () {
                var newDomain = [];
                for (var i = 0; i < _domain.length; i++) {
                    newDomain[i] = log(_domain[i]);
                }

                return newDomain;
            };

            newFunc.domain = function (values) {
                if (!arguments.length) {
                    return _domain;
                }

                for (var i = 0; i < values.length; i++) {
                    _domain[i] = values[i];
                }

                _domainMax = Math.max.apply(Math, _domain);
                _domainMin = Math.min.apply(Math, _domain);

                if (checkMax(_domainMax)) {
                    _domain[1] = _domainMax = getNextMax(_domainMax);
                }

                if (checkMax(Math.abs(_domainMin))) {

                    var value = getNextMax(Math.abs(_domainMin));
                    _domain[0] = _domainMin = _domainMin < 0 ? -value : value;
                }

                func.domain(newFunc.log());

                return newFunc;
            };

            newFunc.base = function (base) {
                func.domain(newFunc.log());

                return newFunc;
            };

            newFunc.invert = function (y) {
                return pow(func.invert(y));
            };

            newFunc.ticks = function (count, isNice, intNumber) {
                var arr = func.ticks(count, isNice, intNumber || 100000000000000000000, true);

                if (arr[arr.length - 1] < func.max()) {
                    arr.push(func.max());
                }

                var newArr = [];
                for (var i = 0, len = arr.length; i < len; i++) {
                    newArr[i] = pow(arr[i]);
                }

                return newArr;
            };

            return newFunc;
        };

        return log;
    }
};

var OrdinalScaleUtil = {
    name: "util.scale.ordinal",
    extend: null,
    component: function component() {
        var ordinal = function ordinal() {
            var _domain = [];
            var _range = [];
            var _rangeBand = 0;
            var _cache = {};
            var _isRangePoints = false;

            function func(t) {
                var key = "" + t;
                if (typeof _cache[key] != 'undefined') {
                    return _cache[key];
                }

                var index = -1;
                for (var i = 0; i < _domain.length; i++) {
                    if (typeof t == 'string' && _domain[i] === t) {
                        index = i;
                        break;
                    }
                }

                if (index > -1) {
                    _cache[key] = _range[index];
                    return _range[index];
                } else {
                    if (typeof _range[t] != 'undefined') {
                        //_domain[t] = t;               // FIXME: 이건 나중에 따로 연산해야할 듯
                        _cache[key] = _range[t];
                        return _range[t];
                    }

                    return null;
                }
            }

            /**
             * @method domain
             * @static
             *
             * @param values
             * @returns {*}
             */
            func.domain = function (values) {

                if (typeof values == 'undefined') {
                    return _domain;
                }

                for (var i = 0; i < values.length; i++) {
                    _domain[i] = values[i];
                }

                return this;
            };

            func.range = function (values) {
                if (typeof values == 'undefined') {
                    return _range;
                }

                for (var i = 0; i < values.length; i++) {
                    _range[i] = values[i];
                }

                return this;
            };

            func.rangePoints = function (interval, padding) {
                padding = padding || 0;

                var step = _domain.length;
                var unit = (interval[1] - interval[0] - padding) / step;

                var range = [];
                for (var i = 0; i < _domain.length; i++) {
                    if (i == 0) {
                        range[i] = interval[0] + padding / 2 + unit / 2;
                    } else {
                        range[i] = range[i - 1] + unit;
                    }
                }

                _range = range;
                _rangeBand = unit;
                _isRangePoints = true;

                return func;
            };

            func.rangeBands = function (interval, padding, outerPadding) {
                padding = padding || 0;
                outerPadding = outerPadding || 0;

                var count = _domain.length;
                var step = count - 1;
                var band = (interval[1] - interval[0]) / step;

                var range = [];
                for (var i = 0; i < _domain.length; i++) {
                    if (i == 0) {
                        range[i] = interval[0];
                    } else {
                        range[i] = band + range[i - 1];
                    }
                }

                _rangeBand = band;
                _range = range;
                _isRangePoints = false;

                return func;
            };

            func.rangeBand = function () {
                return _rangeBand;
            };

            func.invert = function (x) {
                var min = Math.min(_range[0], _range[1]);

                if (_isRangePoints) {
                    min -= _rangeBand / 2;

                    var tempX = x;
                    if (tempX < min) {
                        tempX = min;
                    }
                    var result = Math.abs(tempX - min) / _rangeBand;
                    return Math.floor(result);
                } else {
                    var result = Math.abs(x - min) / _rangeBand;
                    return Math.ceil(result);
                }
            };

            return func;
        };

        return ordinal;
    }
};

var TimeScaleUtil = {
    name: "util.scale.time",
    extend: null,
    component: function component() {
        var _time = jui$1.include("util.time");
        var linear = jui$1.include("util.scale.linear");

        var time = function time() {

            var _domain = [];
            var _rangeBand;
            var func = linear();
            var df = func.domain;

            func.domain = function (domain) {
                if (!arguments.length) return df.call(func);

                for (var i = 0; i < domain.length; i++) {
                    _domain[i] = +domain[i];
                }

                return df.call(func, _domain);
            };

            func.min = function () {
                return Math.min(_domain[0], _domain[_domain.length - 1]);
            };

            func.max = function () {
                return Math.max(_domain[0], _domain[_domain.length - 1]);
            };

            func.rate = function (value, max) {
                return func(func.max() * (value / max));
            };

            func.ticks = function (type, interval) {
                var start = _domain[0];
                var end = _domain[1];

                var times = [];
                while (start < end) {
                    times.push(new Date(+start));

                    start = _time.add(start, type, interval);
                }

                times.push(new Date(+start));

                var first = func(times[1]);
                var second = func(times[2]);

                _rangeBand = second - first;

                return times;
            };

            func.realTicks = function (type, interval) {
                var start = _domain[0];
                var end = _domain[1];

                var times = [];
                var date = new Date(+start);
                var realStart = null;

                if (type == _time.years) {
                    realStart = new Date(date.getFullYear(), 0, 1);
                } else if (type == _time.months) {
                    realStart = new Date(date.getFullYear(), date.getMonth(), 1);
                } else if (type == _time.days || type == _time.weeks) {
                    realStart = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                } else if (type == _time.hours) {
                    realStart = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), 0, 0, 0);
                } else if (type == _time.minutes) {
                    realStart = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), 0, 0);
                } else if (type == _time.seconds) {
                    realStart = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0);
                } else if (type == _time.milliseconds) {
                    realStart = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
                }
                realStart = _time.add(realStart, type, interval);

                while (+realStart < +end) {
                    times.push(new Date(+realStart));
                    realStart = _time.add(realStart, type, interval);
                }

                var first = func(times[1]);
                var second = func(times[2]);

                _rangeBand = second - first;

                return times;
            };

            func.rangeBand = function () {
                return _rangeBand;
            };

            func.invert = function (y) {
                var f = linear().domain(func.range()).range(func.domain());
                return new Date(f(y));
            };

            return func;
        };

        return time;
    }
};

jui$1.use([math, time]);

var scale = {
    name: "util.scale",
    extend: null,
    component: function component() {
        var math$$1 = jui$1.include("util.math");
        var _time = jui$1.include("util.time");

        var self = {

            /**
             * 원형 좌표에 대한 scale
             *
             */
            circle: function circle() {

                var _domain = [];
                var _range = [];
                var _rangeBand = 0;

                function func(t) {}

                func.domain = function (values) {

                    if (typeof values == 'undefined') {
                        return _domain;
                    }

                    for (var i = 0; i < values.length; i++) {
                        _domain[i] = values[i];
                    }

                    return this;
                };

                func.range = function (values) {

                    if (typeof values == 'undefined') {
                        return _range;
                    }

                    for (var i = 0; i < values.length; i++) {
                        _range[i] = values[i];
                    }

                    return this;
                };

                func.rangePoints = function (interval, padding) {

                    padding = padding || 0;

                    var step = _domain.length;
                    var unit = (interval[1] - interval[0] - padding) / step;

                    var range = [];
                    for (var i = 0; i < _domain.length; i++) {
                        if (i == 0) {
                            range[i] = interval[0] + padding / 2 + unit / 2;
                        } else {
                            range[i] = range[i - 1] + unit;
                        }
                    }

                    _range = range;
                    _rangeBand = unit;

                    return func;
                };

                func.rangeBands = function (interval, padding, outerPadding) {

                    padding = padding || 0;
                    outerPadding = outerPadding || 0;

                    var count = _domain.length;
                    var step = count - 1;
                    var band = (interval[1] - interval[0]) / step;

                    var range = [];
                    for (var i = 0; i < _domain.length; i++) {
                        if (i == 0) {
                            range[i] = interval[0];
                        } else {
                            range[i] = band + range[i - 1];
                        }
                    }

                    _rangeBand = band;
                    _range = range;

                    return func;
                };

                func.rangeBand = function () {
                    return _rangeBand;
                };

                return func;
            },

            /**
             *
             * 순서를 가지는 리스트에 대한 scale
             *
             */
            ordinal: function ordinal() {

                var _domain = [];
                var _range = [];
                var _rangeBand = 0;
                var _cache = {};

                function func(t) {

                    var key = "" + t;
                    if (typeof _cache[key] != 'undefined') {
                        return _cache[key];
                    }

                    var index = -1;
                    for (var i = 0; i < _domain.length; i++) {
                        if (typeof t == 'string' && _domain[i] === t) {
                            index = i;
                            break;
                        }
                    }

                    if (index > -1) {
                        _cache[key] = _range[index];
                        return _range[index];
                    } else {
                        if (typeof _range[t] != 'undefined') {
                            _domain[t] = t;
                            _cache[key] = _range[t];
                            return _range[t];
                        }

                        return null;
                    }
                }

                func.domain = function (values) {

                    if (typeof values == 'undefined') {
                        return _domain;
                    }

                    for (var i = 0; i < values.length; i++) {
                        _domain[i] = values[i];
                    }

                    return this;
                };

                func.range = function (values) {

                    if (typeof values == 'undefined') {
                        return _range;
                    }

                    for (var i = 0; i < values.length; i++) {
                        _range[i] = values[i];
                    }

                    return this;
                };

                func.rangePoints = function (interval, padding) {

                    padding = padding || 0;

                    var step = _domain.length;
                    var unit = (interval[1] - interval[0] - padding) / step;

                    var range = [];
                    for (var i = 0; i < _domain.length; i++) {
                        if (i == 0) {
                            range[i] = interval[0] + padding / 2 + unit / 2;
                        } else {
                            range[i] = range[i - 1] + unit;
                        }
                    }

                    _range = range;
                    _rangeBand = unit;

                    return func;
                };

                func.rangeBands = function (interval, padding, outerPadding) {

                    padding = padding || 0;
                    outerPadding = outerPadding || 0;

                    var count = _domain.length;
                    var step = count - 1;
                    var band = (interval[1] - interval[0]) / step;

                    var range = [];
                    for (var i = 0; i < _domain.length; i++) {
                        if (i == 0) {
                            range[i] = interval[0];
                        } else {
                            range[i] = band + range[i - 1];
                        }
                    }

                    _rangeBand = band;
                    _range = range;

                    return func;
                };

                func.rangeBand = function () {
                    return _rangeBand;
                };

                func.invert = function (x) {
                    return Math.ceil(x / _rangeBand);
                };

                return func;
            },

            /**
             * 시간에 대한 scale
             *
             */
            time: function time$$1() {

                var _domain = [];
                var _rangeBand;

                var func = self.linear();

                var df = func.domain;

                func.domain = function (domain) {

                    if (!arguments.length) return df.call(func);

                    for (var i = 0; i < domain.length; i++) {
                        _domain[i] = +domain[i];
                    }

                    return df.call(func, _domain);
                };

                func.min = function () {
                    return Math.min(_domain[0], _domain[_domain.length - 1]);
                };

                func.max = function () {
                    return Math.max(_domain[0], _domain[_domain.length - 1]);
                };

                func.rate = function (value, max) {
                    return func(func.max() * (value / max));
                };

                func.ticks = function (type, interval) {
                    var start = _domain[0];
                    var end = _domain[1];

                    var times = [];
                    while (start < end) {
                        times.push(new Date(+start));

                        start = _time.add(start, type, interval);
                    }

                    times.push(new Date(+start));

                    var first = func(times[1]);
                    var second = func(times[2]);

                    _rangeBand = second - first;

                    return times;
                };

                func.realTicks = function (type, interval) {
                    var start = _domain[0];
                    var end = _domain[1];

                    var times = [];
                    var date = new Date(+start);
                    var realStart = null;

                    if (type == _time.years) {
                        realStart = new Date(date.getFullYear(), 0, 1);
                    } else if (type == _time.months) {
                        realStart = new Date(date.getFullYear(), date.getMonth(), 1);
                    } else if (type == _time.days || type == _time.weeks) {
                        realStart = new Date(date.getFullYear(), date.getMonth(), date.getDate());
                    } else if (type == _time.hours) {
                        realStart = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), 0, 0, 0);
                    } else if (type == _time.minutes) {
                        realStart = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), 0, 0);
                    } else if (type == _time.seconds) {
                        realStart = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0);
                    } else if (type == _time.milliseconds) {
                        realStart = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
                    }
                    realStart = _time.add(realStart, type, interval);

                    while (+realStart < +end) {
                        times.push(new Date(+realStart));
                        realStart = _time.add(realStart, type, interval);
                    }

                    var first = func(times[1]);
                    var second = func(times[2]);

                    _rangeBand = second - first;

                    return times;
                };

                func.rangeBand = function () {
                    return _rangeBand;
                };

                func.invert = function (y) {
                    var f = self.linear().domain(func.range()).range(func.domain());

                    return new Date(f(y));
                };

                return func;
            },

            /**
             * log scale
             *
             * var log = _.scale.log(10).domain([0, 1000000]).range([0, 300]);
             *
             * log(0) == 0
             * log.ticks(4) == [0, 100, 10000, 1000000]
             *
             * @param base
             */
            log: function log(base) {

                var _base = base || 10;

                var func = self.linear();
                var _domain = [];
                var _domainMax = null;
                var _domainMin = null;

                function log(value) {

                    if (value < 0) {
                        return -(Math.log(Math.abs(value)) / Math.log(_base));
                    } else if (value > 0) {
                        return Math.log(value) / Math.log(_base);
                    }

                    return 0;
                }

                function pow(value) {
                    if (value < 0) {
                        return -Math.pow(_base, Math.abs(value));
                    } else if (value > 0) {
                        return Math.pow(_base, value);
                    }

                    return 0;
                }

                function checkMax(value) {
                    return Math.pow(_base, (value + "").length - 1) < value;
                }

                function getNextMax(value) {
                    return Math.pow(_base, (value + "").length);
                }

                var newFunc = function newFunc(x) {

                    var value = x;

                    if (x > _domainMax) {
                        value = _domainMax;
                    } else if (x < _domainMin) {
                        value = _domainMin;
                    }

                    return func(log(value));
                };

                $.extend(newFunc, func);

                newFunc.log = function () {
                    var newDomain = [];
                    for (var i = 0; i < _domain.length; i++) {
                        newDomain[i] = log(_domain[i]);
                    }

                    return newDomain;
                };

                newFunc.domain = function (values) {

                    if (!arguments.length) {
                        return _domain;
                    }

                    for (var i = 0; i < values.length; i++) {
                        _domain[i] = values[i];
                    }

                    _domainMax = Math.max.apply(Math, _domain);
                    _domainMin = Math.min.apply(Math, _domain);

                    if (checkMax(_domainMax)) {
                        _domain[1] = _domainMax = getNextMax(_domainMax);
                    }

                    if (checkMax(Math.abs(_domainMin))) {

                        var value = getNextMax(Math.abs(_domainMin));
                        _domain[0] = _domainMin = _domainMin < 0 ? -value : value;
                    }

                    func.domain(newFunc.log());

                    return newFunc;
                };

                newFunc.base = function (base) {
                    func.domain(newFunc.log());

                    return newFunc;
                };

                newFunc.invert = function (y) {
                    return pow(func.invert(y));
                };

                newFunc.ticks = function (count, isNice, intNumber) {

                    var arr = func.ticks(count, isNice, intNumber || 100000000000000000000, true);

                    if (arr[arr.length - 1] < func.max()) {
                        arr.push(func.max());
                    }

                    var newArr = [];
                    for (var i = 0, len = arr.length; i < len; i++) {
                        newArr[i] = pow(arr[i]);
                    }

                    return newArr;
                };

                return newFunc;
            },

            /**
             * 범위에 대한 scale
             *
             */
            linear: function linear() {

                var _domain = [0, 1];
                var _range = [0, 1];
                var _isRound = false;
                var _isClamp = false;
                var _cache = {};

                var roundFunction = null;
                var numberFunction = null;

                var domainMin = null;
                var domainMax = null;

                var rangeMin = null;
                var rangeMax = null;

                var distDomain = null;
                var distRange = null;
                var rate = 0;

                var callFunction = null;
                var _rangeBand = null;

                function func(x) {

                    if (domainMax < x) {
                        if (_isClamp) {
                            return func(domainMax);
                        }

                        return _range[0] + Math.abs(x - _domain[0]) * rate;
                    } else if (domainMin > x) {
                        if (_isClamp) {
                            return func(domainMin);
                        }

                        return _range[0] - Math.abs(x - _domain[0]) * rate;
                    } else {
                        var pos = (x - _domain[0]) / distDomain;

                        return callFunction(pos);
                    }
                }

                func.cache = function () {
                    return _cache;
                };

                func.min = function () {
                    return Math.min.apply(Math, _domain);
                };

                func.max = function () {
                    return Math.max.apply(Math, _domain);
                };

                func.rangeMin = function () {
                    return Math.min.apply(Math, _range);
                };

                func.rangeMax = function () {
                    return Math.max.apply(Math, _range);
                };

                func.rate = function (value, max) {
                    return func(func.max() * (value / max));
                };

                func.clamp = function (isClamp) {
                    _isClamp = isClamp || false;
                };

                func.domain = function (values) {

                    if (!arguments.length) {
                        return _domain;
                    }

                    for (var i = 0; i < values.length; i++) {
                        _domain[i] = values[i];
                    }

                    domainMin = func.min();
                    domainMax = func.max();

                    distDomain = _domain[1] - _domain[0];

                    return this;
                };

                func.range = function (values) {

                    if (!arguments.length) {
                        return _range;
                    }

                    for (var i = 0; i < values.length; i++) {
                        _range[i] = values[i];
                    }

                    roundFunction = math$$1.interpolateRound(_range[0], _range[1]);
                    numberFunction = math$$1.interpolateNumber(_range[0], _range[1]);

                    rangeMin = func.rangeMin();
                    rangeMax = func.rangeMax();

                    distRange = Math.abs(rangeMax - rangeMin);

                    rate = distRange / distDomain;

                    callFunction = _isRound ? roundFunction : numberFunction;

                    return this;
                };

                func.rangeRound = function (values) {
                    _isRound = true;

                    return func.range(values);
                };

                func.rangeBand = function () {
                    return _rangeBand;
                };

                func.invert = function (y) {

                    var f = self.linear().domain(_range).range(_domain);
                    return f(y);
                };

                func.ticks = function (count, isNice, /** @deprecated */intNumber, reverse) {

                    //intNumber = intNumber || 10000;
                    reverse = reverse || false;
                    var max = func.max();

                    if (_domain[0] == 0 && _domain[1] == 0) {
                        return [];
                    }

                    var obj = math$$1.nice(_domain[0], _domain[1], count || 10, isNice || false);

                    var arr = [];

                    var start = reverse ? obj.max : obj.min;
                    var end = reverse ? obj.min : obj.max;
                    var unit = obj.spacing;
                    var fixed = math$$1.fixed(unit);

                    while (reverse ? end <= start : start <= end) {
                        arr.push(start /* / intNumber*/);

                        if (reverse) {
                            start = fixed.minus(start, unit);
                        } else {
                            start = fixed.plus(start, unit);
                        }
                    }

                    if (reverse) {
                        if (arr[0] != max) {
                            arr.unshift(max);
                        }

                        for (var i = 0, len = arr.length; i < len; i++) {
                            arr[i] = Math.abs(arr[i] - max);
                        }
                        //arr.reverse();
                    } else {
                        if (arr[arr.length - 1] != end && start > end) {
                            arr.push(end);
                        }

                        if (_domain[0] > _domain[1]) {
                            arr.reverse();
                        }
                    }

                    var first = func(arr[0]);
                    var second = func(arr[1]);

                    _rangeBand = Math.abs(second - first);

                    return arr;
                };

                return func;
            }
        };

        return self;
    }
};

var vector = {
    name: "chart.vector",
    extend: null,
    component: function component() {
        var Vector = function Vector(x, y, z) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;

            this.add = function (numberOrVector) {
                if (numberOrVector instanceof Vector) {
                    return new Vector(this.x + numberOrVector.x, this.y + numberOrVector.y, this.z + numberOrVector.z);
                }

                return new Vector(this.x + numberOrVector, this.y + numberOrVector, this.z + numberOrVector);
            };

            this.subtract = function (numberOrVector) {
                if (numberOrVector instanceof Vector) {
                    return new Vector(this.x - numberOrVector.x, this.y - numberOrVector.y, this.z - numberOrVector.z);
                }

                return new Vector(this.x - numberOrVector, this.y - numberOrVector, this.z - numberOrVector);
            };

            this.multiply = function (numberOrVector) {
                if (numberOrVector instanceof Vector) {
                    return new Vector(this.x * numberOrVector.x, this.y * numberOrVector.y, this.z * numberOrVector.z);
                }

                return new Vector(this.x * numberOrVector, this.y * numberOrVector, this.z * numberOrVector);
            };

            this.dotProduct = function (vector) {
                var value = this.x * vector.x + this.y * vector.y + this.z * vector.z;
                return Math.acos(value / (this.getMagnitude() * vector.getMagnitude()));
            };

            this.crossProduct = function (vector) {
                return new Vector(this.y * vector.z - this.z * vector.y, this.z * vector.x - this.x * vector.z, this.x * vector.y - this.y * vector.x);
            };

            this.normalize = function () {
                var mag = this.getMagnitude();

                this.x /= mag;
                this.y /= mag;
                this.z /= mag;
            };

            this.getMagnitude = function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            };
        };

        return Vector;
    }
};

var draw = {
    name: "chart.draw",
    extend: null,
    component: function component() {
        var _ = jui$1.include("util.base");

        var Draw = function Draw() {

            /**
             * @method drawBefore
             *
             * run before draw object
             *
             */

            /**
             * @method draw
             *
             * draw object
             *
             * @return {Object}
             *
             */

            /**
             * @method drawAfter
             *
             * run after draw object
             */

            /**
             * @method drawAnimate
             *
             * implements animate code after draw object
             */

            /**
             * @method render
             *
             * 모든 Draw 객체는  render 함수를 통해서 그려진다.
             *
             */
            this.render = function () {
                if (!_.typeCheck("function", this.draw)) {
                    throw new Error("JUI_CRITICAL_ERR: 'draw' method must be implemented");
                }

                // Call drawBefore method
                if (_.typeCheck("function", this.drawBefore)) {
                    this.drawBefore();
                }

                // Call draw method (All)
                var obj = this.draw();

                // Call drawAnimate method
                if (_.typeCheck("function", this.drawAnimate)) {
                    var draw = this.grid || this.brush || this.widget || this.map;

                    if (draw.animate !== false) {
                        this.drawAnimate(obj);
                    }
                }

                // Call drawAfter method
                if (_.typeCheck("function", this.drawAfter)) {
                    this.drawAfter(obj);
                }

                return obj;
            };

            /**
             * @method format
             * Get a default format callback of draw object.
             *
             * @return {Function}
             */
            this.format = function () {
                var draw = this.grid || this.brush || this.widget,
                    callback = draw.format || this.chart.format;

                return callback.apply(this.chart, arguments);
            };

            /**
             * @method balloonPoints
             *
             * 말풍선 그리그 메소드
             *
             * @param {String} type
             * @param {Number} w
             * @param {Number} h
             * @param {Number} anchor
             * @return {String}
             */
            this.balloonPoints = function (type, w, h, anchor) {
                var points = [];

                if (type == "top") {
                    points.push([0, 0].join(","));
                    points.push([w, 0].join(","));
                    points.push([w, h].join(","));
                    points.push([w / 2 + anchor / 2, h].join(","));
                    points.push([w / 2, h + anchor].join(","));
                    points.push([w / 2 - anchor / 2, h].join(","));
                    points.push([0, h].join(","));
                    points.push([0, 0].join(","));
                } else if (type == "bottom") {
                    points.push([0, anchor].join(","));
                    points.push([w / 2 - anchor / 2, anchor].join(","));
                    points.push([w / 2, 0].join(","));
                    points.push([w / 2 + anchor / 2, anchor].join(","));
                    points.push([w, anchor].join(","));
                    points.push([w, anchor + h].join(","));
                    points.push([0, anchor + h].join(","));
                    points.push([0, anchor].join(","));
                } else if (type == "left") {
                    points.push([0, 0].join(","));
                    points.push([w, 0].join(","));
                    points.push([w, h / 2 - anchor / 2].join(","));
                    points.push([w + anchor, h / 2].join(","));
                    points.push([w, h / 2 + anchor / 2].join(","));
                    points.push([w, h].join(","));
                    points.push([0, h].join(","));
                    points.push([0, 0].join(","));
                } else if (type == "right") {
                    points.push([0, 0].join(","));
                    points.push([w, 0].join(","));
                    points.push([w, h].join(","));
                    points.push([0, h].join(","));
                    points.push([0, h / 2 + anchor / 2].join(","));
                    points.push([0 - anchor, h / 2].join(","));
                    points.push([0, h / 2 - anchor / 2].join(","));
                    points.push([0, 0].join(","));
                } else {
                    points.push([0, 0].join(","));
                    points.push([w, 0].join(","));
                    points.push([w, h].join(","));
                    points.push([0, h].join(","));
                    points.push([0, 0].join(","));
                }

                return points.join(" ");
            };

            /**
             * @method on
             *
             * chart.on() 을 쉽게 사용 할 수 있게 해주는 유틸리티 함수
             *
             * @param {String} type event name
             * @param {Function} callback
             * @return {*}
             */
            this.on = function (type, callback) {
                var self = this;

                return this.chart.on(type, function () {
                    if (_.startsWith(type, "axis.") && _.typeCheck("integer", self.axis.index)) {
                        var axis = self.chart.axis(self.axis.index),
                            e = arguments[0];

                        if (_.typeCheck("object", axis)) {
                            if (arguments[1] == self.axis.index) {
                                callback.apply(self, [e]);
                            }
                        }
                    } else {
                        callback.apply(self, arguments);
                    }
                }, "render");
            };

            this.calculate3d = function () {
                var w = this.axis.area("width"),
                    h = this.axis.area("height"),
                    x = this.axis.area("x"),
                    y = this.axis.area("y"),
                    d = this.axis.depth,
                    r = this.axis.degree,
                    p = this.axis.perspective,
                    list = arguments;

                if (!_.typeCheck("integer", r.x)) r.x = 0;
                if (!_.typeCheck("integer", r.y)) r.y = 0;
                if (!_.typeCheck("integer", r.z)) r.z = 0;

                for (var i = 0; i < list.length; i++) {
                    list[i].perspective = p;
                    list[i].rotate(Math.max(w, h, d), r, x + w / 2, y + h / 2, d / 2);
                }
            };
        };

        Draw.setup = function () {
            return {
                /** @cfg {String} [type=null] Specifies the type of a widget/brush/grid to be added.*/
                type: null,
                /** @cfg {Boolean} [animate=false] Run the animation effect.*/
                animate: false
            };
        };

        return Draw;
    }
};

var axis = {
    name: "chart.axis",
    extend: null,
    component: function component() {
        var _ = jui$1.include("util.base");

        var Axis = function Axis(chart, originAxis, cloneAxis) {
            var self = this,
                map = null;
            var _area = {},
                _padding = {},
                _clipId = "",
                _clipPath = null,
                _clipRectId = "",
                _clipRect = null;

            function calculatePanel(a, padding) {
                a.x = getRate(a.x, chart.area('width'));
                a.y = getRate(a.y, chart.area('height'));
                a.width = getRate(a.width, chart.area('width'));
                a.height = getRate(a.height, chart.area('height'));

                a.x2 = a.x + a.width;
                a.y2 = a.y + a.height;

                // 패딩 개념 추가
                a.x += padding.left || 0;
                a.y += padding.top || 0;

                a.x2 -= padding.right || 0;
                a.y2 -= padding.bottom || 0;

                a.width = a.x2 - a.x;
                a.height = a.y2 - a.y;

                return a;
            }

            function getRate(value, max) {
                if (_.typeCheck("string", value) && value.indexOf("%") > -1) {
                    return max * (parseFloat(value.replace("%", "")) / 100);
                }

                return value;
            }

            function drawGridType(axis, k) {
                if ((k == "x" || k == "y" || k == "z") && !_.typeCheck("object", axis[k])) return null;

                // 축 위치 설정
                axis[k] = axis[k] || {};

                if (k == "x") {
                    axis[k].orient = axis[k].orient == "top" ? "top" : "bottom";
                } else if (k == "y") {
                    axis[k].orient = axis[k].orient == "right" ? "right" : "left";
                } else if (k == "z") {
                    axis[k].orient = "center";
                } else if (k == "c") {
                    axis[k].type = axis[k].type || "panel";
                    axis[k].orient = "custom";
                }

                axis[k].type = axis[k].type || "block";
                var Grid = jui$1.include("chart.grid." + axis[k].type);

                // 그리드 기본 옵션과 사용자 옵션을 합침
                jui$1.defineOptions(Grid, axis[k]);

                // 엑시스 기본 프로퍼티 정의
                var obj = new Grid(chart, axis, axis[k]);
                obj.chart = chart;
                obj.axis = axis;
                obj.grid = axis[k];
                obj.svg = chart.svg;

                var elem = obj.render();

                // 그리드 별 위치 선정하기 (z축이 없을 때)
                if (!self.isFull3D()) {
                    if (axis[k].orient == "left") {
                        elem.root.translate(chart.area("x") + self.area("x") - axis[k].dist, chart.area("y"));
                    } else if (axis[k].orient == "right") {
                        elem.root.translate(chart.area("x") + self.area("x2") + axis[k].dist, chart.area("y"));
                    } else if (axis[k].orient == "bottom") {
                        elem.root.translate(chart.area("x"), chart.area("y") + self.area("y2") + axis[k].dist);
                    } else if (axis[k].orient == "top") {
                        elem.root.translate(chart.area("x"), chart.area("y") + self.area("y") - axis[k].dist);
                    } else {
                        if (elem.root) elem.root.translate(chart.area("x") + self.area("x"), chart.area("y") + self.area("y"));
                    }
                }

                elem.scale.type = axis[k].type;
                elem.scale.root = elem.root;

                return elem.scale;
            }

            function drawMapType(axis, k) {
                if (k == "map" && !_.typeCheck("object", axis[k])) return null;

                // 축 위치 설정
                axis[k] = axis[k] || {};

                var Map = jui$1.include("chart.map");

                // 맵 기본 옵션과 사용자 옵션을 합침
                jui$1.defineOptions(Map, axis[k]);

                // 맵 객체는 한번만 생성함
                if (map == null) {
                    map = new Map(chart, axis, axis[k]);
                }

                // 맵 기본 프로퍼티 설정
                map.chart = chart;
                map.axis = axis;
                map.map = axis[k];
                map.svg = chart.svg;

                // 그리드 별 위치 선정하기
                var elem = map.render();
                elem.root.translate(chart.area("x") + self.area("x"), chart.area("y") + self.area("y"));
                elem.scale.type = axis[k].type;
                elem.scale.root = elem.root;

                return elem.scale;
            }

            function setScreen(pNo) {
                var dataList = self.origin,
                    limit = self.buffer,
                    maxPage = Math.ceil(dataList.length / limit);

                // 최소 & 최대 페이지 설정
                if (pNo < 1) {
                    self.page = 1;
                } else {
                    self.page = pNo > maxPage ? maxPage : pNo;
                }

                self.start = (self.page - 1) * limit, self.end = self.start + limit;

                // 마지막 페이지 처리
                if (self.end > dataList.length) {
                    self.start = dataList.length - limit;
                    self.end = dataList.length;
                }

                if (self.end <= dataList.length) {
                    self.start = self.start < 0 ? 0 : self.start;
                    self.data = dataList.slice(self.start, self.end);

                    if (dataList.length > 0) self.page++;
                }
            }

            function setZoom(start, end) {
                var dataList = self.origin;

                self.end = end > dataList.length ? dataList.length : end;
                self.start = start < 0 ? 0 : start;
                self.data = dataList.slice(self.start, self.end);
            }

            function createClipPath() {
                // clippath with x, y
                if (_clipPath) {
                    _clipPath.remove();
                    _clipPath = null;
                }

                // _clipId = _.createId("clip-id-");
                _clipId = "axis-clip-id-" + chart.index + "." + cloneAxis.index;

                _clipPath = chart.svg.clipPath({
                    id: _clipId
                }, function () {
                    chart.svg.rect({
                        x: _area.x,
                        y: _area.y,
                        width: _area.width,
                        height: _area.height
                    });
                });
                chart.appendDefs(_clipPath);

                // clippath without x, y
                if (_clipRect) {
                    _clipRect.remove();
                    _clipRect = null;
                }

                // _clipRectId = _.createId("clip-rect-id-");
                _clipRectId = "axis-clip-rect-id-" + chart.index;

                _clipRect = chart.svg.clipPath({
                    id: _clipRectId
                }, function () {
                    chart.svg.rect({
                        x: 0,
                        y: 0,
                        width: _area.width,
                        height: _area.height
                    });
                });

                chart.appendDefs(_clipRect);
            }

            function checkAxisPoint(e) {
                var top = self.area("y"),
                    left = self.area("x");

                if (e.chartY > top && e.chartY < top + self.area("height") && e.chartX > left && e.chartX < left + self.area("width")) {

                    e.axisX = e.chartX - left;
                    e.axisY = e.chartY - top;

                    return true;
                }

                return false;
            }

            function setAxisMouseEvent() {
                var isMouseOver = false,
                    index = cloneAxis.index;

                chart.on("chart.mousemove", function (e) {
                    if (checkAxisPoint(e)) {
                        if (!isMouseOver) {
                            chart.emit("axis.mouseover", [e, index]);
                            isMouseOver = true;
                        }
                    } else {
                        if (isMouseOver) {
                            chart.emit("axis.mouseout", [e, index]);
                            isMouseOver = false;
                        }
                    }

                    if (checkAxisPoint(e)) {
                        chart.emit("axis.mousemove", [e, index]);
                    }
                });

                chart.on("bg.mousemove", function (e) {
                    if (!checkAxisPoint(e) && isMouseOver) {
                        chart.emit("axis.mouseout", [e, index]);
                        isMouseOver = false;
                    }
                });

                chart.on("chart.mousedown", function (e) {
                    if (!checkAxisPoint(e)) return;
                    chart.emit("axis.mousedown", [e, index]);
                });

                chart.on("chart.mouseup", function (e) {
                    if (!checkAxisPoint(e)) return;
                    chart.emit("axis.mouseup", [e, index]);
                });

                chart.on("chart.click", function (e) {
                    if (!checkAxisPoint(e)) return;
                    chart.emit("axis.click", [e, index]);
                });

                chart.on("chart.dblclick", function (e) {
                    if (!checkAxisPoint(e)) return;
                    chart.emit("axis.dblclick", [e, index]);
                });

                chart.on("chart.rclick", function (e) {
                    if (!checkAxisPoint(e)) return;
                    chart.emit("axis.rclick", [e, index]);
                });

                chart.on("chart.mousewheel", function (e) {
                    if (!checkAxisPoint(e)) return;
                    chart.emit("axis.mousewheel", [e, index]);
                });
            }

            function drawAxisBackground() {
                var bw = chart.theme("axisBorderWidth"),
                    lr = _padding.left + _padding.right,
                    tb = _padding.top + _padding.bottom;

                var bg = chart.svg.rect({
                    rx: chart.theme("axisBorderRadius"),
                    ry: chart.theme("axisBorderRadius"),
                    fill: chart.theme("axisBackgroundColor"),
                    "fill-opacity": chart.theme("axisBackgroundOpacity"),
                    stroke: chart.theme("axisBorderColor"),
                    "stroke-width": bw,
                    width: _area.width + lr - bw,
                    height: _area.height + tb - bw,
                    x: _area.x - _padding.left,
                    y: _area.y - _padding.top
                });

                bg.translate(chart.area("x"), chart.area("y"));

                return bg;
            }

            function init() {
                _.extend(self, {
                    data: cloneAxis.data,
                    origin: cloneAxis.origin,
                    buffer: cloneAxis.buffer,
                    shift: cloneAxis.shift,
                    index: cloneAxis.index,
                    page: cloneAxis.page,
                    start: cloneAxis.start,
                    end: cloneAxis.end,
                    degree: cloneAxis.degree,
                    depth: cloneAxis.depth,
                    perspective: cloneAxis.perspective
                });

                // 원본 데이터 설정
                self.origin = self.data;

                // 페이지 초기화
                if (self.start > 0 || self.end > 0) {
                    setZoom(self.start, self.end);
                } else {
                    setScreen(self.page);
                }

                // 엑시스 이벤트 설정
                setAxisMouseEvent();

                // Grid 및 Area 설정
                self.reload(cloneAxis);
            }

            /**
             * @method getValue
             *
             * 특정 필드의 값을 맵핑해서 가지고 온다.
             *
             * @param {Object} data row data
             * @param {String} fieldString 필드 이름
             * @param {String/Number/Boolean/Object} [defaultValue=''] 기본값
             * @return {Mixed}
             */
            this.getValue = function (data, fieldString, defaultValue) {
                var value = data[cloneAxis.keymap[fieldString]];
                if (!_.typeCheck("undefined", value)) {
                    return value;
                }

                value = data[fieldString];
                if (!_.typeCheck("undefined", value)) {
                    return value;
                }

                return defaultValue;
            };

            /**
             * @method reload
             *
             * Axis 의 x,y,z 축을 다시 생성한다.
             * * *
             * @param {Object} options
             */
            this.reload = function (options) {
                var area = chart.area();

                _.extend(this, {
                    x: options.x,
                    y: options.y,
                    z: options.z,
                    c: options.c,
                    map: options.map
                });

                // 패딩 옵션 설정
                if (_.typeCheck("integer", options.padding)) {
                    _padding = { left: options.padding, right: options.padding, bottom: options.padding, top: options.padding };
                } else {
                    _padding = options.padding;
                }

                _area = calculatePanel(_.extend(options.area, {
                    x: 0, y: 0, width: area.width, height: area.height
                }, true), _padding);

                // 클립 패스 설정
                createClipPath();

                this.root = drawAxisBackground();
                this.x = drawGridType(this, "x");
                this.y = drawGridType(this, "y");
                this.z = drawGridType(this, "z");
                this.c = drawGridType(this, "c");
                this.map = drawMapType(this, "map");

                this.buffer = options.buffer;
                this.shift = options.shift;
                this.index = options.index;
                this.page = options.page;
                this.start = options.start;
                this.end = options.end;
                this.degree = options.degree;
                this.depth = options.depth;
                this.perspective = options.perspective;
            };

            /**
             * @method area
             *
             * Axis 의 표시 영역을 리턴한다.
             *
             * @param {"x"/"y"/"width"/'height"/null} key  area's key
             * @return {Number/Object} key 가 있으면 해당 key 의 value 를 리턴한다. 없으면 전체 area 객체를 리턴한다.
             */
            this.area = function (key) {
                return _.typeCheck("undefined", _area[key]) ? _area : _area[key];
            };

            /**
             * Gets the top, bottom, left and right margin values.
             *
             * @param {"top"/"left"/"bottom"/"right"} key
             * @return {Number/Object}
             */
            this.padding = function (key) {
                return _.typeCheck("undefined", _padding[key]) ? _padding : _padding[key];
            };

            /**
             * @method get
             *
             * Axis 의 옵션 정보를 리턴한다.
             *
             * @param key
             */
            this.get = function (type) {
                var obj = {
                    area: _area,
                    padding: _padding,
                    clipId: _clipId,
                    clipRectId: _clipRectId
                };

                return obj[type] || cloneAxis[type];
            };

            /**
             * @method set
             *
             * axis의 주요 프로퍼티를 업데이트한다.
             *
             * @param {"x"/"y"/"c"/"map"/"degree"/"padding"} type
             * @param {Object} grid
             */
            this.set = function (type, value, isReset) {
                if (_.typeCheck("object", value)) {
                    if (isReset === true) {
                        originAxis[type] = _.deepClone(value);
                        cloneAxis[type] = _.deepClone(value);
                    } else {
                        _.extend(originAxis[type], value);
                        _.extend(cloneAxis[type], value);
                    }
                } else {
                    originAxis[type] = value;
                    cloneAxis[type] = value;
                }

                if (chart.isRender()) chart.render();
            };

            /**
             * @deprecated
             * @method updateGrid
             *
             * grid 정보를 업데이트 한다.
             *
             * @param {"x"/"y"/"c"/"map"} type
             * @param {Object} grid
             */
            this.updateGrid = this.set;

            /**
             * @method update
             *
             * data 를 업데이트 한다.
             *
             * @param {Array} data
             */
            this.update = function (data) {
                this.origin = _.typeCheck("array", data) ? data : [data];
                this.page = 1;
                this.start = 0;
                this.end = 0;

                this.screen(1);
            };

            /**
             * @method screen
             *
             * 화면상에 보여줄 데이타를 페이징한다.
             *
             * @param {Number} pNo 페이지 번호
             */
            this.screen = function (pNo) {
                setScreen(pNo);

                if (this.end <= this.origin.length) {
                    if (chart.isRender()) chart.render();
                }
            };

            /**
             * @method next
             *
             */
            this.next = function () {
                var dataList = this.origin,
                    limit = this.buffer,
                    step = this.shift;

                this.start += step;

                var isLimit = this.start + limit > dataList.length;

                this.end = isLimit ? dataList.length : this.start + limit;
                this.start = isLimit ? dataList.length - limit : this.start;
                this.start = this.start < 0 ? 0 : this.start;
                this.data = dataList.slice(this.start, this.end);

                if (chart.isRender()) chart.render();
            };

            /**
             * @method prev
             */
            this.prev = function () {
                var dataList = this.origin,
                    limit = this.buffer,
                    step = this.shift;

                this.start -= step;

                var isLimit = this.start < 0;

                this.end = isLimit ? limit : this.start + limit;
                this.start = isLimit ? 0 : this.start;
                this.data = dataList.slice(this.start, this.end);

                if (chart.isRender()) chart.render();
            };

            /**
             * @method zoom
             *
             * 특정 인덱스의 영역으로 데이타를 다시 맞춘다.
             *
             * @param {Number} start
             * @param {Number} end
             */
            this.zoom = function (start, end) {
                if (start == end) return;

                setZoom(start, end);
                if (chart.isRender()) chart.render();
            };

            this.isFull3D = function () {
                return !_.typeCheck(["undefined", "null"], this.z);
            };

            init();
        };

        Axis.setup = function () {

            /** @property {chart.grid.core} [x=null] Sets a grid on the X axis (see the grid tab). */
            /** @property {chart.grid.core} [y=null] Sets a grid on the Y axis (see the grid tab). */
            /** @property {chart.grid.core} [c=null] Sets a custom grid (see the grid tab). */
            /** @property {chart.map} [map=null] Sets a chart map. */
            /** @property {Array} [data=[]] Sets the row set data which constitute a chart. */
            /** @property {Integer} [buffer=10000] Limits the number of elements shown on a chart. */
            /** @property {Integer} [shift=1] Data shift count for the 'prev' or 'next' method of the chart builder. */
            /** @property {Array} [origin=[]] [For read only] Original data initially set. */
            /** @property {Integer} [page=1] [For read only] Page number of the data currently drawn. */
            /** @property {Integer} [start=0] [For read only] Start index of the data currently drawn. */
            /** @property {Integer} [end=0] [For read only] End index of the data currently drawn. */

            return {
                /** @cfg {Integer} [extend=null]  Configures the index of an applicable grid group when intending to use already configured axis options. */
                extend: null,

                /** @cfg {chart.grid.core} [x=null] Sets a grid on the X axis (see the grid tab). */
                x: null,
                /** @cfg {chart.grid.core} [y=null]  Sets a grid on the Y axis (see the grid tab). */
                y: null,
                /** @cfg {chart.grid.core} [z=null] Sets a grid on the Z axis (see the grid tab). */
                z: null,
                /** @cfg {chart.grid.core} [c=null] Sets a grid on the C axis (see the grid tab). */
                c: null,
                /** @cfg {chart.map.core} [map=null] Sets a map on the Map axis */
                map: null,
                /** @cfg {Array} [data=[]]  Sets the row set data which constitute a chart.  */
                data: [],
                /** @cfg {Array} [origin=[]]  [Fore read only] Original data initially set. */
                origin: [],
                /** @cfg {Object} [keymap={}] grid's data key map  */
                keymap: {},
                /** @cfg {Object} [area={}]  set area(x, y, width, height) of axis */
                area: {},
                /**
                 * @cfg  {Object} padding axis padding
                 * @cfg  {Number} [padding.top=0] axis's top padding
                 * @cfg  {Number} [padding.bottom=0] axis's bottom padding
                 * @cfg  {Number} [padding.left=0] axis's left padding
                 * @cfg  {Number} [padding.right=0] axis's right padding
                 */
                padding: {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0
                },
                /** @cfg {Number} [buffer=10000] Limits the number of elements shown on a chart.  */
                buffer: 10000,
                /** @cfg {Number} [shift=1]  Data shift count for the 'prev' or 'next' method of the chart builder.  */
                shift: 1,

                /** @cfg {Number} [page=1]  Page number of the data currently drawn. */
                page: 1,
                /** @cfg {Number} [start=0] */
                start: 0,
                /** @cfg {Number} [end=0] */
                end: 0,
                /**
                 * @cfg  {Object} Set degree of 3d chart
                 * @cfg  {Number} [degree.x=0] axis's x-degree
                 * @cfg  {Number} [degree.y=0] axis's y-degree
                 * @cfg  {Number} [degree.z=0] axis's z-degree
                 */
                degree: {
                    x: 0,
                    y: 0,
                    z: 0
                },
                /** @cfg {Number} [depth=0]  Set depth of 3d chart  */
                depth: 0,
                /** @cfg {Number} [perspective=0.9]  Set perspective values in the 3d chart  */
                perspective: 0.9
            };
        };

        return Axis;
    }
};

jui$1.use([dom, svg]);

var Map = {
    name: "chart.map",
    extend: null,
    component: function component() {
        var _ = jui$1.include("util.base");
        var $ = jui$1.include("util.dom");
        var SVG = jui$1.include("util.svg");

        var Map = function Map() {
            var self = this;
            var pathData = {},
                pathGroup = null,
                pathIndex = {},
                pathScale = 1,
                pathX = 0,
                pathY = 0;

            function loadArray(data) {
                var children = [];

                for (var i = 0, len = data.length; i < len; i++) {
                    if (_.typeCheck("object", data[i])) {
                        var style = {};

                        if (_.typeCheck("string", data[i].style)) {
                            style = getStyleObj(data[i].style);
                            delete data[i].style;
                        }

                        var elem = SVG.createObject({
                            type: data[i].d != null ? "path" : "polygon",
                            attr: data[i]
                        });

                        // Set styles
                        elem.attr(_.extend(style, {
                            fill: self.chart.theme("mapPathBackgroundColor"),
                            "fill-opacity": self.chart.theme("mapPathBackgroundOpacity"),
                            stroke: self.chart.theme("mapPathBorderColor"),
                            "stroke-width": self.chart.theme("mapPathBorderWidth"),
                            "stroke-opacity": self.chart.theme("mapPathBorderOpacity")
                        }));

                        children.push({
                            path: elem,
                            data: data[i]
                        });
                    }
                }

                function getStyleObj(str) {
                    var style = {},
                        list = str.split(";");

                    for (var i = 0; i < list.length; i++) {
                        if (list[i].indexOf(":") != -1) {
                            var obj = list[i].split(":");

                            style[_.trim(obj[0])] = _.trim(obj[1]);
                        }
                    }

                    return style;
                }

                return children;
            }

            function getPathList(root) {
                if (!_.typeCheck("string", root.id)) return;

                var pathData = [],
                    children = root.childNodes;

                for (var i = 0, len = children.length; i < len; i++) {
                    var elem = children[i],
                        name = elem.nodeName.toLowerCase();

                    if (elem.nodeType != 1) continue;

                    if (name == "g") {
                        pathData = pathData.concat(getPathList(elem));
                    } else if (name == "path" || name == "polygon") {
                        var obj = { group: root.id };

                        for (var key in elem.attributes) {
                            var attr = elem.attributes[key];

                            if (attr.specified && isLoadAttribute(attr.name)) {
                                obj[attr.name] = replaceXYValue(attr);
                            }
                        }

                        if (_.typeCheck("string", obj.id)) {
                            _.extend(obj, getDataById(obj.id));
                        }

                        pathData.push(obj);
                    }
                }

                return pathData;
            }

            function loadPath(uri) {
                // 해당 URI의 데이터가 존재할 경우
                if (_.typeCheck("array", pathData[uri])) {
                    return loadArray(pathData[uri]);
                }

                // 해당 URI의 데이터가 없을 경우
                pathData[uri] = [];

                _.ajax({
                    url: uri,
                    async: false,
                    success: function success(xhr) {
                        var xml = xhr.responseXML,
                            svg$$1 = xml.getElementsByTagName("svg"),
                            style = xml.getElementsByTagName("style");

                        if (svg$$1.length != 1) return;
                        var children = svg$$1[0].childNodes;

                        for (var i = 0, len = children.length; i < len; i++) {
                            var elem = children[i],
                                name = elem.nodeName.toLowerCase();

                            if (elem.nodeType != 1) continue;

                            if (name == "g") {
                                pathData[uri] = pathData[uri].concat(getPathList(elem));
                            } else if (name == "path" || name == "polygon") {
                                var obj = {};

                                for (var key in elem.attributes) {
                                    var attr = elem.attributes[key];

                                    if (attr.specified && isLoadAttribute(attr.name)) {
                                        obj[attr.name] = replaceXYValue(attr);
                                    }
                                }

                                if (_.typeCheck("string", obj.id)) {
                                    _.extend(obj, getDataById(obj.id));
                                }

                                pathData[uri].push(obj);
                            }
                        }

                        // 스타일 태그가 정의되어 있을 경우
                        for (var i = 0; i < style.length; i++) {
                            self.svg.root.element.appendChild(style[i]);
                        }
                    },
                    fail: function fail(xhr) {
                        throw new Error("JUI_CRITICAL_ERR: Failed to load resource");
                    }
                });

                return loadArray(pathData[uri]);
            }

            function isLoadAttribute(name) {
                return name == "group" || name == "id" || name == "title" || name == "x" || name == "y" || name == "d" || name == "points" || name == "class" || name == "style";
            }

            function replaceXYValue(attr) {
                if (attr.name == "x" || attr.name == "y") {
                    return parseFloat(attr.value);
                }

                return attr.value;
            }

            function getDataById(id) {
                var list = self.axis.data;

                for (var i = 0; i < list.length; i++) {
                    var dataId = self.axis.getValue(list[i], "id", null);

                    if (dataId == id) {
                        return list[i];
                    }
                }

                return null;
            }

            function makePathGroup() {
                var group = self.chart.svg.group(),
                    list = loadPath(self.map.path);

                for (var i = 0, len = list.length; i < len; i++) {
                    var path = list[i].path,
                        data = list[i].data;

                    //addEvent(path, list[i]);
                    group.append(path);

                    if (_.typeCheck("string", data.id)) {
                        pathIndex[data.id] = list[i];
                    }
                }

                return group;
            }

            function getScaleXY() {
                // 차후에 공통 함수로 변경해야 함
                var w = self.map.width,
                    h = self.map.height,
                    px = (w * pathScale - w) / 2,
                    py = (h * pathScale - h) / 2;

                return {
                    x: px + pathX,
                    y: py + pathY
                };
            }

            function addEvent(elem, obj) {
                var chart = self.chart;

                elem.on("click", function (e) {
                    setMouseEvent(e);
                    chart.emit("map.click", [obj, e]);
                });

                elem.on("dblclick", function (e) {
                    setMouseEvent(e);
                    chart.emit("map.dblclick", [obj, e]);
                });

                elem.on("contextmenu", function (e) {
                    setMouseEvent(e);
                    chart.emit("map.rclick", [obj, e]);
                    e.preventDefault();
                });

                elem.on("mouseover", function (e) {
                    setMouseEvent(e);
                    chart.emit("map.mouseover", [obj, e]);
                });

                elem.on("mouseout", function (e) {
                    setMouseEvent(e);
                    chart.emit("map.mouseout", [obj, e]);
                });

                elem.on("mousemove", function (e) {
                    setMouseEvent(e);
                    chart.emit("map.mousemove", [obj, e]);
                });

                elem.on("mousedown", function (e) {
                    setMouseEvent(e);
                    chart.emit("map.mousedown", [obj, e]);
                });

                elem.on("mouseup", function (e) {
                    setMouseEvent(e);
                    chart.emit("map.mouseup", [obj, e]);
                });

                function setMouseEvent(e) {
                    var pos = $.offset(chart.root),
                        offsetX = e.pageX - pos.left,
                        offsetY = e.pageY - pos.top;

                    e.bgX = offsetX;
                    e.bgY = offsetY;
                    e.chartX = offsetX - chart.padding("left");
                    e.chartY = offsetY - chart.padding("top");
                }
            }

            this.scale = function (id) {
                if (!_.typeCheck("string", id)) return;

                var x = null,
                    y = null,
                    path = null,
                    data = null,
                    pxy = getScaleXY();

                if (_.typeCheck("object", pathIndex[id])) {
                    path = pathIndex[id].path;
                    data = pathIndex[id].data;

                    if (data.x != null) {
                        var dx = self.axis.getValue(data, "dx", 0),
                            cx = parseFloat(data.x) + dx;
                        x = cx * pathScale - pxy.x;
                    }

                    if (data.y != null) {
                        var dy = self.axis.getValue(data, "dy", 0),
                            cy = parseFloat(data.y) + dy;
                        y = cy * pathScale - pxy.y;
                    }
                }

                return {
                    x: x,
                    y: y,
                    path: path,
                    data: data
                };
            };

            this.scale.each = function (callback) {
                var self = this;

                for (var id in pathIndex) {
                    callback.apply(self, [id, pathIndex[id]]);
                }
            };

            this.scale.size = function () {
                return {
                    width: self.map.width,
                    height: self.map.height
                };
            };

            this.scale.scale = function (scale) {
                if (!scale || scale < 0) return pathScale;

                pathScale = scale;
                pathGroup.scale(pathScale);
                this.view(pathX, pathY);

                return pathScale;
            };

            this.scale.view = function (x, y) {
                var xy = { x: pathX, y: pathY };

                if (!_.typeCheck("number", x) || !_.typeCheck("number", y)) return xy;

                pathX = x;
                pathY = y;

                var pxy = getScaleXY();
                pathGroup.translate(-pxy.x, -pxy.y);

                return {
                    x: pathX,
                    y: pathY
                };
            };

            this.draw = function () {
                var root = this.chart.svg.group();

                pathScale = this.map.scale;
                pathX = this.map.viewX;
                pathY = this.map.viewY;
                pathGroup = makePathGroup();

                // pathGroup 루트에 추가
                root.append(pathGroup);

                if (this.map.scale != 1) {
                    this.scale.scale(pathScale);
                }

                if (this.map.viewX != 0 || this.map.viewY != 0) {
                    this.scale.view(pathX, pathY);
                }

                if (this.map.hide) {
                    root.attr({ visibility: "hidden" });
                }

                return {
                    root: root,
                    scale: this.scale
                };
            };

            this.drawAfter = function (obj) {
                obj.root.attr({ "clip-path": "url(#" + this.axis.get("clipRectId") + ")" });

                // 모든 path가 그려진 이후에 이벤트 설정
                setTimeout(function () {
                    self.scale.each(function (id, obj) {
                        addEvent(obj.path, obj);
                    });
                }, 1);
            };
        };

        Map.setup = function () {
            /** @property {chart.builder} chart */
            /** @property {chart.axis} axis */
            /** @property {Object} map */

            return {
                scale: 1,
                viewX: 0,
                viewY: 0,

                /** @cfg {Boolean} [hide=false] Determines whether to display an applicable grid.  */
                hide: false,
                /** @cfg {String} [map=''] Set a map file's name */
                path: "",
                /** @cfg {Number} [width=-1] Set map's width */
                width: -1,
                /** @cfg {Number} [height=-1] Set map's height */
                height: -1
            };
        };

        /**
         * @event map_click
         * Event that occurs when clicking on the map area. (real name ``` map.click ```)
         * @param {jQueryEvent} e The event object.
         * @param {Number} index Axis index.
         */
        /**
         * @event map_dblclick
         * Event that occurs when double clicking on the map area. (real name ``` map.dblclick ```)
         * @param {jQueryEvent} e The event object.
         * @param {Number} index Axis index.
         */
        /**
         * @event map_rclick
         * Event that occurs when right clicking on the map area. (real name ``` map.rclick ```)
         * @param {jQueryEvent} e The event object.
         * @param {Number} index Axis index.
         */
        /**
         * @event map_mouseover
         * Event that occurs when placing the mouse over the map area. (real name ``` map.mouseover ```)
         * @param {jQueryEvent} e The event object.
         * @param {Number} index Axis index.
         */
        /**
         * @event map_mouseout
         * Event that occurs when moving the mouse out of the map area. (real name ``` map.mouseout ```)
         * @param {jQueryEvent} e The event object.
         * @param {Number} index Axis index.
         */
        /**
         * @event map_mousemove
         * Event that occurs when moving the mouse over the map area. (real name ``` map.mousemove ```)
         * @param {jQueryEvent} e The event object.
         * @param {Number} index Axis index.
         */
        /**
         * @event map_mousedown
         * Event that occurs when left clicking on the map area. (real name ``` map.mousedown ```)
         * @param {jQueryEvent} e The event object.
         * @param {Number} index Axis index.
         */
        /**
         * @event map_mouseup
         * Event that occurs after left clicking on the map area. (real name ``` map.mouseup ```)
         * @param {jQueryEvent} e The event object.
         * @param {Number} index Axis index.
         */

        return Map;
    }
};

jui$1.use(dom, svg, color, axis);

var JUIBuilder = {
    name: "chart.builder",
    extend: "core",
    component: function component() {
        var _ = jui$1.include("util.base");
        var $ = jui$1.include("util.dom");
        var SVGUtil = jui$1.include("util.svg");
        var ColorUtil = jui$1.include("util.color");
        var Axis = jui$1.include("chart.axis");
        var HidpiUtil = jui$1.include("util.canvas.hidpi");

        _.resize(function () {
            var call_list = jui$1.get("chart.builder");

            for (var i = 0; i < call_list.length; i++) {
                var ui_list = call_list[i];

                for (var j = 0; j < ui_list.length; j++) {
                    if (_.typeCheck("function", ui_list[j].resize)) {
                        ui_list[j].resize();
                    }
                }
            }
        }, 1000);

        var UI = function UI() {
            var _axis = [],
                _brush = [],
                _widget = [],
                _defs = null;
            var _padding,
                _area,
                _theme,
                _hash = {};
            var _initialize = false,
                _options = null,
                _handler = { render: [], renderAll: [] }; // 리셋 대상 커스텀 이벤트 핸들러
            var _canvas = { main: null, buffer: null, sub: null }; // 캔버스 모드 전용
            var _cache = {},
                _index = 0; // index는 차트의 생성 순서

            function calculate(self) {
                var max = self.svg.size();

                var _chart = {
                    width: max.width - (_padding.left + _padding.right),
                    height: max.height - (_padding.top + _padding.bottom),
                    x: _padding.left,
                    y: _padding.top
                };

                // chart 크기가 마이너스일 경우 (엘리먼트가 hidden 상태)
                if (_chart.width < 0) _chart.width = 0;
                if (_chart.height < 0) _chart.height = 0;

                // _chart 영역 계산
                _chart.x2 = _chart.x + _chart.width;
                _chart.y2 = _chart.y + _chart.height;

                _area = _chart;
            }

            function drawBefore(self) {
                _brush = _.deepClone(_options.brush);
                _widget = _.deepClone(_options.widget);

                // defs 엘리먼트 생성
                _defs = self.svg.defs();

                // 해쉬 코드 초기화
                _hash = {};
            }

            function drawAxis(self) {

                // 엑시스 리스트 얻어오기
                var axisList = _.deepClone(_options.axis, { data: true, origin: true });

                for (var i = 0; i < axisList.length; i++) {
                    jui$1.defineOptions(Axis, axisList[i]);

                    // 엑시스 인덱스 설정
                    axisList[i].index = i;

                    if (!_axis[i]) {
                        _axis[i] = new Axis(self, _options.axis[i], axisList[i]);
                    } else {
                        _axis[i].reload(axisList[i]);
                    }
                }
            }

            function drawBrush(self) {
                var draws = _brush;

                if (draws != null) {
                    for (var i = 0; i < draws.length; i++) {
                        var Obj = jui$1.include("chart.brush." + draws[i].type);

                        // 브러쉬 기본 옵션과 사용자 옵션을 합침
                        jui$1.defineOptions(Obj, draws[i]);
                        var axis$$1 = _axis[draws[i].axis];

                        // 타겟 프로퍼티 설정
                        if (!draws[i].target) {
                            var target = [];

                            if (axis$$1) {
                                for (var key in axis$$1.data[0]) {
                                    target.push(key);
                                }
                            }

                            draws[i].target = target;
                        } else if (_.typeCheck("string", draws[i].target)) {
                            draws[i].target = [draws[i].target];
                        }

                        // 브러쉬 인덱스 설정
                        draws[i].index = i;

                        // 브러쉬 기본 프로퍼티 정의
                        var draw = new Obj(self, axis$$1, draws[i]);
                        draw.chart = self;
                        draw.axis = axis$$1;
                        draw.brush = draws[i];
                        draw.svg = self.svg;
                        draw.canvas = _canvas.buffer;

                        // 브러쉬 렌더링
                        draw.render();
                    }
                }
            }

            function drawWidget(self, isAll) {
                var draws = _widget;

                if (draws != null) {
                    for (var i = 0; i < draws.length; i++) {
                        var Obj = jui$1.include("chart.widget." + draws[i].type);

                        // 위젯 기본 옵션과 사용자 옵션을 합침
                        jui$1.defineOptions(Obj, draws[i]);

                        // 위젯 인덱스 설정
                        draws[i].index = i;

                        // 위젯 기본 프로퍼티 정의
                        var draw = new Obj(self, _axis[0], draws[i]);
                        draw.chart = self;
                        draw.axis = _axis[0];
                        draw.widget = draws[i];
                        draw.svg = self.svg;
                        draw.canvas = _canvas.sub;

                        // 위젯은 렌더 옵션이 false일 때, 최초 한번만 로드함 (연산 + 드로잉)
                        // 하지만 isAll이 true이면, 강제로 연산 및 드로잉을 함 (테마 변경 및 리사이징 시)
                        if (_initialize && !draw.isRender() && isAll !== true) {
                            return;
                        }

                        var elem = draw.render();
                        if (!draw.isRender()) {
                            self.svg.autoRender(elem, false);
                        }
                    }
                }
            }

            function setCommonEvents(self, elem) {
                var isMouseOver = false;

                elem.on("click", function (e) {
                    if (!checkPosition(e)) {
                        self.emit("bg.click", [e]);
                    } else {
                        self.emit("chart.click", [e]);
                    }
                });

                elem.on("dblclick", function (e) {
                    if (!checkPosition(e)) {
                        self.emit("bg.dblclick", [e]);
                    } else {
                        self.emit("chart.dblclick", [e]);
                    }
                });

                elem.on("contextmenu", function (e) {
                    if (!checkPosition(e)) {
                        self.emit("bg.rclick", [e]);
                    } else {
                        self.emit("chart.rclick", [e]);
                    }

                    e.preventDefault();
                });

                elem.on("mousemove", function (e) {
                    if (!checkPosition(e)) {
                        if (isMouseOver) {
                            self.emit("chart.mouseout", [e]);
                            isMouseOver = false;
                        }

                        self.emit("bg.mousemove", [e]);
                    } else {
                        if (isMouseOver) {
                            self.emit("chart.mousemove", [e]);
                        } else {
                            self.emit("chart.mouseover", [e]);
                            isMouseOver = true;
                        }
                    }
                });

                elem.on("mousedown", function (e) {
                    if (!checkPosition(e)) {
                        self.emit("bg.mousedown", [e]);
                    } else {
                        self.emit("chart.mousedown", [e]);
                    }
                });

                elem.on("mouseup", function (e) {
                    if (!checkPosition(e)) {
                        self.emit("bg.mouseup", [e]);
                    } else {
                        self.emit("chart.mouseup", [e]);
                    }
                });

                elem.on("mouseover", function (e) {
                    if (!checkPosition(e)) {
                        self.emit("bg.mouseover", [e]);
                    }
                });

                elem.on("mouseout", function (e) {
                    if (!checkPosition(e)) {
                        self.emit("bg.mouseout", [e]);
                    }
                });

                elem.on("mousewheel", function (e) {
                    if (!checkPosition(e)) {
                        self.emit("bg.mousewheel", [e]);
                    } else {
                        self.emit("chart.mousewheel", [e]);
                    }
                });

                function checkPosition(e) {
                    var pos = $.offset(self.root),
                        offsetX = e.pageX - pos.left,
                        offsetY = e.pageY - pos.top;

                    e.bgX = offsetX;
                    e.bgY = offsetY;
                    e.chartX = offsetX - self.padding("left");
                    e.chartY = offsetY - self.padding("top");

                    if (e.chartX < 0) return;
                    if (e.chartX > self.area("width")) return;
                    if (e.chartY < 0) return;
                    if (e.chartY > self.area("height")) return;

                    return true;
                }
            }

            function resetCustomEvent(self, isAll) {
                for (var i = 0; i < _handler.render.length; i++) {
                    self.off(_handler.render[i]);
                }
                _handler.render = [];

                if (isAll === true) {
                    for (var i = 0; i < _handler.renderAll.length; i++) {
                        self.off(_handler.renderAll[i]);
                    }
                    _handler.renderAll = [];
                }
            }

            function createGradient(obj, hashKey) {
                if (!_.typeCheck("undefined", hashKey) && _hash[hashKey]) {
                    return "url(#" + _hash[hashKey] + ")";
                }

                // var id = _.createId("gradient");
                var id = "gradient-" + _index;
                obj.attr.id = id;

                var g = SVGUtil.createObject(obj);
                _defs.append(g);

                if (!_.typeCheck("undefined", hashKey)) {
                    _hash[hashKey] = id;
                }

                return "url(#" + id + ")";
            }

            function createPattern(obj) {
                if (_.typeCheck("string", obj)) {
                    obj = obj.replace("url(#", "").replace(")", "");

                    if (_hash[obj]) {
                        return "url(#" + obj + ")";
                    }

                    // already pattern id
                    if (obj.indexOf('pattern-') == -1) {
                        return false;
                    }

                    var arr = obj.split("-"),
                        method = arr.pop();

                    var pattern = jui$1.include("chart." + arr.join("."));

                    if (!pattern) {
                        return false;
                    }

                    var patternElement = pattern[method];

                    if (typeof patternElement == 'function') {
                        patternElement = patternElement.call(patternElement);
                    }

                    // json 객체를 svg element 로 변환
                    if (patternElement.attr && !patternElement.attr.id) {
                        patternElement.attr.id = obj;
                    }

                    patternElement = SVGUtil.createObject(patternElement);

                    _defs.append(patternElement);

                    _hash[obj] = obj;

                    return "url(#" + obj + ")";
                } else {
                    // obj.attr.id = obj.attr.id || _.createId('pattern-');
                    obj.attr.id = obj.attr.id || "pattern-" + _index;

                    if (_hash[obj.attr.id]) {
                        return "url(#" + obj.attr.id + ")";
                    }

                    var patternElement = SVGUtil.createObject(obj);

                    _defs.append(patternElement);

                    _hash[obj.attr.id] = obj.attr.id;

                    return "url(#" + obj.attr.id + ")";
                }
            }

            function createColor(color$$1) {
                if (_.typeCheck("undefined", color$$1)) {
                    return "none";
                }

                if (_.typeCheck("object", color$$1)) {

                    if (color$$1.type == "pattern") {
                        return createPattern(color$$1);
                    } else {
                        return createGradient(color$$1);
                    }
                }

                if (typeof color$$1 == "string") {
                    var url = createPattern(color$$1);
                    if (url) {
                        return url;
                    }
                }

                var parsedColor = ColorUtil.parse(color$$1);
                if (parsedColor == color$$1) return color$$1;

                return createGradient(parsedColor, color$$1);
            }

            function setThemeStyle(theme) {
                var style = {};

                // 테마를 하나의 객체로 Merge
                if (_.typeCheck("string", theme)) {
                    _.extend(style, jui$1.include("chart.theme." + theme));
                    _.extend(style, _options.style);
                } else if (_.typeCheck("object", theme)) {
                    _.extend(_theme, _options.style);
                    _.extend(_theme, theme);
                    _.extend(style, _theme);
                }

                // 최종 렌더링에 적용되는 객체
                _theme = style;
            }

            function setDefaultOptions(self) {
                // 일부 옵션을 제외하고 클론
                _options = _.deepClone(self.options, { data: true, bind: true });

                var padding = _options.padding;

                // 패딩 옵션 설정
                if (_.typeCheck("integer", padding)) {
                    _padding = { left: padding, right: padding, bottom: padding, top: padding };
                } else {
                    _padding = padding;
                }

                // Draw 옵션 설정
                if (!_.typeCheck("array", _options.axis)) {
                    _options.axis = [_options.axis];
                }

                if (!_.typeCheck("array", _options.brush)) {
                    _options.brush = [_options.brush];
                }

                if (!_.typeCheck("array", _options.widget)) {
                    _options.widget = [_options.widget];
                }

                // Axis 기본값 설정
                if (_options.axis.length == 0) {
                    _options.axis.push({ data: [] });
                }

                // Axis 확장 설정
                for (var i = 0; i < _options.axis.length; i++) {
                    var axis$$1 = _options.axis[i];
                    _.extend(axis$$1, _options.axis[axis$$1.extend], true);
                }
            }

            function setVectorFontIcons() {
                var icon = _options.icon;
                if (!_.typeCheck(["string", "array"], icon.path)) return;

                var pathList = _.typeCheck("string", icon.path) ? [icon.path] : icon.path,
                    urlList = [];

                for (var i = 0; i < pathList.length; i++) {
                    var path = pathList[i],
                        url = "url(" + path + ") ";

                    if (path.indexOf(".eot") != -1) {
                        url += "format('embedded-opentype')";
                    } else if (path.indexOf(".woff") != -1) {
                        url += "format('woff')";
                    } else if (path.indexOf(".ttf") != -1) {
                        url += "format('truetype')";
                    } else if (path.indexOf(".svg") != -1) {
                        url += "format('svg')";
                    }

                    urlList.push(url);
                }

                var fontFace = "font-family: " + icon.type + "; font-weight: normal; font-style: normal; src: " + urlList.join(",");

                (function (rule) {
                    var sheet = function () {
                        var style = document.createElement("style");

                        style.appendChild(document.createTextNode(""));
                        document.head.appendChild(style);

                        return style.sheet;
                    }();

                    sheet.insertRule(rule, 0);
                })("@font-face {" + fontFace + "}");
            }

            function parseIconInText(self, text) {
                var regex = /{([^{}]+)}/g,
                    result = text.match(regex);

                if (result != null) {
                    for (var i = 0; i < result.length; i++) {
                        var key = result[i].substring(1, result[i].length - 1);
                        text = text.replace(result[i], self.icon(key));
                    }
                }

                return text;
            }

            function getCanvasRealSize(self) {
                var size = self.svg.size();

                return {
                    width: _.typeCheck("integer", _options.width) ? _options.width : size.width,
                    height: _.typeCheck("integer", _options.height) ? _options.height : size.height
                };
            }

            function initRootStyles(root) {
                root.style.position = "relative";
                root.style.userSelect = "none";
                root.style.webkitUserSelect = "none";
                root.style.MozUserSelect = "none";
                root.setAttribute("unselectable", "on");
            }

            function initCanvasElement(self) {
                var size = getCanvasRealSize(self);
                var ratio = HidpiUtil.pixelRatio;

                var _loop = function _loop(key) {
                    var elem = document.createElement("CANVAS");
                    elem.width = size.width * ratio;
                    elem.height = size.height * ratio;
                    elem.style.position = "absolute";
                    elem.style.left = "0px";
                    elem.style.top = "0px";
                    elem.style.width = size.width + "px";
                    elem.style.height = size.height + "px";

                    // Context 설정하기
                    if (elem.getContext) {
                        _canvas[key] = elem.getContext("2d");
                        HidpiUtil.apply(_canvas[key]);

                        if (key != "buffer") {
                            self.root.appendChild(elem);
                        }
                    }

                    // Widget 캔버스 이벤트 함수 정의
                    if (key == "sub") {
                        elem.on = function (type, handler) {
                            var callback = function callback(e) {
                                if (typeof handler == "function") {
                                    handler.call(this, e);
                                }
                            };

                            elem.addEventListener(type, callback, false);
                            return this;
                        };
                    }
                };

                for (var key in _canvas) {
                    _loop(key);
                }
            }

            function resetCanvasElement(self, type) {
                var ratio = HidpiUtil.pixelRatio,
                    size = getCanvasRealSize(self),
                    context = _canvas[type];

                context.restore();
                context.clearRect(0, 0, size.width * ratio, size.height * ratio);
                context.save();

                if (type == "main") {
                    context.translate(_area.x, _area.y);
                }
            }

            this.init = function () {
                // TODO: 차트 인덱스 설정
                _index = this.index = jui$1.size();

                // 기본 옵션 설정
                setDefaultOptions(this);

                // 차트 테마 설정 (+옵션 스타일)
                setThemeStyle(_options.theme);

                // 루트 엘리먼트 기본 스타일 설정
                initRootStyles(this.root);

                /** @property {chart.svg} svg Refers to an SVG utility object. */
                this.svg = new SVGUtil(this.root, {
                    width: _options.width,
                    height: _options.height,
                    "buffered-rendering": "dynamic"
                });

                // canvas 기본 객체 생성
                if (_options.canvas) {
                    initCanvasElement(this);
                    setCommonEvents(this, $.find(this.root, "CANVAS")[1]);
                } else {
                    setCommonEvents(this, this.svg.root);
                }

                // 아이콘 폰트 설정
                setVectorFontIcons();

                // 차트 기본 렌더링
                this.render();
            };

            /**
             * @method get
             *
             * Gets a named axis, brush, widget (type: axis, brush, widget, padding, area)
             *
             * @param {"axis"/"brush"/"widget"/"padding"/"area"} type
             * @param {String} key  Property name
             * @return {Mixed/Object}
             */
            this.get = function (type, key) {
                var obj = {
                    axis: _axis,
                    brush: _brush,
                    widget: _widget,
                    padding: _padding,
                    area: _area
                };

                if (obj[type][key]) {
                    return obj[type][key];
                }

                return obj[type] || obj;
            };

            /**
             * Gets the axis object of that index.
             *
             * @param {Number} key
             * @returns {Array/Object}
             */
            this.axis = function (key) {
                return arguments.length == 0 ? _axis : _axis[key];
            };

            /**
             * Gets a calculated value for a chart area (type: width, height, x, y, x2, y2)).
             *
             * @param {String} key
             * @return {Number/Object}
             */
            this.area = function (key) {
                return _.typeCheck("undefined", _area[key]) ? _area : _area[key];
            };

            /**
             * Gets the top, bottom, left and right margin values.
             *
             * @param {"top"/"left"/"bottom"/"right"} key
             * @return {Number/Object}
             */
            this.padding = function (key) {
                return _.typeCheck("undefined", _padding[key]) ? _padding : _padding[key];
            };

            /**
             * Gets a color defined in the theme or the color set.
             *
             * @param {Number/String} key
             * @param {Array} colors
             * @param {Array} target
             * @return {String} Selected color string
             */
            this.color = function (key, colors) {
                var color$$1 = null;

                // 직접 색상을 추가할 경우 (+그라데이션, +필터)
                if (arguments.length == 1) {
                    if (_.typeCheck("string", key)) {
                        color$$1 = key;
                    } else if (_.typeCheck("integer", key)) {
                        color$$1 = nextColor(key);
                    }
                } else {
                    // 테마 & 브러쉬 옵션 컬러 설정
                    if (_.typeCheck(["array", "object"], colors)) {
                        color$$1 = colors[key];

                        if (_.typeCheck("integer", color$$1)) {
                            color$$1 = nextColor(color$$1);
                        }
                    } else {
                        color$$1 = nextColor();
                    }
                }

                if (_hash[color$$1]) {
                    return "url(#" + _hash[color$$1] + ")";
                }

                function nextColor(newIndex) {
                    var c = _theme["colors"],
                        index = newIndex || key;

                    return index > c.length - 1 ? c[c.length - 1] : c[index];
                }

                return createColor(color$$1);
            };

            /**
             * Gets the unicode string of the icon.
             *
             * @param {String} key  icon's alias
             */
            this.icon = function (key) {
                return jui$1.include("chart.icon." + _options.icon.type)[key];
            };

            /**
             * Creates a text element to which a theme is applied.
             *
             * Also it support icon string
             *
             * @param {Object} attr
             * @param {String|Function} textOrCallback
             */
            this.text = function (attr, textOrCallback) {
                if (_.typeCheck("string", textOrCallback)) {
                    textOrCallback = parseIconInText(this, textOrCallback);
                } else if (_.typeCheck("undefined", textOrCallback)) {
                    textOrCallback = "";
                }

                return this.svg.text(attr, textOrCallback);
            };

            /**
             * Creates a text element to which a theme is applied.
             *
             * Also it support icon string
             *
             * @param {Object} attr
             * @param {Array} texts
             * @param {Number} lineBreakRate
             */
            this.texts = function (attr, texts, lineBreakRate) {
                var g = this.svg.group();

                for (var i = 0; i < texts.length; i++) {
                    if (_.typeCheck("string", texts[i])) {
                        var size = (attr["font-size"] || 10) * (lineBreakRate || 1);

                        g.append(this.svg.text(_.extend({ y: i * size }, attr, true), parseIconInText(this, texts[i])));
                    }
                }

                return g;
            };

            /**
             * @method theme
             *
             * Gets a value for the theme element applied to the current chart.
             *
             * ```
             *      // get all theme property
             *      var theme = chart.theme();
             *      // get a part of theme
             *      var fontColor = chart.theme("fontColor");
             *      // get selected value of theme
             *      chart.theme(isSelected, "selectedFontColor", "fontColor");  // if isSelected is true, return 'selectedFontColor' else return 'fontColor'
             * ```
             */
            this.theme = function (key, value, value2) {
                if (arguments.length == 0) {
                    return _theme;
                } else if (arguments.length == 1) {
                    if (key.indexOf("Color") > -1 && _theme[key] != null) {
                        return createColor(_theme[key]);
                    }

                    return _theme[key];
                } else if (arguments.length == 3) {
                    var val = key ? value : value2;

                    if (val.indexOf("Color") > -1 && _theme[val] != null) {
                        return createColor(_theme[val]);
                    }

                    return _theme[val];
                }
            };

            /**
             * Returns a value from the format callback function of a defined option.
             *
             * @param {Function} format
             * @return {Mixed}
             */
            this.format = function () {
                if (arguments.length == 0) return;
                var callback = _options.format;

                if (_.typeCheck("function", callback)) {
                    return callback.apply(this, arguments);
                }

                return arguments[0];
            };

            /**
             * @method on
             *
             * A callback function defined as an on method is run when an emit method is called.
             *
             * @param {String} type Event's name
             * @param {Function} callback
             * @param {"render"/"renderAll"/undefined} resetType
             */
            this.on = function (type, callback, resetType) {
                if (!_.typeCheck("string", type) || !_.typeCheck("function", callback)) return;

                this.event.push({ type: type.toLowerCase(), callback: callback });

                // 브러쉬나 위젯에서 설정한 이벤트 핸들러만 추가
                if (resetType == "render" || resetType == "renderAll") {
                    _handler[resetType].push(callback);
                }
            };

            /**
             * @method render
             *
             * Renders all draw objects.
             *
             * @param {Boolean} isAll
             */
            this.render = function (isAll) {
                // SVG 메인 리셋
                this.svg.reset(isAll);

                // chart 이벤트 초기화 (삭제 대상)
                resetCustomEvent(this, isAll);

                // chart 영역 계산
                calculate(this);

                // Canvas 초기 설정
                if (this.options.canvas) {
                    resetCanvasElement(this, "main");
                    resetCanvasElement(this, "buffer");

                    if (isAll) {
                        resetCanvasElement(this, "sub");
                    }
                }

                // chart 관련된 요소 draw
                drawBefore(this);
                drawAxis(this);
                drawBrush(this);
                drawWidget(this, isAll);

                // Canvas 더블버퍼링 렌더링
                if (this.options.canvas) {
                    _canvas.main.drawImage(_canvas.buffer.canvas, 0, 0);
                }

                // SVG 기본 테마 설정
                this.svg.root.css({
                    "font-family": this.theme("fontFamily") + "," + _options.icon.type,
                    background: this.theme("backgroundColor")
                });

                // SVG 메인/서브 렌더링
                this.svg.render(isAll);

                // 커스텀 이벤트 발생
                this.emit("render", [_initialize]);

                // 초기화 및 렌더링 체크 설정
                _initialize = true;
            };

            /**
             * @method appendDefs
             *
             * Add the child element in defs tag.
             *
             * @param {chart.svg.element} elem
             */
            this.appendDefs = function (elem) {
                _defs.append(elem);
            };

            /**
             * @method addBrush
             *
             * Adds a brush and performs rendering again.
             *
             * @param {Object} brush
             */
            this.addBrush = function (brush) {
                _options.brush.push(brush);
                if (this.isRender()) this.render();
            };

            /**
             * @method removeBrush
             *
             * Deletes the brush of a specified index and performs rendering again.
             * @param {Number} index
             */
            this.removeBrush = function (index) {
                _options.brush.splice(index, 1);
                if (this.isRender()) this.render();
            };

            /**
             * @method updateBrush
             * Updates the brush of a specified index and performs rendering again.
             * @param {Number} index
             * @param {Object} brush
             * @param {Boolean} isReset
             */
            this.updateBrush = function (index, brush, isReset) {
                if (isReset === true) {
                    _options.brush[index] = brush;
                } else {
                    _.extend(_options.brush[index], brush);
                }

                if (this.isRender()) this.render();
            };

            /**
             * @method addWidget
             * Adds a widget and performs rendering again.
             *
             * @param {Object} widget
             */
            this.addWidget = function (widget) {
                _options.widget.push(widget);
                if (this.isRender()) this.render();
            };

            /**
             * @method removeWidget
             * Deletes the widget of a specified index and performs rendering again.
             * @param {Number} index
             */
            this.removeWidget = function (index) {
                _options.widget.splice(index, 1);
                if (this.isRender()) this.render();
            };

            /**
             * @method updateWidget
             * Updates the widget of a specified index and performs rendering again
             * @param {Number} index
             * @param {Object} widget
             * @param {Boolean} isReset
             */
            this.updateWidget = function (index, widget, isReset) {
                if (isReset === true) {
                    _options.widget[index] = widget;
                } else {
                    _.extend(_options.widget[index], widget);
                }

                if (this.isRender()) this.render();
            };

            /**
             * Changes a chart to a specified theme and renders the chart again.
             *
             * @param {String/Object} theme
             */
            this.setTheme = function (theme) {
                setThemeStyle(theme);
                if (this.isRender()) this.render(true);
            };

            /**
             * Changes the size of a chart to the specified area and height then performs rendering.
             *
             * @param {Number} width
             * @param {Number} height
             */
            this.setSize = function (width, height) {
                if (arguments.length == 2) {
                    _options.width = width;
                    _options.height = height;
                }

                // Resize svg
                this.svg.size(_options.width, _options.height);

                // Resize canvas
                if (_options.canvas) {
                    var ratio = HidpiUtil.pixelRatio,
                        list = $.find(this.root, "CANVAS"),
                        size = getCanvasRealSize(this);

                    for (var i = 0; i < list.length; i++) {
                        list[i].width = size.width * ratio;
                        list[i].height = size.height * ratio;
                        list[i].style.width = size.width + "px";
                        list[i].style.height = size.height + "px";
                    }
                }

                if (this.isRender()) this.render(true);
            };

            /**
             * Returns true if the horizontal or vertical size of the chart is 100%.
             *
             * @return {Boolean}
             */
            this.isFullSize = function () {
                if (_options.width == "100%" || _options.height == "100%") return true;

                return true;
            };

            /**
             * Resize the chart to fit the screen width.
             *
             */
            this.resize = function () {
                if (this.isFullSize()) {
                    this.setSize();
                }

                if (!this.isRender()) {
                    this.render(true);
                }
            };

            /**
             * Returns the values of rendering options and, if the rendering option is false, does not render the chart again when a method is called.
             *
             * @return {Boolean}
             */
            this.isRender = function () {
                return !_initialize ? true : _options.render;
            };

            this.setCache = function (key, value) {
                _cache[key] = value;
            };

            this.getCache = function (key, defValue) {
                if (_cache[key] === undefined) return defValue;
                return _cache[key];
            };
        };

        UI.setup = function () {
            return {
                /** @cfg  {String/Number} [width="100%"] chart width */
                width: "100%",
                /** @cfg  {String/Number} [height="100%"] chart height */
                height: "100%",
                /**
                 * @cfg  {Object} padding chart padding
                 * @cfg  {Number} [padding.top=50] chart padding
                 * @cfg  {Number} [padding.bottom=50] chart padding
                 * @cfg  {Number} [padding.left=50] chart padding
                 * @cfg  {Number} [padding.right=50] chart padding
                 */
                padding: {
                    top: 50,
                    bottom: 50,
                    left: 50,
                    right: 50
                },

                /** @cfg  {String} [theme=classic] chart theme  */
                theme: "classic",
                /** @cfg  {Object} style chart custom theme  */
                style: {},
                /** @cfg {Array} brush Determines a brush to be added to a chart. */
                brush: [],
                /** @cfg {Array} widget Determines a widget to be added to a chart. */
                widget: [],
                /** @cfg {Array} [axis=[]] Determines a axis to be added to a chart. */
                axis: [],

                /** @cfg {Object} [bind=null] Sets a component objects to be bind.*/
                bind: null,
                /** @cfg {Function} [format=null] Sets a format callback function to be used in a grid/brush/widget. */
                format: null,
                /** @cfg {Boolean} [render=true] Does not render a chart when a rendering-related method is called with false (although the render method is not included). */
                render: true,

                /**
                 * @cfg {Object} icon Icon-related settings available in the chart.
                 * @cfg {String} [icon.type="classic"]
                 * @cfg {String} [icon.path=null]
                 */
                icon: {
                    type: "classic",
                    path: null
                },

                /** @cfg {Boolean} [canvas=false] */
                canvas: false
            };
        };

        /**
         * @event chart_click
         * Event that occurs when clicking on the chart area. (real name ``` chart.click ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event chart_dblclick
         * Event that occurs when double clicking on the chart area. (real name ``` chart.dblclick ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event chart_rclick
         * Event that occurs when right clicking on the chart area. (real name ``` chart.rclick ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event chart_mouseover
         * Event that occurs when placing the mouse over the chart area. (real name ``` chart.mouseover ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event chart_mouseout
         * Event that occurs when moving the mouse out of the chart area. (real name ``` chart.mouseout ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event chart_mousemove
         * Event that occurs when moving the mouse over the chart area. (real name ``` chart.mousemove ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event chart_mousedown
         * Event that occurs when left clicking on the chart area. (real name ``` chart.mousedown ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event chart_mouseup
         * Event that occurs after left clicking on the chart area. (real name ``` chart.mouseup ```)
         * @param {jQueryEvent} e The event object.
         */

        /**
         * @event bg_click
         * Event that occurs when clicking on the chart margin. (real name ``` bg.click ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event bg_dblclick
         * Event that occurs when double clicking on the chart margin. (real name ``` bg.dblclick ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event bg_rclick
         * Event that occurs when right clicking on the chart margin. (real name ``` bg.rclick ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event bg_mouseover
         * Event that occurs when placing the mouse over the chart margin. (real name ``` bg.mouseover ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event bg_mouseout
         * Event that occurs when moving the mouse out of the chart margin. (real name ``` bg.mouseout ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event bg_mousemove
         * Event that occurs when moving the mouse over the chart margin. (real name ``` bg.mousemove ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event bg_mousedown
         * Event that occurs when left clicking on the chart margin. (real name ``` bg.mousedown ```)
         * @param {jQueryEvent} e The event object.
         */
        /**
         * @event bg_mouseup
         * Event that occurs after left clicking on the chart margin. (real name ``` bg.mouseup ```)
         * @param {jQueryEvent} e The event object.
         */

        return UI;
    }
};

var Plane = {
    name: "chart.plane",
    extend: "core",
    component: function component() {
        var _ = jui$1.include("util.base");
        var builder = jui$1.include("chart.builder");

        var UI = function UI() {
            var chart = null,
                axis = [],
                brush = [],
                widget = [];

            var axisIndex = 0,
                baseAxis = {},
                etcAxis = {};

            this.init = function () {
                var opts = this.options,
                    defAxis = {
                    type: "range",
                    step: opts.step,
                    line: opts.line
                };

                baseAxis.x = _.extend({ domain: opts.x }, defAxis);
                baseAxis.y = _.extend({ domain: opts.y }, defAxis);
                baseAxis.x.orient = "bottom";
                baseAxis.y.orient = "left";
                baseAxis.z = _.extend({ domain: opts.z }, defAxis);
                baseAxis.depth = opts.depth - opts.padding * 2;
                baseAxis.degree = { x: opts.dx, y: opts.dy, z: opts.dz };
                baseAxis.perspective = opts.perspective;

                etcAxis.extend = 0;
                etcAxis.x = { hide: true };
                etcAxis.y = { hide: true };
                etcAxis.z = { hide: true };

                if (opts.dimension == "2d") {
                    baseAxis.perspective = 1;
                    baseAxis.degree.x = 0;
                    baseAxis.degree.y = 0;
                    baseAxis.degree.z = 0;
                    baseAxis.z.hideText = true;
                }
            };

            this.push = function (data) {
                if (!_.typeCheck("array", data)) return;

                if (!axis[axisIndex]) {
                    axis.push(_.extend({}, axisIndex == 0 ? baseAxis : etcAxis));
                }

                if (!axis[axisIndex].data) {
                    axis[axisIndex].data = [];
                }

                axis[axisIndex].data.push(data);
            };

            this.commit = function (symbol, r) {
                var opts = this.options;

                brush.push({
                    type: "canvas.dot3d",
                    color: axisIndex,
                    axis: axisIndex,
                    symbol: symbol || opts.symbol,
                    size: (r || opts.r) * 2
                });

                axisIndex++;
            };

            this.append = function (datas, symbol, r) {
                var opts = this.options;

                axis.push(_.extend({}, axisIndex == 0 ? baseAxis : etcAxis));
                axis[axisIndex].data = datas;

                brush.push({
                    type: "canvas.dot3d",
                    color: axisIndex,
                    axis: axisIndex,
                    symbol: symbol || opts.symbol,
                    size: (r || opts.r) * 2
                });

                axisIndex++;
            };

            this.render = function () {
                var opts = this.options;

                if (opts.dimension == "3d") {
                    widget.push({
                        type: "polygon.rotate3d"
                    });
                }

                if (chart != null) {
                    chart.root.innerHTML = "";
                    chart = null;
                }

                if (axis.length == 0) {
                    axis.push(baseAxis);
                }

                chart = builder(this.root, {
                    padding: opts.padding,
                    width: opts.width,
                    height: opts.height,
                    axis: axis,
                    brush: brush,
                    widget: widget,
                    canvas: true,
                    render: false,
                    style: {
                        gridFaceBackgroundOpacity: 0.1
                    }
                });

                if (_.typeCheck("array", opts.colors)) {
                    var colors = [];

                    for (var i = 0; i < opts.colors.length; i++) {
                        colors.push(chart.color(opts.colors[i]));
                    }

                    chart.setTheme({ colors: colors });
                }

                axis = [];
                brush = [];
                widget = [];
                axisIndex = 0;

                chart.render();
            };
        };

        UI.setup = function () {
            return {
                dimension: "2d",
                width: 500,
                height: 500,
                depth: 500,
                padding: 50,
                x: [-100, 100],
                y: [-100, 100],
                z: [-100, 100],
                step: 4,
                line: true,
                symbol: "dot",
                r: 2,
                perspective: 0.9,
                dx: 10,
                dy: 5,
                dz: 0,
                colors: null
            };
        };

        return UI;
    }
};

var Animation = {
    name: "chart.animation",
    extend: "core",
    component: function component() {
        var _ = jui$1.include("util.base");
        var builder = jui$1.include("chart.builder");

        var UI = function UI() {
            var interval = void 0,
                animateSeq = -1,
                prevTime = 0,
                startTime = 0;

            this.init = function () {
                var opts = this.options;

                // 차트 빌더는 interval 옵션을 사용하지 않기 때문에 삭제함
                interval = opts.interval;
                delete opts.interval;

                if (opts.axis.length && opts.axis.length > 1) throw new Error("JUI_CRITICAL_ERR: the real-time module allows only a single axes");

                this.builder = builder(this.selector, opts);
            };

            this.run = function (callback) {
                var self = this;
                var currentTime = Date.now();

                if (startTime == 0) {
                    startTime = currentTime;
                }

                if (currentTime - prevTime > interval || interval == 0) {
                    var tpf = (currentTime - prevTime) / 1000;
                    if (tpf > 1) tpf = 1;

                    this.builder.setCache("tpf", tpf);
                    this.builder.setCache("fps", 1.0 / tpf);

                    if (typeof callback == "function") {
                        callback.call(this, currentTime - startTime);
                    }

                    this.render();
                    prevTime = currentTime;
                }

                animateSeq = requestAnimationFrame(function () {
                    self.run(callback);
                });
            };

            this.stop = function () {
                if (animateSeq != -1) {
                    cancelAnimationFrame(animateSeq);
                    animateSeq = -1;
                }
            };

            this.set = function (type, value, isReset) {
                this.builder.axis(0).set(type, value, isReset);
            };

            this.update = function (data) {
                this.builder.axis(0).update(data);
            };

            this.render = function (isAll) {
                this.builder.render(isAll);
            };
        };

        UI.setup = function () {
            return _.extend({
                render: false,
                canvas: true,
                interval: 0
            }, JUIBuilder.component().setup(), true);
        };

        return UI;
    }
};

jui$1.use([vector, transform, math]);

var core = {
    name: "chart.polygon.core",
    extend: null,
    component: function component() {
        var _ = jui$1.include("util.base");
        var Vector = jui$1.include("chart.vector");
        var Transform = jui$1.include("util.transform");
        var math$$1 = jui$1.include("util.math");

        var PolygonCore = function PolygonCore() {
            this.perspective = 0.9;

            this.rotate = function (depth, degree, cx, cy, cz) {
                var p = this.perspective,
                    t = new Transform(this.vertices),
                    m = t.matrix("move3d", cx, cy, cz);

                // 폴리곤 이동 및 각도 변경
                m = math$$1.matrix3d(m, t.matrix("rotate3dx", degree.x));
                m = math$$1.matrix3d(m, t.matrix("rotate3dy", degree.y));
                m = math$$1.matrix3d(m, t.matrix("rotate3dz", degree.z));
                m = math$$1.matrix3d(m, t.matrix("move3d", -cx, -cy, -cz));
                this.vertices = t.custom(m);

                for (var i = 0, count = this.vertices.length; i < count; i++) {
                    var far = Math.abs(this.vertices[i][2] - depth),
                        s = math$$1.scaleValue(far, 0, depth, p, 1),
                        t2 = new Transform(),
                        m2 = t2.matrix("move3d", cx, cy, depth / 2);

                    // 폴리곤 스케일 변경
                    m2 = math$$1.matrix3d(m2, t2.matrix("scale3d", s, s, s));
                    m2 = math$$1.matrix3d(m2, t2.matrix("move3d", -cx, -cy, -depth / 2));
                    this.vertices[i] = math$$1.matrix3d(m2, this.vertices[i]);

                    // 벡터 객체 생성 및 갱신
                    if (_.typeCheck("array", this.vectors)) {
                        if (this.vectors[i] == null) {
                            this.vectors[i] = new Vector(this.vertices[i][0], this.vertices[i][1], this.vertices[i][2]);
                        } else {
                            this.vectors[i].x = this.vertices[i][0];
                            this.vectors[i].y = this.vertices[i][1];
                            this.vectors[i].z = this.vertices[i][2];
                        }
                    }
                }
            };

            this.min = function () {
                var obj = {
                    x: this.vertices[0][0],
                    y: this.vertices[0][1],
                    z: this.vertices[0][2]
                };

                for (var i = 1, len = this.vertices.length; i < len; i++) {
                    obj.x = Math.min(obj.x, this.vertices[i][0]);
                    obj.y = Math.min(obj.y, this.vertices[i][1]);
                    obj.z = Math.min(obj.z, this.vertices[i][2]);
                }

                return obj;
            };

            this.max = function () {
                var obj = {
                    x: this.vertices[0][0],
                    y: this.vertices[0][1],
                    z: this.vertices[0][2]
                };

                for (var i = 1, len = this.vertices.length; i < len; i++) {
                    obj.x = Math.max(obj.x, this.vertices[i][0]);
                    obj.y = Math.max(obj.y, this.vertices[i][1]);
                    obj.z = Math.max(obj.z, this.vertices[i][2]);
                }

                return obj;
            };
        };

        return PolygonCore;
    }
};

jui$1.use(core);

var grid$1 = {
    name: "chart.polygon.grid",
    extend: "chart.polygon.core",
    component: function component() {
        var GridPolygon = function GridPolygon(type, width, height, depth, x, y) {
            x = x || 0;
            y = y || 0;
            width = x + width;
            height = y + height;

            var matrix = {
                center: [new Float32Array([x, y, depth, 1]), new Float32Array([width, y, depth, 1]), new Float32Array([width, height, depth, 1]), new Float32Array([x, height, depth, 1])],
                horizontal: [new Float32Array([x, height, 0, 1]), new Float32Array([width, height, 0, 1]), new Float32Array([width, height, depth, 1]), new Float32Array([x, height, depth, 1])],
                vertical: [new Float32Array([width, y, 0, 1]), new Float32Array([width, height, 0, 1]), new Float32Array([width, height, depth, 1]), new Float32Array([width, y, depth, 1])]
            };

            this.vertices = matrix[type];

            this.vectors = [];
        };

        return GridPolygon;
    }
};

jui$1.use(core);

var line = {
    name: "chart.polygon.line",
    extend: "chart.polygon.core",
    component: function component() {
        var LinePolygon = function LinePolygon(x1, y1, d1, x2, y2, d2) {
            this.vertices = [new Float32Array([x1, y1, d1, 1]), new Float32Array([x2, y2, d2, 1])];

            this.vectors = [];
        };

        return LinePolygon;
    }
};

jui$1.use(core);

var point = {
    name: "chart.polygon.point",
    extend: "chart.polygon.core",
    component: function component() {
        var PointPolygon = function PointPolygon(x, y, d) {
            this.vertices = [new Float32Array([x, y, d, 1])];

            this.vectors = [];
        };

        return PointPolygon;
    }
};

jui$1.use(core);

var CubePolygon = {
    name: "chart.polygon.cube",
    extend: "chart.polygon.core",
    component: function component() {
        var CubePolygon = function CubePolygon(x, y, z, w, h, d) {
            this.vertices = [new Float32Array([x, y, z, 1]), new Float32Array([x + w, y, z, 1]), new Float32Array([x + w, y, z + d, 1]), new Float32Array([x, y, z + d, 1]), new Float32Array([x, y + h, z, 1]), new Float32Array([x + w, y + h, z, 1]), new Float32Array([x + w, y + h, z + d, 1]), new Float32Array([x, y + h, z + d, 1])];

            this.faces = [[0, 1, 2, 3], [3, 2, 6, 7], [0, 3, 7, 4], [1, 2, 6, 5], [0, 1, 5, 4], [4, 5, 6, 7]];

            this.vectors = [];
        };

        return CubePolygon;
    }
};

jui$1.use(draw);

var draw2d = {
    name: "chart.grid.draw2d",
    extend: "chart.draw",
    component: function component() {
        var _ = jui$1.include("util.base");

        var Draw2DGrid = function Draw2DGrid() {

            this.createGridX = function (position, index, x, isActive, isLast) {
                var line = this.getLineOption(),
                    axis = this.chart.svg.group().translate(x, 0),
                    size = this.chart.theme("gridTickBorderSize");

                axis.append(this.line({
                    y2: position == "bottom" ? size : -size,
                    stroke: this.color(isActive, "gridActiveBorderColor", "gridXAxisBorderColor"),
                    "stroke-width": this.chart.theme("gridTickBorderWidth")
                }));

                if (line) {
                    this.drawValueLine(position, axis, isActive, line, index, isLast);
                }

                return axis;
            };

            this.createGridY = function (position, index, y, isActive, isLast) {
                var line = this.getLineOption(),
                    axis = this.chart.svg.group().translate(0, y),
                    size = this.chart.theme("gridTickBorderSize");

                axis.append(this.line({
                    x2: position == "left" ? -size : size,
                    stroke: this.color(isActive, "gridActiveBorderColor", "gridYAxisBorderColor"),
                    "stroke-width": this.chart.theme("gridTickBorderWidth")
                }));

                if (line) {
                    this.drawValueLine(position, axis, isActive, line, index, isLast);
                }

                return axis;
            };

            this.fillRectObject = function (g, line, position, x, y, width, height) {
                if (line.type.indexOf("gradient") > -1) {
                    g.append(this.chart.svg.rect({
                        x: x,
                        y: y,
                        height: height,
                        width: width,
                        fill: this.chart.color(line.fill ? line.fill : "linear(" + position + ") " + this.chart.theme("gridPatternColor") + ",0.5 " + this.chart.theme("backgroundColor")),
                        "fill-opacity": this.chart.theme("gridPatternOpacity")
                    }));
                } else if (line.type.indexOf("rect") > -1) {
                    g.append(this.chart.svg.rect({
                        x: x,
                        y: y,
                        height: height,
                        width: width,
                        fill: this.chart.color(line.fill ? line.fill : this.chart.theme("gridPatternColor")),
                        "fill-opacity": this.chart.theme("gridPatternOpacity")
                    }));
                }
            };

            /**
             * @method drawAxisLine
             * theme 이 적용된  axis line 리턴
             * @param {ChartBuilder} chart
             * @param {Object} attr
             */
            this.drawAxisLine = function (position, g, attr) {
                var isTopOrBottom = position == "top" || position == "bottom";

                g.append(this.chart.svg.line(_.extend({
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                    stroke: this.color(isTopOrBottom ? "gridXAxisBorderColor" : "gridYAxisBorderColor"),
                    "stroke-width": this.chart.theme(isTopOrBottom ? "gridXAxisBorderWidth" : "gridYAxisBorderWidth"),
                    "stroke-opacity": 1
                }, attr)));
            };

            this.drawPattern = function (position, ticks, values, isMove) {
                if (this.grid.hide) return;
                if (!position) return;
                if (!ticks) return;
                if (!values) return;

                var line = this.getLineOption(),
                    isY = position == "left" || position == "right",
                    g = this.chart.svg.group();

                g.translate(this.axis.area("x") + this.chart.area("x"), this.axis.area("y") + this.chart.area("y"));

                if (line && (line.type.indexOf("gradient") > -1 || line.type.indexOf("rect") > -1)) {
                    for (var i = 0; i < values.length - 1; i += 2) {
                        var dist = Math.abs(values[i + 1] - values[i]),
                            pos = values[i] - (isMove ? dist / 2 : 0),
                            x = isY ? 0 : pos,
                            y = isY ? pos : 0,
                            width = isY ? this.axis.area("width") : dist,
                            height = isY ? dist : this.axis.area("height");

                        this.fillRectObject(g, line, position, x, y, width, height);
                    }
                }
            };

            this.drawBaseLine = function (position, g) {
                var obj = this.getGridSize(),
                    pos = {};

                if (position == "bottom" || position == "top") {
                    pos = { x1: obj.start, x2: obj.end };
                } else if (position == "left" || position == "right") {
                    pos = { y1: obj.start, y2: obj.end };
                }

                this.drawAxisLine(position, g, pos);
            };

            this.drawValueLine = function (position, axis, isActive, line, index, isLast) {
                var area = {},
                    isDrawLine = false;

                if (position == "top") {
                    isDrawLine = this.checkDrawLineY(index, isLast);
                    area = { x1: 0, x2: 0, y1: 0, y2: this.axis.area("height") };
                } else if (position == "bottom") {
                    isDrawLine = this.checkDrawLineY(index, isLast);
                    area = { x1: 0, x2: 0, y1: 0, y2: -this.axis.area("height") };
                } else if (position == "left") {
                    isDrawLine = this.checkDrawLineX(index, isLast);
                    area = { x1: 0, x2: this.axis.area("width"), y1: 0, y2: 0 };
                } else if (position == "right") {
                    isDrawLine = this.checkDrawLineX(index, isLast);
                    area = { x1: 0, x2: -this.axis.area("width"), y1: 0, y2: 0 };
                }

                if (isDrawLine) {
                    var lineObject = this.line(_.extend({
                        stroke: this.chart.theme(isActive, "gridActiveBorderColor", "gridBorderColor"),
                        "stroke-width": this.chart.theme(isActive, "gridActiveBorderWidth", "gridBorderWidth")
                    }, area));

                    if (line.type.indexOf("dashed") > -1) {
                        var dash = this.chart.theme("gridBorderDashArray");

                        lineObject.attr({
                            "stroke-dasharray": dash == "none" || !dash ? "3,3" : dash
                        });
                    }

                    axis.append(lineObject);
                }
            };

            this.drawValueText = function (position, axis, index, xy, domain, move, isActive) {
                if (this.grid.hideText) return;

                if (position == "top") {
                    axis.append(this.getTextRotate(this.chart.text({
                        x: move,
                        y: -(this.chart.theme("gridTickBorderSize") + this.chart.theme("gridTickPadding") * 2),
                        dy: this.chart.theme("gridXFontSize") / 3,
                        fill: this.chart.theme(isActive, "gridActiveFontColor", "gridXFontColor"),
                        "text-anchor": "middle",
                        "font-size": this.chart.theme("gridXFontSize"),
                        "font-weight": this.chart.theme("gridXFontWeight")
                    }, domain)));
                } else if (position == "bottom") {
                    axis.append(this.getTextRotate(this.chart.text({
                        x: move,
                        y: this.chart.theme("gridTickBorderSize") + this.chart.theme("gridTickPadding") * 2,
                        dy: this.chart.theme("gridXFontSize") / 3,
                        fill: this.chart.theme(isActive, "gridActiveFontColor", "gridXFontColor"),
                        "text-anchor": "middle",
                        "font-size": this.chart.theme("gridXFontSize"),
                        "font-weight": this.chart.theme("gridXFontWeight")
                    }, domain)));
                } else if (position == "left") {
                    axis.append(this.getTextRotate(this.chart.text({
                        x: -this.chart.theme("gridTickBorderSize") - this.chart.theme("gridTickPadding"),
                        y: move,
                        dy: this.chart.theme("gridYFontSize") / 3,
                        fill: this.chart.theme(isActive, "gridActiveFontColor", "gridYFontColor"),
                        "text-anchor": "end",
                        "font-size": this.chart.theme("gridYFontSize"),
                        "font-weight": this.chart.theme("gridYFontWeight")
                    }, domain)));
                } else if (position == "right") {
                    axis.append(this.getTextRotate(this.chart.text({
                        x: this.chart.theme("gridTickBorderSize") + this.chart.theme("gridTickPadding"),
                        y: move,
                        dy: this.chart.theme("gridYFontSize") / 3,
                        fill: this.chart.theme(isActive, "gridActiveFontColor", "gridYFontColor"),
                        "text-anchor": "start",
                        "font-size": this.chart.theme("gridYFontSize"),
                        "font-weight": this.chart.theme("gridYFontWeight")
                    }, domain)));
                }
            };

            this.drawImage = function (orient, g, tick, index, x, y) {
                if (!_.typeCheck("function", this.grid.image)) return;

                var opts = this.grid.image.apply(this.chart, [tick, index]);

                if (_.typeCheck("object", opts)) {
                    var image = this.chart.svg.image({
                        "xlink:href": opts.uri,
                        width: opts.width,
                        height: opts.height
                    });

                    if (orient == "top" || orient == "bottom") {
                        image.attr({
                            x: this.grid.type == "block" ? this.scale.rangeBand() / 2 - opts.width / 2 : -(opts.width / 2)
                        });
                    } else if (orient == "left" || orient == "right") {
                        image.attr({
                            y: this.grid.type == "block" ? this.scale.rangeBand() / 2 - opts.height / 2 : -(opts.height / 2)
                        });
                    }

                    if (orient == "bottom") {
                        image.attr({ y: opts.dist });
                    } else if (orient == "top") {
                        image.attr({ y: -(opts.dist + opts.height) });
                    } else if (orient == "left") {
                        image.attr({ x: -(opts.dist + opts.width) });
                    } else if (orient == "right") {
                        image.attr({ x: opts.dist });
                    }

                    image.translate(x, y);
                    g.append(image);
                }
            };
        };

        return Draw2DGrid;
    }
};

jui$1.use(draw, grid$1, line, point);

var draw3d = {
    name: "chart.grid.draw3d",
    extend: "chart.draw",
    component: function component() {
        var _ = jui$1.include("util.base");
        var GridPolygon = jui$1.include("chart.polygon.grid");
        var LinePolygon = jui$1.include("chart.polygon.line");
        var PointPolygon = jui$1.include("chart.polygon.point");

        var Draw3DGrid = function Draw3DGrid() {

            this.createGridX = function (position, index, x, isActive, isLast) {
                var line$$1 = this.getLineOption(),
                    axis = this.svg.group();

                if (line$$1) {
                    this.drawValueLine(position, axis, isActive, line$$1, index, x, isLast);
                }

                return axis;
            };

            this.createGridY = function (position, index, y, isActive, isLast) {
                var line$$1 = this.getLineOption(),
                    axis = this.svg.group();

                if (line$$1) {
                    this.drawValueLine(position, axis, isActive, line$$1, index, y, isLast);
                }

                return axis;
            };

            /**
             * @method center
             *
             * draw center
             *
             * @param {chart.util.svg} g
             * @param {Array} ticks
             * @param {Array} values
             * @param {Number} min
             * @param {Function} checkActive
             */
            this.drawCenter = function (g, ticks, values, checkActive, moveZ) {
                var axis = this.svg.group(),
                    line$$1 = this.getLineOption();

                if (line$$1) {
                    this.drawValueLineCenter(axis, ticks, line$$1);
                }

                this.drawValueTextCenter(axis, ticks, values, checkActive, moveZ);

                g.append(axis);
            };

            this.drawBaseLine = function (position, g) {
                var axis = this.svg.group();
                this.drawAxisLine(position, axis);

                g.append(axis);
            };

            /**
             * @method axisLine
             * theme 이 적용된  axis line 리턴
             * @param {ChartBuilder} chart
             * @param {Object} attr
             */
            this.drawAxisLine = function (position, axis) {
                var isTopOrBottom = position == "top" || position == "bottom",
                    borderColor = isTopOrBottom ? "gridXAxisBorderColor" : "gridYAxisBorderColor",
                    borderWidth = isTopOrBottom ? "gridXAxisBorderWidth" : "gridYAxisBorderWidth";

                if (position == "center") {
                    borderColor = "gridZAxisBorderColor";
                    borderWidth = "gridZAxisBorderWidth";
                }

                var face = this.svg.polygon({
                    stroke: this.chart.theme(borderColor),
                    "stroke-width": this.chart.theme(borderWidth),
                    "stroke-opacity": 1,
                    fill: this.chart.theme("gridFaceBackgroundColor"),
                    "fill-opacity": this.chart.theme("gridFaceBackgroundOpacity")
                });

                var p = null,
                    w = this.axis.area("width"),
                    h = this.axis.area("height"),
                    x = this.axis.area("x"),
                    y = this.axis.area("y"),
                    d = this.axis.depth;

                if (position == "center") {
                    p = new GridPolygon("center", w, h, d, x, y);
                } else {
                    if (isTopOrBottom) {
                        h = position == "bottom" ? h : 0;
                        p = new GridPolygon("horizontal", w, h, d, x, y);
                    } else {
                        w = position == "right" ? w : 0;
                        p = new GridPolygon("vertical", w, h, d, x, y);
                    }
                }

                // 사각면 위치 계산 및 추가
                this.calculate3d(p);
                for (var i = 0; i < p.vectors.length; i++) {
                    face.point(p.vectors[i].x, p.vectors[i].y);
                }

                // Y축이 숨김 상태일 때
                if (position == "center") {
                    if (this.axis.get("y").hide !== true) {
                        axis.append(face);
                    }
                } else {
                    axis.append(face);
                }
            };

            this.drawValueLine = function (position, axis, isActive, line$$1, index, xy, isLast) {
                var isDrawLine = false,
                    w = this.axis.area("width"),
                    h = this.axis.area("height"),
                    x = this.axis.area("x"),
                    y = this.axis.area("y"),
                    d = this.axis.depth,
                    l1 = null,
                    l2 = null;

                if (position == "top") {
                    isDrawLine = this.checkDrawLineY(index, isLast);
                    l1 = new LinePolygon(xy, y, 0, xy, y, d);
                    l2 = new LinePolygon(xy, y, d, xy, y + h, d);
                } else if (position == "bottom") {
                    isDrawLine = this.checkDrawLineY(index, isLast);
                    l1 = new LinePolygon(xy, y + h, 0, xy, y + h, d);
                    l2 = new LinePolygon(xy, y + h, d, xy, y, d);
                } else if (position == "left") {
                    isDrawLine = this.checkDrawLineX(index, isLast);
                    l1 = new LinePolygon(x, xy, 0, x, xy, d);
                    l2 = new LinePolygon(x, xy, d, x + w, xy, d);
                } else if (position == "right") {
                    isDrawLine = this.checkDrawLineX(index, isLast);
                    l1 = new LinePolygon(x + w, xy, 0, x + w, xy, d);
                    l2 = new LinePolygon(x + w, xy, d, x, xy, d);
                }

                if (isDrawLine) {
                    // 폴리곤 계산
                    this.calculate3d(l1, l2);

                    var lo1 = this.line({
                        stroke: this.chart.theme("gridBorderColor"),
                        "stroke-width": this.chart.theme("gridBorderWidth"),
                        x1: l1.vectors[0].x,
                        y1: l1.vectors[0].y,
                        x2: l1.vectors[1].x,
                        y2: l1.vectors[1].y
                    });

                    var lo2 = this.line({
                        stroke: this.chart.theme("gridBorderColor"),
                        "stroke-width": this.chart.theme("gridBorderWidth"),
                        x1: l2.vectors[0].x,
                        y1: l2.vectors[0].y,
                        x2: l2.vectors[1].x,
                        y2: l2.vectors[1].y
                    });

                    if (line$$1.type.indexOf("dashed") > -1) {
                        var dash = this.chart.theme("gridBorderDashArray"),
                            style = dash == "none" || !dash ? "3,3" : dash;

                        lo1.attr({ "stroke-dasharray": style });
                        lo2.attr({ "stroke-dasharray": style });
                    }

                    axis.append(lo1);

                    // Y축이 숨김 상태가 아닐 때만 추가
                    if (this.axis.get("y").hide !== true) {
                        axis.append(lo2);
                    }
                }
            };

            this.drawValueLineCenter = function (axis, ticks, line$$1) {
                var len = this.grid.type != "block" ? ticks.length - 1 : ticks.length,
                    w = this.axis.area("width"),
                    h = this.axis.area("height"),
                    x = this.axis.area("x"),
                    y = this.axis.area("y"),
                    d = this.axis.depth,
                    dx = this.axis.get("y").orient == "left" ? 0 : w,
                    dy = this.axis.get("x").orient == "top" ? 0 : h;

                // z축 라인 드로잉
                for (var i = 1; i < len; i++) {
                    var t = i * (d / len),
                        p1 = new LinePolygon(x, y + dy, t, x + w, y + dy, t),
                        p2 = new LinePolygon(x + dx, y, t, x + dx, y + h, t);

                    this.calculate3d(p1, p2);

                    var lo1 = this.line({
                        stroke: this.chart.theme("gridBorderColor"),
                        "stroke-width": this.chart.theme("gridBorderWidth"),
                        x1: p1.vectors[0].x,
                        y1: p1.vectors[0].y,
                        x2: p1.vectors[1].x,
                        y2: p1.vectors[1].y
                    });

                    var lo2 = this.line({
                        stroke: this.chart.theme("gridBorderColor"),
                        "stroke-width": this.chart.theme("gridBorderWidth"),
                        x1: p2.vectors[0].x,
                        y1: p2.vectors[0].y,
                        x2: p2.vectors[1].x,
                        y2: p2.vectors[1].y
                    });

                    if (line$$1.type.indexOf("dashed") > -1) {
                        var dash = this.chart.theme("gridBorderDashArray"),
                            style = dash == "none" || !dash ? "3,3" : dash;

                        lo1.attr({ "stroke-dasharray": style });
                        lo2.attr({ "stroke-dasharray": style });
                    }

                    axis.append(lo1);

                    // Y축이 숨김 상태가 아닐 때만 추가
                    if (this.axis.get("y").hide !== true) {
                        axis.append(lo2);
                    }
                }
            };

            this.drawValueText = function (position, axis, index, xy, domain) {
                if (this.grid.hideText) return;

                var isVertical = position == "left" || position == "right";

                var tickSize = this.chart.theme("gridTickBorderSize"),
                    tickPadding = this.chart.theme("gridTickPadding"),
                    w = this.axis.area("width"),
                    h = this.axis.area("height"),
                    dx = this.axis.area("x"),
                    dy = this.axis.area("y"),
                    x = 0,
                    y = 0;

                if (position == "top") {
                    x = xy;
                    y = dy + -(tickSize + tickPadding * 2);
                } else if (position == "bottom") {
                    x = xy;
                    y = dy + (h + tickSize + tickPadding * 2);
                } else if (position == "left") {
                    x = dx + -(tickSize + tickPadding);
                    y = xy;
                } else if (position == "right") {
                    x = dx + (w + tickSize + tickPadding);
                    y = xy;
                }

                var p = new PointPolygon(x, y, 0);
                this.calculate3d(p);

                axis.append(this.getTextRotate(this.chart.text({
                    x: p.vectors[0].x,
                    y: p.vectors[0].y,
                    dx: !isVertical ? this.chart.theme("gridXFontSize") / 3 : 0,
                    dy: isVertical ? this.chart.theme("gridYFontSize") / 3 : 0,
                    fill: this.chart.theme(isVertical ? "gridYFontColor" : "gridXFontColor"),
                    "text-anchor": isVertical ? position == "left" ? "end" : "start" : "middle",
                    "font-size": this.chart.theme(isVertical ? "gridYFontSize" : "gridXFontSize"),
                    "font-weight": this.chart.theme(isVertical ? "gridYFontWeight" : "gridXFontWeight")
                }, domain)));
            };

            this.drawValueTextCenter = function (axis, ticks, values, checkActive, moveZ) {
                if (this.grid.hideText) return;

                var margin = this.chart.theme("gridTickBorderSize") + this.chart.theme("gridTickPadding"),
                    isLeft = this.axis.get("y").orient == "left",
                    isTop = this.axis.get("x").orient == "top",
                    len = this.grid.type != "block" ? ticks.length - 1 : ticks.length,
                    w = this.axis.area("width"),
                    h = this.axis.area("height"),
                    d = this.axis.depth,
                    x = this.axis.area("x") + (isLeft ? w + margin : -margin),
                    y = this.axis.area("y") + (isTop ? -margin : h + margin);

                // z축 라인 드로잉
                for (var i = 0; i < ticks.length; i++) {
                    var domain = this.format(ticks[i], i),
                        t = i * (d / len) + moveZ,
                        p = new PointPolygon(x, y, t);

                    this.calculate3d(p);

                    axis.append(this.getTextRotate(this.chart.text({
                        x: p.vectors[0].x,
                        y: p.vectors[0].y,
                        fill: this.chart.theme("gridZFontColor"),
                        "text-anchor": isLeft ? "start" : "end",
                        "font-size": this.chart.theme("gridZFontSize"),
                        "font-weight": this.chart.theme("gridZFontWeight")
                    }, domain)));
                }
            };

            this.drawPattern = function () {};
            this.drawImage = function () {};
        };

        return Draw3DGrid;
    }
};

jui$1.use([math, draw, draw2d, draw3d]);

var CoreGrid = {
    name: "chart.grid.core",
    extend: "chart.draw",
    component: function component() {
        var _ = jui$1.include("util.base");
        var math$$1 = jui$1.include("util.math");
        var Draw2D = jui$1.include("chart.grid.draw2d");
        var Draw3D = jui$1.include("chart.grid.draw3d");

        var CoreGrid = function CoreGrid() {

            /**
             * @method wrapper
             * scale wrapper
             *
             * grid 의 x 좌표 값을 같은 형태로 가지고 오기 위한 wrapper 함수
             *
             * grid 속성에 key 가 있다면  key 의 속성값으로 실제 값을 처리
             *
             *      @example
             *      // 그리드 속성에 키가 없을 때
             *      scale(0);		// 0 인덱스에 대한 값  (block, radar)
             *      // grid 속성에 key 가 있을 때
             *      grid { key : "field" }
             *      scale(0)			// field 값으로 scale 설정 (range, date)
             *
             * @protected
             */
            this.wrapper = function (scale, key) {
                return scale;
            };

            /**
             * @method line
             * theme 이 적용된  line 리턴
             * @protected
             * @param {ChartBuilder} chart
             * @param {Object} attr
             */
            this.line = function (attr) {
                return this.chart.svg.line(_.extend({
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                    stroke: this.color("gridBorderColor"),
                    "stroke-width": this.chart.theme("gridBorderWidth"),
                    "stroke-dasharray": this.chart.theme("gridBorderDashArray"),
                    "stroke-opacity": this.chart.theme("gridBorderOpacity")
                }, attr));
            };

            /**
             * @method color
             * grid 에서 color 를 위한 유틸리티 함수
             * @param theme
             * @return {Mixed}
             */
            this.color = function (theme) {
                var color = this.grid.color;

                if (arguments.length == 3) {
                    return color != null ? this.chart.color(color) : this.chart.theme.apply(this.chart, arguments);
                }

                return color != null ? this.chart.color(color) : this.chart.theme(theme);
            };

            /**
             * @method data
             * get data for axis
             * @protected
             * @param {Number} index
             * @param {String} field
             */
            this.data = function (index, field) {
                if (this.axis.data && this.axis.data[index]) {
                    return this.axis.data[index][field] || this.axis.data[index];
                }

                return this.axis.data || [];
            };

            this.getGridSize = function () {
                var orient = this.grid.orient,
                    depth = this.axis.depth,
                    degree = this.axis.degree,
                    axis = orient == "left" || orient == "right" ? this.axis.area("y") : this.axis.area("x"),
                    max = orient == "left" || orient == "right" ? this.axis.area("height") : this.axis.area("width"),
                    start = axis,
                    size = max,
                    end = start + size;

                var result = {
                    start: start,
                    size: size,
                    end: end
                };

                if (!this.axis.isFull3D()) {
                    if (depth > 0 || degree > 0) {
                        var radian = math$$1.radian(360 - degree),
                            x2 = Math.cos(radian) * depth,
                            y2 = Math.sin(radian) * depth;

                        if (orient == "left") {
                            result.start = result.start - y2;
                            result.size = result.size - y2;
                        } else if (orient == "bottom") {
                            result.end = result.end - x2;
                            result.size = result.size - x2;
                        }
                    }
                } else {
                    if (orient == "center") {
                        // z축
                        result.start = 0;
                        result.size = depth;
                        result.end = depth;
                    }
                }

                return result;
            };

            /**
             * @method getDefaultOffset
             *
             * get real size of grid
             *
             * @param {chart.builder} chart
             * @param {Strng} orient
             * @param {Object} grid             그리드 옵션
             * @return {Object}
             * @return {Number} return.start    시작 지점
             * @return {Number} return.size     그리드 넓이 또는 높이
             * @return {Number} return.end      마지막 지점
             */
            this.getDefaultOffset = function () {
                var orient = this.grid.orient,
                    area = this.axis.area();

                var width = area.width,
                    height = area.height,
                    axis = orient == "left" || orient == "right" ? area.y : area.x,
                    max = orient == "left" || orient == "right" ? height : width,
                    start = axis,
                    size = max,
                    end = start + size;

                return {
                    start: start,
                    size: size,
                    end: end
                };
            };

            /**
             * @method getTextRotate
             * implement text rotate in grid text
             * @protected
             * @param {SVGElement} textElement
             */
            this.getTextRotate = function (textElement) {
                var rotate = this.grid.textRotate;

                if (rotate == null) {
                    return textElement;
                }

                if (_.typeCheck("function", rotate)) {
                    rotate = rotate.apply(this.chart, [textElement]);
                }

                var x = textElement.attr("x");
                var y = textElement.attr("y");

                textElement.rotate(rotate, x, y);

                return textElement;
            };

            this.getLineOption = function () {
                var line = this.grid.line;

                if (typeof line === "string") {
                    line = { type: line || "solid" };
                } else if (typeof line === "number") {
                    line = { type: "solid", "stroke-width": line };
                } else if ((typeof line === "undefined" ? "undefined" : _typeof(line)) !== "object") {
                    line = !!line;

                    if (line) {
                        line = { type: "solid" };
                    }
                }

                if (line && !line.type == "string") {
                    line.type = line.type.split(/ /g);
                }

                return line;
            };

            this.checkDrawLineY = function (index, isLast) {
                var y = this.axis.get("y");

                if (!y.hide) {
                    if (y.orient == "left" && index == 0 && !this.grid.realtime) {
                        return false;
                    } else if (y.orient == "right" && isLast) {
                        return false;
                    }
                }

                return true;
            };

            this.checkDrawLineX = function (index, isLast) {
                var x = this.axis.get("x");

                if (!x.hide) {
                    if (x.orient == "top" && index == 0) {
                        return false;
                    } else if (x.orient == "bottom" && isLast && !this.grid.realtime) {
                        return false;
                    }
                }

                return true;
            };

            /**
             * @method top
             *
             * draw top
             *
             * @param {chart.util.svg} g
             * @param {Array} ticks
             * @param {Array} values
             * @param {Number} min
             * @param {Function} checkActive
             */
            this.drawTop = function (g, ticks, values, checkActive, moveX) {
                for (var i = 0, len = ticks.length; i < len; i++) {
                    var domain = this.format(ticks[i], i),
                        x = values[i] - moveX,
                        isLast = i == len - 1 && this.grid.type != "block",
                        isActive = false;

                    // 그리드 이미지 그리기
                    this.drawImage("top", g, ticks[i], i, x, 0);

                    // 도메인이 없으면 그리지 않음
                    if (!domain && domain !== 0) {
                        continue;
                    }

                    // 액티브 라인 체크
                    if (_.typeCheck("function", checkActive)) {
                        isActive = checkActive(ticks[i]);
                    }

                    var axis = this.createGridX("top", i, x, isActive, isLast);
                    this.drawValueText("top", axis, i, values[i], domain, moveX, isActive);

                    g.append(axis);
                }
            };

            this.drawBottom = function (g, ticks, values, checkActive, moveX) {
                for (var i = 0, len = ticks.length; i < len; i++) {
                    var domain = this.format(ticks[i], i),
                        x = values[i] - moveX,
                        isLast = i == len - 1 && this.grid.type != "block",
                        isActive = false;

                    // 그리드 이미지 그리기
                    this.drawImage("bottom", g, ticks[i], i, x, 0);

                    // 도메인이 없으면 그리지 않음
                    if (!domain && domain !== 0) {
                        continue;
                    }

                    // 액티브 라인 체크
                    if (_.typeCheck("function", checkActive)) {
                        isActive = checkActive(ticks[i]);
                    }

                    var axis = this.createGridX("bottom", i, x, isActive, isLast);
                    this.drawValueText("bottom", axis, i, values[i], domain, moveX, isActive);

                    g.append(axis);
                }
            };

            this.drawLeft = function (g, ticks, values, checkActive, moveY) {
                for (var i = 0, len = ticks.length; i < len; i++) {
                    var domain = this.format(ticks[i], i),
                        y = values[i] - moveY,
                        isLast = i == len - 1 && this.grid.type != "block",
                        isActive = false;

                    // 그리드 이미지 그리기
                    this.drawImage("left", g, ticks[i], i, 0, y);

                    // 도메인이 없으면 그리지 않음
                    if (!domain && domain !== 0) {
                        continue;
                    }

                    // 액티브 라인 체크
                    if (_.typeCheck("function", checkActive)) {
                        isActive = checkActive(ticks[i]);
                    }

                    var axis = this.createGridY("left", i, y, isActive, isLast);
                    this.drawValueText("left", axis, i, values[i], domain, moveY, isActive);

                    g.append(axis);
                }
            };

            this.drawRight = function (g, ticks, values, checkActive, moveY) {
                for (var i = 0, len = ticks.length; i < len; i++) {
                    var domain = this.format(ticks[i], i),
                        y = values[i] - moveY,
                        isLast = i == len - 1 && this.grid.type != "block",
                        isActive = false;

                    // 그리드 이미지 그리기
                    this.drawImage("right", g, ticks[i], i, 0, y);

                    // 도메인이 없으면 그리지 않음
                    if (!domain && domain !== 0) {
                        continue;
                    }

                    // 액티브 라인 체크
                    if (_.typeCheck("function", checkActive)) {
                        isActive = checkActive(ticks[i]);
                    }

                    var axis = this.createGridY("right", i, y, isActive, isLast);
                    this.drawValueText("right", axis, i, values[i], domain, moveY, isActive);

                    g.append(axis);
                }
            };

            /**
             * @method drawGrid
             * draw base grid structure
             * @protected
             * @param {chart.builder} chart
             * @param {String} orient
             * @param {String} cls
             * @param {Grid} grid
             */
            this.drawGrid = function () {
                // create group
                var root = this.chart.svg.group(),
                    func = this[this.grid.orient],
                    draw$$1 = this.axis.isFull3D() ? Draw3D : Draw2D;

                // wrapped scale
                this.scale = this.wrapper(this.scale, this.grid.key);

                // render axis
                if (_.typeCheck("function", func)) {
                    draw$$1.call(this);
                    func.call(this, root);
                }

                // hide grid
                if (this.grid.hide) {
                    root.attr({ display: "none" });
                }

                return {
                    root: root,
                    scale: this.scale
                };
            };

            /**
             * @method drawAfter
             *
             * @param {Object} obj
             * @protected
             */
            this.drawAfter = function (obj) {
                obj.root.attr({ "class": "grid-" + this.grid.type });
                obj.root.translate(this.chart.area("x"), this.chart.area("y"));
            };
        };

        CoreGrid.setup = function () {

            /** @property {chart.builder} chart */
            /** @property {chart.axis} axis */
            /** @property {Object} grid */

            return {
                /**  @cfg {Number} [dist=0] Able to change the locatn of an axis.  */
                dist: 0,
                /**  @cfg {"top"/"left"/"bottom"/"right"} [orient=null] Specifies the direction in which an axis is shown (top, bottom, left or right). */
                orient: null,
                /** @cfg {Boolean} [hide=false] Determines whether to display an applicable grid.  */
                hide: false,
                /** @cfg {String/Object/Number} [color=null] Specifies the color of a grid. */
                color: null,
                /** @cfg {String} [title=null] Specifies the text shown on a grid.*/
                title: null,
                /** @cfg {Boolean} [hide=false] Determines whether to display a line on the axis background. */
                line: false,
                /** @cfg {Function} [format=null]  Determines whether to format the value on an axis. */
                format: null,
                /** @cfg {Function} [image=null]  Determines whether to image the value on an axis. */
                image: null,
                /** @cfg {Number} [textRotate=null] Specifies the slope of text displayed on a grid. */
                textRotate: null
            };
        };

        return CoreGrid;
    }
};

var BlockGrid = {
    name: "chart.grid.block",
    extend: "chart.grid.core",
    component: function component() {
        var _ = jui$1.include("util.base");
        var UtilScale = jui$1.include("util.scale");

        var BlockGrid = function BlockGrid() {
            this.center = function (g) {
                this.drawCenter(g, this.domain, this.points, null, this.half_band);
                this.drawBaseLine("center", g);
            };

            this.top = function (g) {
                this.drawPattern("top", this.domain, this.points, true);
                this.drawTop(g, this.domain, this.points, null, this.half_band);
                this.drawBaseLine("top", g);
                g.append(this.createGridX("top", this.domain.length, this.end, null, true));
            };

            this.bottom = function (g) {
                this.drawPattern("bottom", this.domain, this.points, true);
                this.drawBottom(g, this.domain, this.points, null, this.half_band);
                this.drawBaseLine("bottom", g);
                g.append(this.createGridX("bottom", this.domain.length, this.end, null, true));
            };

            this.left = function (g) {
                this.drawPattern("left", this.domain, this.points, true);
                this.drawLeft(g, this.domain, this.points, null, this.half_band);
                this.drawBaseLine("left", g);
                g.append(this.createGridY("left", this.domain.length, this.end, null, true));
            };

            this.right = function (g) {
                this.drawPattern("right", this.domain, this.points, true);
                this.drawRight(g, this.domain, this.points, null, this.half_band);
                this.drawBaseLine("right", g);
                g.append(this.createGridY("right", this.domain.length, this.end, null, true));
            };

            this.initDomain = function () {
                var domain = [];

                if (_.typeCheck("string", this.grid.domain)) {
                    var field = this.grid.domain;
                    var data = this.data();

                    if (this.grid.reverse) {
                        var start = data.length - 1,
                            end = 0,
                            step = -1;
                    } else {
                        var start = 0,
                            end = data.length - 1,
                            step = 1;
                    }

                    for (var i = start; this.grid.reverse ? i >= end : i <= end; i += step) {
                        domain.push(data[i][field]);
                    }
                } else if (_.typeCheck("function", this.grid.domain)) {
                    // block 은 배열을 통째로 리턴함
                    domain = this.grid.domain.call(this.chart);
                } else if (_.typeCheck("array", this.grid.domain)) {
                    domain = this.grid.domain;
                }

                if (this.grid.reverse) {
                    domain.reverse();
                }

                return domain;
            };

            this.wrapper = function (scale, key) {
                var old_scale = scale;
                var self = this;
                var len = self.domain.length;
                var reverse = self.grid.reverse;

                function new_scale(i) {
                    if (typeof i == 'number' && key) {
                        return old_scale(self.axis.data[i][key]);
                    } else {
                        return old_scale(reverse ? len - i - 1 : i);
                    }
                }

                return key ? _.extend(new_scale, old_scale) : old_scale;
            };

            this.drawBefore = function () {
                var domain = this.initDomain(),
                    obj = this.getGridSize(),
                    range = [obj.start, obj.end];

                // scale 설정
                this.scale = UtilScale.ordinal().domain(domain);
                this.scale.rangePoints(range);

                this.start = obj.start;
                this.size = obj.size;
                this.end = obj.end;
                this.points = this.scale.range();
                this.domain = this.scale.domain();

                this.band = this.scale.rangeBand();
                this.half_band = this.band / 2;
                this.bar = 6;
                this.reverse = this.grid.reverse;
            };

            this.draw = function () {
                return this.drawGrid("block");
            };
        };

        BlockGrid.setup = function () {
            return {
                /** @cfg {String/Array/Function} [domain=null] Sets the value displayed on an axis.*/
                domain: null,
                /** @cfg {Boolean} [reverse=false] Reverses the value on domain values*/
                reverse: false,
                /** @cfg {Number} [max=10] Sets the maximum value of a grid. */
                max: 10,
                /** @cfg {Boolean} [hideText=false] Determines whether to show text across the grid. */
                hideText: false,
                /** @cfg {String} [key=null] Sets the value on the grid to the value for the specified key. */
                key: null
            };
        };

        return BlockGrid;
    }
};

var DateGrid = {
    name: "chart.grid.date",
    extend: "chart.grid.core",
    component: function component() {
        var _ = jui$1.include("util.base");
        var UtilScale = jui$1.include("util.scale");
        var UtilTime = jui$1.include("util.time");

        var DateGrid = function DateGrid() {

            this.center = function (g) {
                this.drawCenter(g, this.ticks, this.values, null, 0);
                this.drawBaseLine("center", g);
            };

            this.top = function (g) {
                this.drawPattern("top", this.ticks, this.values);
                this.drawTop(g, this.ticks, this.values, null, 0);
                this.drawBaseLine("top", g);
            };

            this.bottom = function (g) {
                this.drawPattern("bottom", this.ticks, this.values);
                this.drawBottom(g, this.ticks, this.values, null, 0);
                this.drawBaseLine("bottom", g);
            };

            this.left = function (g) {
                this.drawPattern("left", this.ticks, this.values);
                this.drawLeft(g, this.ticks, this.values, null, 0);
                this.drawBaseLine("left", g);
            };

            this.right = function (g) {
                this.drawPattern("right", this.ticks, this.values);
                this.drawRight(g, this.ticks, this.values, null, 0);
                this.drawBaseLine("right", g);
            };

            this.wrapper = function (scale, key) {
                var old_scale = scale;
                var self = this;

                function new_scale(i) {
                    if (typeof i == 'number') {
                        return old_scale(self.axis.data[i][key]);
                    } else {
                        return old_scale(+i);
                    }
                }

                return key ? _.extend(new_scale, old_scale) : old_scale;
            };

            this.initDomain = function () {
                var domain = [],
                    interval = [];
                var min = this.grid.min || undefined,
                    max = this.grid.max || undefined;
                var data = this.data(),
                    value_list = [];

                if (_.typeCheck("string", this.grid.domain)) {
                    if (data.length > 0) {
                        var field = this.grid.domain;
                        value_list.push(+data[0][field]);
                        value_list.push(+data[data.length - 1][field]);
                    }
                } else if (_.typeCheck("function", this.grid.domain)) {
                    var index = data.length;

                    while (index--) {
                        var value = this.grid.domain.call(this.chart, data[index]);

                        if (_.typeCheck("array", value)) {
                            value_list[index] = Math.max.apply(Math, value);
                            value_list.push(Math.min.apply(Math, value));
                        } else {
                            value_list[index] = value;
                        }
                    }
                } else {
                    value_list = this.grid.domain;
                }

                if (_.typeCheck("undefined", min) && value_list.length > 0) min = Math.min.apply(Math, value_list);
                if (_.typeCheck("undefined", max) && value_list.length > 0) max = Math.max.apply(Math, value_list);

                domain = [min, max];
                interval = this.grid.interval;

                if (this.grid.reverse) {
                    domain.reverse();
                }

                if (_.typeCheck("function", interval)) {
                    this.interval = interval.call(this.chart, domain);
                } else {
                    this.interval = interval;
                }

                return domain;
            };

            this.drawBefore = function () {
                var domain = this.initDomain();

                var obj = this.getGridSize(),
                    range = [obj.start, obj.end];

                this.scale = UtilScale.time().domain(domain).range(range);

                this.scale.clamp(this.grid.clamp);

                // 기본값 설정
                this.ticks = [];

                if (this.grid.realtime != null && UtilTime[this.grid.realtime] == this.grid.realtime) {
                    var ticks = this.scale.realTicks(this.grid.realtime, this.interval);
                } else {
                    var ticks = this.scale.ticks("milliseconds", this.interval);
                }

                /* data 없을 때도 기본 설정만으로 보여야 하기 때문에. 지우겠음
                if (this.axis.data.length == 0) {
                    //this.ticks = [];
                } */

                if (typeof this.grid.format == "string") {
                    (function (grid, str) {
                        grid.format = function (value) {
                            return UtilTime.format(value, str);
                        };
                    })(this.grid, this.grid.format);
                }

                // interval = [this.time.days, 1];
                this.start = obj.start;
                this.size = obj.size;
                this.end = obj.end;
                this.bar = 6;
                this.values = [];

                for (var i = 0, len = ticks.length; i < len; i++) {
                    var value = this.scale(ticks[i]);

                    if (value >= obj.start && value <= obj.end) {
                        this.values.push(value);
                        this.ticks.push(ticks[i]);
                    }
                }
            };

            this.draw = function () {
                return this.drawGrid("date");
            };
        };

        DateGrid.setup = function () {
            return {
                /** @cfg {Array} [domain=null] Sets the value displayed on a grid. */
                domain: null,
                /** @cfg {Number} [interval=1000] Sets the interval of the scale displayed on a grid.*/
                interval: 1000,
                /** @cfg {Number} [min=null] Sets the minimum timestamp of a grid.  */
                min: null,
                /** @cfg {Number} [max=null] Sets the maximum timestamp of a grid. */
                max: null,
                /** @cfg {Boolean} [reverse=false] Reverses the value on domain values*/
                reverse: false,
                /** @cfg {String} [key=null] Sets the value on the grid to the value for the specified key. */
                key: null,
                /** @cfg {"years"/"months"/"days"/"hours"/"minutes"/"seconds"/"milliseconds"} [realtime=""] Determines whether to use as a real-time grid. */
                realtime: null,
                /** @cfg {Boolean} [hideText=false] Determines whether to show text across the grid. */
                hideText: false
            };
        };

        return DateGrid;
    }
};

var DateBlockGrid = {
    name: "chart.grid.dateblock",
    extend: "chart.grid.date",
    component: function component() {
        var _ = jui$1.include("util.base");
        var UtilScale = jui$1.include("util.scale");
        var UtilTime = jui$1.include("util.time");

        var DateBlockGrid = function DateBlockGrid() {

            this.wrapper = function (scale, key) {
                var old_scale = scale;
                var self = this;

                old_scale.rangeBand = function () {
                    return self.grid.unit;
                };

                return old_scale;
            };

            this.initDomain = function () {
                var domain = [],
                    interval = [];
                var min = this.grid.min || undefined,
                    max = this.grid.max || undefined;
                var data = this.data(),
                    value_list = [];

                if (_.typeCheck("string", this.grid.domain)) {
                    var field = this.grid.domain;
                    value_list.push(+data[0][field]);
                    value_list.push(+data[data.length - 1][field]);
                } else if (_.typeCheck("function", this.grid.domain)) {
                    var index = data.length;

                    while (index--) {
                        var value = this.grid.domain.call(this.chart, data[index]);

                        if (_.typeCheck("array", value)) {
                            value_list[index] = +Math.max.apply(Math, value);
                            value_list.push(+Math.min.apply(Math, value));
                        } else {
                            value_list[index] = +value;
                        }
                    }
                } else {
                    value_list = this.grid.domain;
                }

                if (_.typeCheck("undefined", min)) min = Math.min.apply(Math, value_list);
                if (_.typeCheck("undefined", max)) max = Math.max.apply(Math, value_list);

                domain = [min, max];
                interval = this.grid.interval;

                if (this.grid.reverse) {
                    domain.reverse();
                }

                if (_.typeCheck("function", interval)) {
                    domain.interval = interval.call(this.chart, domain);
                } else {
                    domain.interval = interval;
                }

                return domain;
            };

            this.drawBefore = function () {
                var domain = this.initDomain(),
                    obj = this.getGridSize(),
                    range = [obj.start, obj.end],
                    time = UtilScale.time().domain(domain).rangeRound(range);

                if (this.grid.realtime != null && UtilTime[this.grid.realtime] == this.grid.realtime) {
                    this.ticks = time.realTicks(this.grid.realtime, domain.interval);
                } else {
                    this.ticks = time.ticks("milliseconds", domain.interval);
                }

                var len = this.axis.data.length - 1;
                var unit = this.grid.unit = Math.abs(range[0] - range[1]) / len;

                if (typeof this.grid.format == "string") {
                    (function (grid, str) {
                        grid.format = function (value) {
                            return UtilTime.format(value, str);
                        };
                    })(this.grid, this.grid.format);
                }

                // interval = [this.time.days, 1];
                this.start = obj.start;
                this.size = obj.size;
                this.end = obj.end;
                this.bar = 6;
                this.values = [];

                for (var i = 0, len = this.ticks.length; i < len; i++) {
                    this.values[i] = time(this.ticks[i]);
                }

                var self = this;
                this.scale = _.extend(function (i) {
                    // area 시작 영역 추가
                    return self.start + i * unit;
                }, time);
            };

            this.draw = function () {
                return this.drawGrid("dateblock");
            };
        };

        return DateBlockGrid;
    }
};

var FullBlockGrid = {
    name: "chart.grid.fullblock",
    extend: "chart.grid.core",
    component: function component() {
        var _ = jui$1.include("util.base");
        var UtilScale = jui$1.include("util.scale");

        var FullBlockGrid = function FullBlockGrid() {
            this.center = function (g) {
                this.drawCenter(g, this.domain, this.points, null, 0);
                this.drawBaseLine("center", g);
            };

            this.top = function (g) {
                this.drawPattern("top", this.domain, this.points);
                this.drawTop(g, this.domain, this.points, null, 0);
                this.drawBaseLine("top", g);
            };

            this.bottom = function (g) {
                this.drawPattern("bottom", this.domain, this.points);
                this.drawBottom(g, this.domain, this.points, null, 0);
                this.drawBaseLine("bottom", g);
            };

            this.left = function (g) {
                this.drawPattern("left", this.domain, this.points);
                this.drawLeft(g, this.domain, this.points, null, 0);
                this.drawBaseLine("left", g);
            };

            this.right = function (g) {
                this.drawPattern("right", this.domain, this.points);
                this.drawRight(g, this.domain, this.points, null, 0);
                this.drawBaseLine("right", g);
            };

            this.initDomain = function () {
                var domain = [];

                if (_.typeCheck("string", this.grid.domain)) {
                    var field = this.grid.domain;
                    var data = this.data();

                    if (this.grid.reverse) {
                        var start = data.length - 1,
                            end = 0,
                            step = -1;
                    } else {
                        var start = 0,
                            end = data.length - 1,
                            step = 1;
                    }

                    for (var i = start; this.grid.reverse ? i >= end : i <= end; i += step) {
                        domain.push(data[i][field]);
                    }
                } else if (_.typeCheck("function", this.grid.domain)) {
                    // block 은 배열을 통째로 리턴함
                    domain = this.grid.domain.call(this.chart);
                } else if (_.typeCheck("array", this.grid.domain)) {
                    domain = this.grid.domain;
                }

                if (this.grid.reverse) {
                    domain.reverse();
                }

                return domain;
            };

            this.wrapper = function (scale, key) {
                var old_scale = scale;
                var self = this;
                var len = self.domain.length;
                var reverse = self.grid.reverse;

                function new_scale(i) {
                    if (typeof i == 'number' && key) {
                        return old_scale(self.axis.data[i][key]);
                    } else {
                        return old_scale(reverse ? len - i : i);
                    }
                }

                return key ? _.extend(new_scale, old_scale) : old_scale;
            };

            this.drawBefore = function () {
                var domain = this.initDomain();

                var obj = this.getGridSize();

                // scale 설정
                this.scale = UtilScale.ordinal().domain(domain);
                var range = [obj.start, obj.end];

                this.scale.rangeBands(range);

                this.start = obj.start;
                this.size = obj.size;
                this.end = obj.end;
                this.points = this.scale.range();
                this.domain = this.scale.domain();

                this.band = this.scale.rangeBand();
                this.half_band = 0;
                this.bar = 6;
                this.reverse = this.grid.reverse;
            };

            this.draw = function () {
                return this.drawGrid("fullblock");
            };
        };

        FullBlockGrid.setup = function () {
            return {
                /** @cfg {String/Array/Function} [domain=null] Sets the value displayed on an axis.*/
                domain: null,
                /** @cfg {Boolean} [reverse=false] Reverses the value on domain values*/
                reverse: false,
                /** @cfg {Number} [max=10] Sets the maximum value of a grid. */
                max: 10,
                /** @cfg {Boolean} [hideText=false] Determines whether to show text across the grid. */
                hideText: false
            };
        };

        return FullBlockGrid;
    }
};

jui$1.use([math]);

var RadarGrid = {
    name: "chart.grid.radar",
    extend: "chart.grid.core",
    component: function component() {
        var _ = jui$1.include("util.base");
        var math$$1 = jui$1.include("util.math");

        var RadarGrid = function RadarGrid() {
            var self = this,
                position = [];

            function drawCircle(root, centerX, centerY, x, y, count) {
                var r = Math.abs(y),
                    cx = centerX,
                    cy = centerY;

                root.append(self.chart.svg.circle({
                    cx: cx,
                    cy: cy,
                    r: r,
                    "fill-opacity": 0,
                    stroke: self.color("gridBorderColor"),
                    "stroke-width": self.chart.theme("gridBorderWidth")
                }));
            }

            function drawRadial(root, centerX, centerY, x, y, count, unit) {
                var g = self.chart.svg.group();
                var points = [];

                points.push([centerX + x, centerY + y]);

                var startX = x,
                    startY = y;

                for (var i = 0; i < count; i++) {
                    var obj = math$$1.rotate(startX, startY, unit);

                    startX = obj.x;
                    startY = obj.y;

                    points.push([centerX + obj.x, centerY + obj.y]);
                }

                var path = self.chart.svg.path({
                    "fill": "none",
                    stroke: self.color("gridBorderColor"),
                    "stroke-width": self.chart.theme("gridBorderWidth")
                });

                for (var i = 0; i < points.length; i++) {
                    var point = points[i];

                    if (i == 0) {
                        path.MoveTo(point[0], point[1]);
                    } else {
                        path.LineTo(point[0], point[1]);
                    }
                }

                path.LineTo(points[0][0], points[0][1]);
                //path.ClosePath();

                g.append(path);
                root.append(g);
            }

            function scale(obj) {
                var max = self.grid.max;

                var dx = self.chart.padding('left');
                var dy = self.chart.padding('top');

                return function (index, value) {
                    var rate = value / max;

                    var height = Math.abs(obj.y1) - Math.abs(obj.y2),
                        pos = height * rate,
                        unit = 2 * Math.PI / self.domain.length;

                    var cx = obj.x1,
                        cy = obj.y1,
                        y = -pos,
                        x = 0;

                    var o = math$$1.rotate(x, y, unit * index);

                    var result = {
                        x: dx + cx + o.x,
                        y: dy + cy + o.y
                    };

                    return result;
                };
            }

            this.initDomain = function () {
                var domain = [];
                if (_.typeCheck("string", this.grid.domain)) {
                    var field = this.grid.domain;
                    var data = this.data();

                    if (this.grid.reverse) {
                        var start = data.length - 1,
                            end = 0,
                            step = -1;
                    } else {
                        var start = 0,
                            end = data.length - 1,
                            step = 1;
                    }

                    for (var i = start; this.grid.reverse ? i >= end : i <= end; i += step) {
                        domain.push(data[i][field]);
                    }

                    //grid.domain = domain;
                } else if (_.typeCheck("function", this.grid.domain)) {
                    // block 은 배열을 통째로 리턴함
                    domain = this.grid.domain(this.chart, this.grid);
                } else {
                    domain = this.grid.domain;
                }

                if (this.grid.reverse) {
                    domain.reverse();
                }

                return domain;
            };

            this.drawBefore = function () {
                this.domain = this.initDomain();
            };

            this.draw = function () {
                var width = this.axis.area('width'),
                    height = this.axis.area('height');
                var min = width;

                if (height < min) {
                    min = height;
                }

                // center
                var w = min / 2,
                    centerX = this.axis.area('x') + width / 2,
                    centerY = this.axis.area('y') + height / 2;

                var startY = -w,
                    startX = 0,
                    count = this.domain.length,
                    step = this.grid.step,
                    unit = 2 * Math.PI / count,
                    h = Math.abs(startY) / step;

                var g = this.chart.svg.group(),
                    root = this.chart.svg.group();

                g.append(root);

                // domain line
                position = [];

                for (var i = 0; i < count; i++) {
                    var x2 = centerX + startX,
                        y2 = centerY + startY;

                    root.append(this.chart.svg.line({
                        x1: centerX,
                        y1: centerY,
                        x2: x2,
                        y2: y2,
                        stroke: this.color("gridAxisBorderColor"),
                        "stroke-width": this.chart.theme("gridBorderWidth")
                    }));

                    position[i] = {
                        x1: centerX,
                        y1: centerY,
                        x2: x2,
                        y2: y2
                    };

                    var ty = y2,
                        tx = x2,
                        talign = "middle";

                    if (y2 > centerY) {
                        ty = y2 + 20;
                    } else if (y2 < centerY) {
                        ty = y2 - 10;
                    }

                    if (x2 > centerX) {
                        talign = "start";
                        tx += 10;
                    } else if (x2 < centerX) {
                        talign = "end";
                        tx -= 10;
                    }

                    if (!this.grid.hideText) {
                        root.append(this.chart.text({
                            x: tx,
                            y: ty,
                            "text-anchor": talign,
                            "font-size": this.chart.theme("gridCFontSize"),
                            "font-weight": this.chart.theme("gridCFontWeight"),
                            fill: this.chart.theme("gridCFontColor")
                        }, this.domain[i]));
                    }

                    var obj = math$$1.rotate(startX, startY, unit);

                    startX = obj.x;
                    startY = obj.y;
                }

                if (!this.grid.line) {
                    return {
                        root: root,
                        scale: scale(position[0])
                    };
                }

                // area split line
                startY = -w;
                var stepBase = 0,
                    stepValue = this.grid.max / this.grid.step;

                for (var i = 0; i < step; i++) {
                    if (i == 0 && this.grid.extra) {
                        startY += h;
                        continue;
                    }

                    if (this.grid.shape == "circle") {
                        drawCircle(root, centerX, centerY, 0, startY, count);
                    } else {
                        drawRadial(root, centerX, centerY, 0, startY, count, unit);
                    }

                    if (!this.grid.hideText) {
                        root.append(this.chart.text({
                            x: centerX,
                            y: centerY + (startY + h - 5),
                            "font-size": this.chart.theme("gridCFontSize"),
                            "font-weight": this.chart.theme("gridCFontWeight"),
                            fill: this.chart.theme("gridCFontColor")
                        }, this.grid.max - stepBase + ""));
                    }

                    startY += h;
                    stepBase += stepValue;
                }

                // hide
                if (this.grid.hide) {
                    root.attr({ display: "none" });
                }

                return {
                    root: root,
                    scale: scale(position[0])
                };
            };
        };

        RadarGrid.setup = function () {
            return {
                /** @cfg {String/Array/Function} [domain=null] Sets the value displayed on an axis.*/
                domain: null,
                /** @cfg {Boolean} [reverse=false] Reverses the value on domain values*/
                reverse: false,
                /** @cfg {Number} [max=null] Sets the maximum value of a grid. */
                max: 100,
                /** @cfg {Array} [step=10] Sets the interval of the scale displayed on a grid. */
                step: 10,
                /** @cfg {Boolean} [line=true] Determines whether to display a line on the axis background. */
                line: true,
                /** @cfg {Boolean} [hideText=false] Determines whether to show text across the grid. */
                hideText: false,
                /** @cfg {Boolean} [extra=false] Leaves a certain spacing distance from the grid start point and displays a line where the spacing ends. */
                extra: false,
                /** @cfg {"radial"/"circle"} [shape="radial"] Determines the shape of a grid (radial, circle). */
                shape: "radial" // or circle
            };
        };

        return RadarGrid;
    }
};

jui$1.use([math, scale]);

var RangeGrid = {
    name: "chart.grid.range",
    extend: "chart.grid.core",
    component: function component() {
        var _ = jui$1.include("util.base");
        var math$$1 = jui$1.include("util.math");
        var UtilScale = jui$1.include("util.scale");

        var RangeGrid = function RangeGrid() {
            this.center = function (g) {
                var min = this.scale.min(),
                    max = this.scale.max();

                this.drawCenter(g, this.ticks, this.values, function (tick) {
                    return tick == 0 && tick != min && tick != max;
                }, 0);
                this.drawBaseLine("center", g);
            };

            this.top = function (g) {
                this.drawPattern("top", this.ticks, this.values);
                var min = this.scale.min(),
                    max = this.scale.max();

                this.drawTop(g, this.ticks, this.values, function (tick) {
                    return tick == 0 && tick != min && tick != max;
                }, 0);
                this.drawBaseLine("top", g);
            };

            this.bottom = function (g) {
                this.drawPattern("bottom", this.ticks, this.values);
                var min = this.scale.min(),
                    max = this.scale.max();

                this.drawBottom(g, this.ticks, this.values, function (tick) {
                    return tick == 0 && tick != min && tick != max;
                }, 0);
                this.drawBaseLine("bottom", g);
            };

            this.left = function (g) {
                this.drawPattern("left", this.ticks, this.values);
                var min = this.scale.min(),
                    max = this.scale.max();

                this.drawLeft(g, this.ticks, this.values, function (tick) {
                    return tick == 0 && tick != min && tick != max;
                }, 0);
                this.drawBaseLine("left", g);
            };

            this.right = function (g) {
                this.drawPattern("right", this.ticks, this.values);
                var min = this.scale.min(),
                    max = this.scale.max();

                this.drawRight(g, this.ticks, this.values, function (tick) {
                    return tick == 0 && tick != min && tick != max;
                }, 0);
                this.drawBaseLine("right", g);
            };

            this.wrapper = function (scale$$1, key) {
                var old_scale = scale$$1;
                var self = this;

                function new_scale(i) {
                    return old_scale(self.axis.data[i][key]);
                }

                return key ? _.extend(new_scale, old_scale) : old_scale;
            };

            this.initDomain = function () {

                var domain = [];
                var min = this.grid.min || undefined,
                    max = this.grid.max || undefined,
                    data = this.data();
                var value_list = [];
                var isArray = false;

                if (_.typeCheck("string", this.grid.domain)) {
                    var field = this.grid.domain;

                    value_list = new Array(data.length);
                    var index = data.length;
                    while (index--) {
                        var value = data[index][field];

                        if (_.typeCheck("array", value)) {
                            value_list[index] = Math.max(value);
                            value_list.push(Math.min(value));
                        } else {
                            value_list[index] = value;
                            value_list.push(0);
                        }
                    }
                } else if (_.typeCheck("function", this.grid.domain)) {
                    value_list = new Array(data.length);

                    var isCheck = false;
                    var index = data.length;
                    while (index--) {

                        var value = this.grid.domain.call(this.chart, data[index]);

                        if (_.typeCheck("array", value)) {

                            value_list[index] = Math.max.apply(Math, value);
                            value_list.push(Math.min.apply(Math, value));
                        } else {
                            value_list[index] = value;

                            if (!isCheck) {
                                value_list.push(0);
                                isCheck = true;
                            }
                        }
                    }
                } else {
                    value_list = this.grid.domain;
                    isArray = true;
                }

                var tempMin = Math.min.apply(Math, value_list);
                var tempMax = Math.max.apply(Math, value_list);

                if (isArray) {
                    min = tempMin;
                    max = tempMax;
                } else {
                    if (typeof min == 'undefined' || min > tempMin) min = tempMin;
                    if (typeof max == 'undefined' || max < tempMax) max = tempMax;
                }

                var unit;
                if (_.typeCheck("function", this.grid.unit)) {
                    unit = this.grid.unit.call(this.chart, this.grid);
                } else if (_.typeCheck("number", this.grid.unit)) {
                    unit = this.grid.unit;
                } else {

                    if (min > 0) {
                        min = Math.floor(min);
                    }

                    unit = math$$1.div(max - min, this.grid.step); // (max - min) / this.grid.step

                    if (unit > 1) {
                        unit = Math.ceil(unit);
                    } else if (0 < unit && unit < 1) {
                        unit = math$$1.div(Math.ceil(math$$1.multi(unit, 10)), 10);
                    }
                }

                if (unit == 0) {
                    domain = [0, 0];
                } else {

                    var start = 0;

                    var fixed = math$$1.fixed(unit);
                    while (start < max) {
                        start = fixed.plus(start, unit);
                    }

                    var end = start;
                    while (end > min) {
                        end = fixed.minus(end, unit);
                    }

                    domain = [end, start];

                    domain.step = Math.abs(end - start) / unit;
                }

                if (this.grid.reverse) {
                    domain.reverse();
                }

                return domain;
            };

            this.drawBefore = function () {
                var domain = this.initDomain();

                var obj = this.getGridSize();

                this.scale = UtilScale.linear().domain(domain);

                if (this.grid.orient == "left" || this.grid.orient == "right") {
                    var arr = [obj.end, obj.start];
                } else {
                    var arr = [obj.start, obj.end];
                }

                this.scale.range(arr);
                this.scale.clamp(this.grid.clamp);

                this.start = obj.start;
                this.size = obj.size;
                this.end = obj.end;
                this.step = domain.step;
                this.nice = this.grid.nice;
                this.ticks = this.scale.ticks(this.step, this.nice);

                if (this.grid.orient == 'left' || this.grid.orient == 'right') {
                    this.ticks.reverse();
                }

                this.bar = 6;

                this.values = [];

                for (var i = 0, len = this.ticks.length; i < len; i++) {
                    this.values[i] = this.scale(this.ticks[i]);
                }
            };

            this.draw = function () {
                return this.drawGrid("range");
            };
        };

        RangeGrid.setup = function () {
            return {
                /** @cfg {String/Array/Function} [domain=null] Sets the value displayed on an axis.*/
                domain: null,
                /** @cfg {Array} [step=10] Sets the interval of the scale displayed on a grid. */
                step: 10,
                /** @cfg {Number} [min=0] Sets the minimum value of a grid.  */
                min: 0,
                /** @cfg {Number} [max=0] Sets the maximum value of a grid. */
                max: 0,
                /** @cfg {Number} [unit=null] Multiplies the axis value to be displayed.  */
                unit: null,
                /**
                 * @cfg {Boolean} [clamp=true]
                 *
                 * max 나 min 을 넘어가는 값에 대한 체크,
                 * true 이면 넘어가는 값도 min, max 에서 조정, false 이면  비율로 계산해서 넘어가는 값 적용
                 */
                clamp: true,
                /** @cfg {Boolean} [reverse=false] Reverses the value on domain values*/
                reverse: false,
                /** @cfg {String} [key=null] Sets the value on the grid to the value for the specified key. */
                key: null,
                /** @cfg {Boolean} [hideText=false] Determines whether to show text across the grid. */
                hideText: false,
                /** @cfg {Boolean} [nice=false] Automatically sets the value of a specific section.  */
                nice: false
            };
        };

        return RangeGrid;
    }
};

var LogGrid = {
    name: "chart.grid.log",
    extend: "chart.grid.range",
    component: function component() {
        var UtilScale = jui$1.include("util.scale");

        var LogGrid = function LogGrid() {

            this.drawBefore = function () {
                this.grid.unit = false;

                var domain = this.initDomain();

                var obj = this.getGridSize();

                this.scale = UtilScale.log(this.grid.base).domain(domain);

                if (this.grid.orient == "left" || this.grid.orient == "right") {
                    var arr = [obj.end, obj.start];
                } else {
                    var arr = [obj.start, obj.end];
                }
                this.scale.range(arr);

                this.start = obj.start;
                this.size = obj.size;
                this.end = obj.end;
                this.step = this.grid.step;
                this.nice = this.grid.nice;
                this.ticks = this.scale.ticks(this.step, this.nice);

                if (this.grid.orient == 'left' || this.grid.orient == 'right') {
                    this.ticks.reverse();
                }

                this.bar = 6;

                this.values = [];

                for (var i = 0, len = this.ticks.length; i < len; i++) {
                    this.values[i] = this.scale(this.ticks[i]);
                }
            };

            this.draw = function () {
                return this.drawGrid("log");
            };
        };

        LogGrid.setup = function () {
            return {
                /** @cfg {Number} [base=10] log's base */
                base: 10,
                step: 4,
                nice: false,
                /** @cfg {Boolean} [hideText=false] Determines whether to show text across the grid. */
                hideText: false
            };
        };

        return LogGrid;
    }
};

var RuleGrid = {
    name: "chart.grid.rule",
    extend: "chart.grid.core",
    component: function component() {
        var _ = jui$1.include("util.base");
        var UtilScale = jui$1.include("util.scale");

        var RuleGrid = function RuleGrid() {

            this.top = function (g) {
                var height = this.axis.area('height'),
                    half_height = height / 2;

                g.append(this.axisLine({
                    y1: this.center ? half_height : 0,
                    y2: this.center ? half_height : 0,
                    x1: this.start,
                    x2: this.end
                }));

                var ticks = this.ticks,
                    values = this.values,
                    bar = this.bar;

                for (var i = 0; i < ticks.length; i++) {
                    var domain = this.format(ticks[i], i);

                    if (!domain && domain !== 0) {
                        continue;
                    }

                    var isZero = ticks[i] == 0,
                        axis = this.chart.svg.group().translate(values[i], this.center ? half_height : 0);

                    axis.append(this.line({
                        y1: this.center ? -bar : 0,
                        y2: bar,
                        stroke: this.color("gridAxisBorderColor"),
                        "stroke-width": this.chart.theme("gridBorderWidth")
                    }));

                    if (!isZero || isZero && !this.hideZero) {
                        axis.append(this.getTextRotate(this.chart.text({
                            x: 0,
                            y: bar + bar + 4,
                            "text-anchor": "middle",
                            fill: this.chart.theme("gridFontColor")
                        }, domain)));
                    }

                    g.append(axis);
                }
            };

            this.bottom = function (g) {
                var height = this.axis.area('height'),
                    half_height = height / 2;

                g.append(this.axisLine({
                    y1: this.center ? -half_height : 0,
                    y2: this.center ? -half_height : 0,
                    x1: this.start,
                    x2: this.end
                }));

                var ticks = this.ticks,
                    values = this.values,
                    bar = this.bar;

                for (var i = 0; i < ticks.length; i++) {
                    var domain = this.format(ticks[i], i);

                    if (!domain && domain !== 0) {
                        continue;
                    }

                    var isZero = ticks[i] == 0,
                        axis = this.chart.svg.group().translate(values[i], this.center ? -half_height : 0);

                    axis.append(this.line({
                        y1: this.center ? -bar : 0,
                        y2: this.center ? bar : -bar,
                        stroke: this.color("gridAxisBorderColor"),
                        "stroke-width": this.chart.theme("gridBorderWidth")
                    }));

                    if (!isZero || isZero && !this.hideZero) {
                        axis.append(this.getTextRotate(this.chart.text({
                            x: 0,
                            y: -bar * 2,
                            "text-anchor": "middle",
                            fill: this.chart.theme(isZero, "gridActiveFontColor", "gridFontColor")
                        }, domain)));
                    }

                    g.append(axis);
                }
            };

            this.left = function (g) {
                var width = this.axis.area('width'),
                    height = this.axis.area('height'),
                    half_width = width / 2;

                g.append(this.axisLine({
                    x1: this.center ? half_width : 0,
                    x2: this.center ? half_width : 0,
                    y1: this.start,
                    y2: this.end
                }));

                var ticks = this.ticks,
                    values = this.values,
                    bar = this.bar;

                for (var i = 0; i < ticks.length; i++) {
                    var domain = this.format(ticks[i], i);

                    if (!domain && domain !== 0) {
                        continue;
                    }

                    var isZero = ticks[i] == 0,
                        axis = this.chart.svg.group().translate(this.center ? half_width : 0, values[i]);

                    axis.append(this.line({
                        x1: this.center ? -bar : 0,
                        x2: bar,
                        stroke: this.color("gridAxisBorderColor"),
                        "stroke-width": this.chart.theme("gridBorderWidth")
                    }));

                    if (!isZero || isZero && !this.hideZero) {
                        axis.append(this.getTextRotate(this.chart.text({
                            x: bar / 2 + 4,
                            y: bar - 2,
                            fill: this.chart.theme("gridFontColor")
                        }, domain)));
                    }

                    g.append(axis);
                }
            };

            this.right = function (g) {
                var width = this.axis.area('width'),
                    half_width = width / 2;

                g.append(this.axisLine({
                    x1: this.center ? -half_width : 0,
                    x2: this.center ? -half_width : 0,
                    y1: this.start,
                    y2: this.end
                }));

                var ticks = this.ticks,
                    values = this.values,
                    bar = this.bar;

                for (var i = 0; i < ticks.length; i++) {
                    var domain = this.format(ticks[i], i);

                    if (!domain && domain !== 0) {
                        continue;
                    }

                    var isZero = ticks[i] == 0,
                        axis = this.chart.svg.group().translate(this.center ? -half_width : 0, values[i]);

                    axis.append(this.line({
                        x1: this.center ? -bar : 0,
                        x2: this.center ? bar : -bar,
                        stroke: this.color("gridAxisBorderColor"),
                        "stroke-width": this.chart.theme("gridBorderWidth")
                    }));

                    if (!isZero || isZero && !this.hideZero) {
                        axis.append(this.getTextRotate(this.chart.text({
                            x: -bar - 4,
                            y: bar - 2,
                            "text-anchor": "end",
                            fill: this.chart.theme("gridFontColor")
                        }, domain)));
                    }

                    g.append(axis);
                }
            };

            this.wrapper = function (scale, key) {
                var old_scale = scale;
                var self = this;

                function new_scale(i) {
                    return old_scale(self.axis.data[i][key]);
                }

                return key ? _.extend(new_scale, old_scale) : old_scale;
            };

            this.initDomain = function () {

                var domain = [];
                var min = this.grid.min || undefined,
                    max = this.grid.max || undefined,
                    data = this.data();
                var value_list = [];

                if (_.typeCheck("string", this.grid.domain)) {
                    var field = this.grid.domain;

                    value_list = new Array(data.length);
                    for (var index = 0, len = data.length; index < len; index++) {

                        var value = data[index][field];

                        if (_.typeCheck("array", value)) {
                            value_list[index] = Math.max(value);
                            value_list.push(Math.min(value));
                        } else {
                            value_list[index] = value;
                        }
                    }
                } else if (_.typeCheck("function", this.grid.domain)) {
                    value_list = new Array(data.length);

                    for (var index = 0, len = data.length; index < len; index++) {

                        var value = this.grid.domain.call(this.chart, data[index]);

                        if (_.typeCheck("array", value)) {

                            value_list[index] = Math.max.apply(Math, value);
                            value_list.push(Math.min.apply(Math, value));
                        } else {
                            value_list[index] = value;
                        }
                    }
                } else {
                    value_list = grid.domain;
                }

                var tempMin = Math.min.apply(Math, value_list);
                var tempMax = Math.max.apply(Math, value_list);

                if (typeof min == 'undefined') min = tempMin;
                if (typeof max == 'undefined') max = tempMax;

                this.grid.max = max;
                this.grid.min = min;

                var unit;

                if (_.typeCheck("function", this.grid.unit)) {
                    unit = this.grid.unit.call(this.chart, this.grid);
                } else if (_.typeCheck("number", this.grid.unit)) {
                    unit = this.grid.unit;
                } else {
                    unit = Math.ceil((max - min) / this.grid.step);
                }

                if (unit == 0) {
                    domain = [0, 0];
                } else {

                    var start = 0;

                    while (start < max) {
                        start += unit;
                    }

                    var end = start;
                    while (end > min) {
                        end -= unit;
                    }

                    domain = [end, start];
                    //this.grid.step = Math.abs(start / unit) + Math.abs(end / unit);
                }

                if (this.grid.reverse) {
                    domain.reverse();
                }

                return domain;
            };

            this.drawBefore = function () {
                var domain = this.initDomain();

                var obj = this.getGridSize();
                this.scale = UtilScale.linear().domain(domain);

                if (this.grid.orient == "left" || this.grid.orient == "right") {
                    var arr = [obj.end, obj.start];
                } else {
                    var arr = [obj.start, obj.end];
                }
                this.scale.range(arr);

                this.start = obj.start;
                this.size = obj.size;
                this.end = obj.end;
                this.step = this.grid.step;
                this.nice = this.grid.nice;
                this.ticks = this.scale.ticks(this.step, this.nice);
                this.bar = 6;
                this.hideZero = this.grid.hideZero;
                this.center = this.grid.center;
                this.values = [];

                for (var i = 0, len = this.ticks.length; i < len; i++) {
                    this.values[i] = this.scale(this.ticks[i]);
                }
            };

            this.draw = function () {
                return this.drawGrid(chart, orient, "rule", grid);
            };
        };

        RuleGrid.setup = function () {
            return {
                /** @cfg {String/Array/Function} [domain=null] Sets the value displayed on an axis.*/
                domain: null,
                /** @cfg {Array} [step=10] Sets the interval of the scale displayed on a grid. */
                step: 10,
                /** @cfg {Number} [min=0] Sets the minimum value of a grid.  */
                min: 0,
                /** @cfg {Number} [max=0] Sets the maximum value of a grid. */
                max: 0,
                /** @cfg {Number} [unit=null] Multiplies the axis value to be displayed.  */
                unit: null,
                /**
                 * @cfg {Boolean} [clamp=true]
                 *
                 * max 나 min 을 넘어가는 값에 대한 체크,
                 * true 이면 넘어가는 값도 min, max 에서 조정, false 이면  비율로 계산해서 넘어가는 값 적용
                 */
                clamp: true,
                /** @cfg {Boolean} [reverse=false] Reverses the value on domain values*/
                reverse: false,
                /** @cfg {String} [key=null] Sets the value on the grid to the value for the specified key. */
                key: null,
                /** @cfg {Boolean} [hideText=false] Determines whether to show text across the grid. */
                hideText: false,
                /** @cfg {Boolean} [hideZero=false] Determines whether to show '0' displayed on the grid. */
                hideZero: false,
                /** @cfg {Boolean} [nice=false] Automatically sets the value of a specific section.  */
                nice: false,
                /** @cfg {Boolean} [center=false] Place the reference axis in the middle.  */
                center: false

            };
        };

        return RuleGrid;
    }
};

var PanelGrid = {
    name: "chart.grid.panel",
    extend: "chart.grid.core",
    component: function component() {
        var _ = jui$1.include("util.base");

        var PanelGrid = function PanelGrid() {

            this.custom = function (g) {
                var obj = this.scale(0);

                obj.x -= this.axis.area("x");
                obj.y -= this.axis.area("y");

                g.append(this.chart.svg.rect(_.extend(obj, {
                    fill: "transparent",
                    stroke: "transparent"
                })));
            };

            this.drawBefore = function () {
                this.scale = function (axis) {
                    return function (i) {

                        return {
                            x: axis.area("x"),
                            y: axis.area("y"),
                            width: axis.area("width"),
                            height: axis.area("height")
                        };
                    };
                }(this.axis);
            };

            this.draw = function () {
                this.grid.hide = true;
                return this.drawGrid("panel");
            };
        };

        return PanelGrid;
    }
};

var TableGrid = {
    name: "chart.grid.table",
    extend: "chart.grid.core",
    component: function component() {
        var TableGrid = function TableGrid(chart, axis, grid) {
            var row, column;

            this.custom = function (g) {
                for (var r = 0; r < row; r++) {
                    for (var c = 0; c < column; c++) {
                        var index = r * column + c;

                        var obj = this.scale(index);

                        obj.x -= this.axis.area('x');
                        obj.y -= this.axis.area('y');

                        var rect = this.chart.svg.rect(_.extend(obj, {
                            fill: "tranparent",
                            stroke: "black"
                        }));

                        //g.append(rect);
                    }
                }
            };

            this.drawBefore = function () {

                var row = this.grid.rows;
                var column = this.grid.columns;

                var padding = this.grid.padding;

                var columnUnit = (this.axis.area('width') - (column - 1) * padding) / column;
                var rowUnit = (this.axis.area('height') - (row - 1) * padding) / row;

                // create scale
                this.scale = function (axis, row, column, rowUnit, columnUnit) {
                    return function (i) {

                        var r = Math.floor(i / column);
                        var c = i % column;

                        var x = c * columnUnit;
                        var y = r * rowUnit;

                        var space = padding * c;
                        var rspace = padding * r;

                        return {
                            x: axis.area('x') + x + space,
                            y: axis.area('y') + y + rspace,
                            width: columnUnit,
                            height: rowUnit
                        };
                    };
                }(this.axis, row, column, rowUnit, columnUnit);
            };

            this.draw = function () {
                this.grid.hide = true;
                return this.drawGrid("table");
            };
        };

        TableGrid.setup = function () {
            return {
                /** @cfg {Number} [rows=1] row count in table  */
                rows: 1,
                /** @cfg {Number} [column=1] column count in table  */
                columns: 1,
                /** @cfg {Number} [padding=1] padding in table  */
                padding: 10
            };
        };

        return TableGrid;
    }
};

var OverlapGrid = {
    name: "chart.grid.overlap",
    extend: "chart.grid.core",
    component: function component() {
        var _ = jui$1.include("util.base");

        var OverlapGrid = function OverlapGrid() {
            var size, widthUnit, heightUnit, width, height;

            this.custom = function () {
                for (var i = 0, len = this.axis.data.length; i < len; i++) {
                    var obj = this.scale(i);

                    obj.x -= this.axis.area("x");
                    obj.y -= this.axis.area("y");

                    this.chart.svg.rect(_.extend(obj, {
                        fill: "transparent",
                        stroke: "transparent"
                    }));
                }
            };

            this.drawBefore = function () {
                size = this.grid.count || this.axis.data.length || 1;

                widthUnit = this.axis.area('width') / 2 / size;
                heightUnit = this.axis.area('height') / 2 / size;

                width = this.axis.area('width');
                height = this.axis.area('height');

                // create scale
                this.scale = function (axis) {
                    return function (i) {

                        var x = i * widthUnit;
                        var y = i * heightUnit;

                        return {
                            x: axis.area('x') + x,
                            y: axis.area('y') + y,
                            width: Math.abs(width / 2 - x) * 2,
                            height: Math.abs(height / 2 - y) * 2
                        };
                    };
                }(this.axis);
            };

            this.draw = function () {
                this.grid.hide = true;
                return this.drawGrid("overlap");
            };
        };

        OverlapGrid.setup = function () {
            return {
                /** @cfg {Number} [count=null] Splited count  */
                count: null
            };
        };

        return OverlapGrid;
    }
};

jui$1.use([math]);

var Grid3dGrid = {
    name: "chart.grid.grid3d",
    extend: "chart.grid.core",
    component: function component() {
        var _ = jui$1.include("util.base");
        var math$$1 = jui$1.include("util.math");

        var Grid3D = function Grid3D() {
            var self = this,
                depth = 0,
                degree = 0,
                radian = 0;

            function getElementAttr(root) {
                var attr = null;

                root.each(function (i, elem) {
                    if (elem.element.nodeName == "line") {
                        attr = elem.attributes;
                    }
                });

                return attr;
            }

            this.drawBefore = function () {
                depth = this.axis.get("depth");
                degree = this.axis.get("degree");
                radian = math$$1.radian(360 - degree);

                this.scale = function () {
                    return function (x, y, z, count) {
                        var step = _.typeCheck("integer", count) ? count : 1,
                            split = depth / step;

                        if (z == undefined || step == 1) {
                            return {
                                x: self.axis.x(x),
                                y: self.axis.y(y),
                                depth: split
                            };
                        } else {
                            var z = z == undefined ? 0 : z,
                                c = split * z,
                                top = Math.sin(radian) * split;

                            return {
                                x: self.axis.x(x) + Math.cos(radian) * c,
                                y: self.axis.y(y) + Math.sin(radian) * c + top,
                                depth: split
                            };
                        }
                    };
                }(this.axis);

                this.scale.depth = depth;
                this.scale.degree = degree;
                this.scale.radian = radian;
            };

            this.draw = function () {
                var xRoot = this.axis.x.root,
                    yRoot = this.axis.y.root;

                var y2 = Math.sin(radian) * depth,
                    x2 = Math.cos(radian) * depth;

                yRoot.each(function (i, elem) {
                    if (elem.element.nodeName == "line") {
                        yRoot.append(self.line({
                            x1: x2,
                            y1: 0,
                            x2: x2,
                            y2: y2 + elem.attributes.y2
                        }));
                    } else {
                        // X축 라인 속성 가져오기
                        var xAttr = getElementAttr(xRoot);

                        elem.append(self.line({
                            x1: 0,
                            y1: 0,
                            x2: x2,
                            y2: y2
                        }));

                        elem.append(self.line({
                            x1: x2,
                            y1: y2,
                            x2: x2 + xAttr.x2,
                            y2: y2
                        }));
                    }
                });

                xRoot.each(function (i, elem) {
                    var attr = elem.element.nodeName == "line" ? elem.attributes : elem.get(0).attributes,
                        y2 = attr.y1 + Math.sin(radian) * depth,
                        x2 = attr.x1 + Math.cos(radian) * depth;

                    if (i > 0) {
                        // Y축 라인 속성 가져오기
                        var yAttr = getElementAttr(yRoot);

                        elem.append(self.line({
                            x1: attr.x1,
                            y1: attr.y1,
                            x2: x2,
                            y2: y2
                        }));

                        elem.append(self.line({
                            x1: x2,
                            y1: y2,
                            x2: x2,
                            y2: -(yAttr.y2 - y2)
                        }));
                    }
                });

                return this.drawGrid();
            };
        };

        Grid3D.setup = function () {
            return {
                /** @cfg {Array} [domain=null] */
                domain: null
            };
        };

        return Grid3D;
    }
};

jui$1.use(draw, dom);

var CoreBrush = {
    name: "chart.brush.core",
    extend: "chart.draw",
    component: function component() {
        var _ = jui$1.include("util.base");
        var $ = jui$1.include("util.dom");

        var CoreBrush = function CoreBrush() {

            function getMinMaxValue(data, target) {
                var seriesList = {},
                    targetList = {};

                for (var i = 0; i < target.length; i++) {
                    if (!seriesList[target[i]]) {
                        targetList[target[i]] = [];
                    }
                }

                // 시리즈 데이터 구성
                for (var i = 0, len = data.length; i < len; i++) {
                    var row = data[i];

                    for (var k in targetList) {
                        targetList[k].push(row[k]);
                    }
                }

                for (var key in targetList) {
                    seriesList[key] = {
                        min: Math.min.apply(Math, targetList[key]),
                        max: Math.max.apply(Math, targetList[key])
                    };
                }

                return seriesList;
            }

            this.drawAfter = function (obj) {
                if (this.brush.clip !== false) {
                    obj.attr({ "clip-path": "url(#" + this.axis.get("clipId") + ")" });
                }

                obj.attr({ "class": "brush-" + this.brush.type });
                obj.translate(this.chart.area("x"), this.chart.area("y")); // 브러쉬일 경우, 기본 좌표 설정
            };

            this.drawTooltip = function (fill, stroke, opacity) {
                var self = this,
                    tooltip = null;

                function draw$$1() {
                    return self.chart.svg.group({ "visibility": "hidden" }, function () {
                        self.chart.text({
                            fill: self.chart.theme("tooltipPointFontColor"),
                            "font-size": self.chart.theme("tooltipPointFontSize"),
                            "font-weight": self.chart.theme("tooltipPointFontWeight"),
                            "text-anchor": "middle",
                            opacity: opacity
                        });

                        self.chart.svg.circle({
                            r: self.chart.theme("tooltipPointRadius"),
                            fill: fill,
                            stroke: stroke,
                            opacity: opacity,
                            "stroke-width": self.chart.theme("tooltipPointBorderWidth")
                        });
                    });
                }

                function show(orient, x, y, value) {
                    var text = tooltip.get(0);
                    text.element.textContent = value;

                    if (orient == "left") {
                        text.attr({ x: -7, y: 4, "text-anchor": "end" });
                    } else if (orient == "right") {
                        text.attr({ x: 7, y: 4, "text-anchor": "start" });
                    } else if (orient == "bottom") {
                        text.attr({ y: 16 });
                    } else {
                        text.attr({ y: -7 });
                    }

                    tooltip.attr({ visibility: value != 0 ? "visible" : "hidden" });
                    tooltip.translate(x, y);
                }

                // 툴팁 생성
                tooltip = draw$$1();

                return {
                    tooltip: tooltip,
                    control: show,
                    style: function style(fill, stroke, opacity) {
                        tooltip.get(0).attr({
                            opacity: opacity
                        });

                        tooltip.get(1).attr({
                            fill: fill,
                            stroke: stroke,
                            opacity: opacity
                        });
                    }
                };
            };

            /**
             *
             * @method curvePoints
             *
             * 좌표 배열 'K'에 대한 커브 좌표 'P1', 'P2'를 구하는 함수
             *
             * TODO: min, max 에 대한 처리도 같이 필요함.
             *
             * @param {Array} K
             * @return {Object}
             * @return {Array} return.p1
             * @return {Array} return.p2
             *
             */
            this.curvePoints = function (K) {
                var p1 = [];
                var p2 = [];
                var n = K.length - 1;

                /*rhs vector*/
                var a = [];
                var b = [];
                var c = [];
                var r = [];

                /*left most segment*/
                a[0] = 0;
                b[0] = 2;
                c[0] = 1;
                r[0] = K[0] + 2 * K[1];

                /*internal segments*/
                for (i = 1; i < n - 1; i++) {
                    a[i] = 1;
                    b[i] = 4;
                    c[i] = 1;
                    r[i] = 4 * K[i] + 2 * K[i + 1];
                }

                /*right segment*/
                a[n - 1] = 2;
                b[n - 1] = 7;
                c[n - 1] = 0;
                r[n - 1] = 8 * K[n - 1] + K[n];

                /*solves Ax=b with the Thomas algorithm (from Wikipedia)*/
                for (var i = 1; i < n; i++) {
                    var m = a[i] / b[i - 1];
                    b[i] = b[i] - m * c[i - 1];
                    r[i] = r[i] - m * r[i - 1];
                }

                p1[n - 1] = r[n - 1] / b[n - 1];
                for (var i = n - 2; i >= 0; --i) {
                    p1[i] = (r[i] - c[i] * p1[i + 1]) / b[i];
                } /*we have p1, now compute p2*/
                for (var i = 0; i < n - 1; i++) {
                    p2[i] = 2 * K[i + 1] - p1[i + 1];
                }p2[n - 1] = 0.5 * (K[n] + p1[n - 1]);

                return {
                    p1: p1,
                    p2: p2
                };
            };

            /**
             *
             * @method eachData
             *
             * loop axis data
             *
             * @param {Function} callback
             */
            this.eachData = function (callback, reverse) {
                if (!_.typeCheck("function", callback)) return;
                var list = this.listData();

                if (reverse === true) {
                    for (var len = list.length - 1; len >= 0; len--) {
                        callback.call(this, len, list[len]);
                    }
                } else {
                    for (var index = 0, len = list.length; index < len; index++) {
                        callback.call(this, list[index], index);
                    }
                }
            };

            /**
             *
             * @method listData
             *
             * get axis.data
             *
             * @returns {Array} axis.data
             */
            this.listData = function () {
                if (!this.axis) {
                    return [];
                } else {
                    if (!this.axis.data) {
                        return [];
                    }
                }

                return this.axis.data;
            };

            /**
             *
             * @method getData
             *
             * get record by index in axis.data
             *
             * @param {Integer} index
             * @returns {Object} record in axis.data
             */
            this.getData = function (index) {
                return this.listData()[index];
            };

            /**
             * @method getValue
             *
             * chart.axis.getValue alias
             *
             * @param {Object} data row data
             * @param {String} fieldString 필드 이름
             * @param {String/Number/Boolean/Object} [defaultValue=''] 기본값
             * @return {Mixed}
             */
            this.getValue = function (data, fieldString, defaultValue) {
                return this.axis.getValue(data, fieldString, defaultValue);
            };

            /**
             *
             * @method getXY
             *
             * 차트 데이터에 대한 좌표 'x', 'y'를 구하는 함수
             *
             * @param {Boolean} [isCheckMinMax=true]
             * @return {Array}
             */
            this.getXY = function (isCheckMinMax) {
                var xy = [],
                    series = {},
                    length = this.listData().length,
                    i = length,
                    target = this.brush.target,
                    targetLength = target.length;

                if (isCheckMinMax !== false) {
                    series = getMinMaxValue(this.axis.data, target);
                }

                for (var j = 0; j < targetLength; j++) {
                    xy[j] = {
                        x: new Array(length),
                        y: new Array(length),
                        value: new Array(length),
                        min: [],
                        max: [],
                        length: length
                    };
                }

                var axisData = this.axis.data,
                    isRangeY = this.axis.y.type == "range",
                    x = this.axis.x,
                    y = this.axis.y,
                    func = _.loop(i);

                func(function (i, group) {
                    var data = axisData[i],
                        startX = 0,
                        startY = 0;

                    if (isRangeY) startX = x(i);else startY = y(i);

                    for (var j = 0; j < targetLength; j++) {
                        var key = target[j],
                            value = data[key];

                        if (isRangeY) startY = y(value);else startX = x(value);

                        xy[j].x[i] = startX;
                        xy[j].y[i] = startY;
                        xy[j].value[i] = value;

                        if (isCheckMinMax !== false) {
                            xy[j].min[i] = value == series[key].min;
                            xy[j].max[i] = value == series[key].max;
                        }
                    }
                });

                return xy;
            };

            /**
             *
             * @method getStackXY
             *
             * 차트 데이터에 대한 좌표 'x', 'y'를 구하는 함수
             * 단, 'y' 좌표는 다음 데이터 보다 높게 구해진다.
             *
             * @param {Boolean} [isCheckMinMax=true]
             * @return {Array}
             */
            this.getStackXY = function (isCheckMinMax) {
                var xy = this.getXY(isCheckMinMax),
                    isRangeY = this.axis.y.type == "range";

                this.eachData(function (data, i) {
                    var valueSum = 0;

                    for (var j = 0; j < this.brush.target.length; j++) {
                        var key = this.brush.target[j],
                            value = data[key];

                        if (j > 0) {
                            valueSum += data[this.brush.target[j - 1]];
                        }

                        if (isRangeY) {
                            xy[j].y[i] = this.axis.y(value + valueSum);
                        } else {
                            xy[j].x[i] = this.axis.x(value + valueSum);
                        }
                    }
                });

                return xy;
            };

            /**
             * @method addEvent
             * 브러쉬 엘리먼트에 대한 공통 이벤트 정의
             *
             * @param {Element} element
             * @param {Integer} dataIndex
             * @param {Integer} targetIndex
             */
            this.addEvent = function (elem, dataIndex, targetIndex) {
                if (this.brush.useEvent !== true) return;

                var chart = this.chart,
                    obj = {};

                if (_.typeCheck("object", dataIndex) && !targetIndex) {
                    obj.brush = this.brush;
                    obj.data = dataIndex;
                } else {
                    obj.brush = this.brush;
                    obj.dataIndex = dataIndex;
                    obj.dataKey = targetIndex != null ? this.brush.target[targetIndex] : null;
                    obj.data = dataIndex != null ? this.getData(dataIndex) : null;
                }

                elem.on("click", function (e) {
                    setMouseEvent(e);
                    chart.emit("click", [obj, e]);
                });

                elem.on("dblclick", function (e) {
                    setMouseEvent(e);
                    chart.emit("dblclick", [obj, e]);
                });

                elem.on("contextmenu", function (e) {
                    setMouseEvent(e);
                    chart.emit("rclick", [obj, e]);
                    e.preventDefault();
                });

                elem.on("mouseover", function (e) {
                    setMouseEvent(e);
                    chart.emit("mouseover", [obj, e]);
                });

                elem.on("mouseout", function (e) {
                    setMouseEvent(e);
                    chart.emit("mouseout", [obj, e]);
                });

                elem.on("mousemove", function (e) {
                    setMouseEvent(e);
                    chart.emit("mousemove", [obj, e]);
                });

                elem.on("mousedown", function (e) {
                    setMouseEvent(e);
                    chart.emit("mousedown", [obj, e]);
                });

                elem.on("mouseup", function (e) {
                    setMouseEvent(e);
                    chart.emit("mouseup", [obj, e]);
                });

                function setMouseEvent(e) {
                    var pos = $.offset(chart.root),
                        offsetX = e.pageX - pos.left,
                        offsetY = e.pageY - pos.top;

                    e.bgX = offsetX;
                    e.bgY = offsetY;
                    e.chartX = offsetX - chart.padding("left");
                    e.chartY = offsetY - chart.padding("top");
                }
            };

            /**
             * @method color
             *
             * chart.color() 를 쉽게 사용할 수 있게 만든 유틸리티 함수
             *
             * @param {Number} key1  브러쉬에서 사용될 컬러 Index
             * @param {Number} key2  브러쉬에서 사용될 컬러 Index
             * @returns {*}
             */
            this.color = function (key1, key2) {
                var colors = this.brush.colors,
                    color = null,
                    colorIndex = 0,
                    rowIndex = 0;

                if (!_.typeCheck("undefined", key2)) {
                    colorIndex = key2;
                    rowIndex = key1;
                } else {
                    colorIndex = key1;
                }

                if (_.typeCheck("function", colors)) {
                    var newColor = colors.call(this.chart, this.getData(rowIndex), rowIndex);

                    if (_.typeCheck(["string", "integer"], newColor)) {
                        color = this.chart.color(newColor);
                    } else if (_.typeCheck("array", newColor)) {
                        color = this.chart.color(colorIndex, newColor);
                    } else {
                        color = this.chart.color(0);
                    }
                } else {
                    color = this.chart.color(colorIndex, colors);
                }

                return color;
            };

            /**
             * @method offset
             *
             * 그리드 타입에 따른 시작 좌표 가져오기 (블럭)
             *
             * @param {String} 그리드 종류
             * @param {Number} 인덱스
             * @returns {*}
             */
            this.offset = function (type, index) {
                // 그리드 타입에 따른 시작 좌표 가져오기
                var res = this.axis[type](index);

                if (this.axis[type].type != "block") {
                    res += this.axis[type].rangeBand() / 2;
                }

                return res;
            };
        };

        CoreBrush.setup = function () {
            return {

                /** @property {chart.builder} chart */
                /** @property {chart.axis} axis */
                /** @property {Object} brush */

                /** @cfg {Array} [target=null] Specifies the key value of data displayed on a brush.  */
                target: null,
                /** @cfg {Array/Function} [colors=null] Able to specify color codes according to the target order (basically, refers to the color codes of a theme) */
                colors: null,
                /** @cfg {Integer} [axis=0] Specifies the index of a grid group which acts as the reference axis of a brush. */
                axis: 0,
                /** @cfg {Integer} [index=null] [Read Only] Sequence index on which brush is drawn. */
                index: null,
                /** @cfg {boolean} [clip=true] If the brush is drawn outside of the chart, cut the area. */
                clip: true,
                /** @cfg {boolean} [useEvent=true] If you do not use a brush events, it gives better performance. */
                useEvent: true
            };
        };

        /**
         * @event click
         * Event that occurs when clicking on the brush.
         * @param {BrushData} obj Related brush data.
         */
        /**
         * @event dblclick
         * Event that occurs when double clicking on the brush.
         * @param {BrushData} obj Related brush data.
         */
        /**
         * @event rclick
         * Event that occurs when right clicking on the brush.
         * @param {BrushData} obj Related brush data.
         */
        /**
         * @event mouseover
         * Event that occurs when placing the mouse over the brush.
         * @param {BrushData} obj Related brush data.
         */
        /**
         * @event mouseout
         * Event that occurs when moving the mouse out of the brush.
         * @param {BrushData} obj Related brush data.
         */
        /**
         * @event mousemove
         * Event that occurs when moving the mouse over the brush.
         * @param {BrushData} obj Related brush data.
         */
        /**
         * @event mousedown
         * Event that occurs when left clicking on the brush.
         * @param {BrushData} obj Related brush data.
         */
        /**
         * @event mouseup
         * Event that occurs after left clicking on the brush.
         * @param {BrushData} obj Related brush data.
         */

        return CoreBrush;
    }
};

var MapCoreBrush = {
    name: "chart.brush.map.core",
    extend: "chart.brush.core",
    component: function component() {
        var MapCoreBrush = function MapCoreBrush() {};

        return MapCoreBrush;
    }
};

var PolygonCoreBrush = {
    name: "chart.brush.polygon.core",
    extend: "chart.brush.core",
    component: function component() {
        var PolygonCoreBrush = function PolygonCoreBrush() {
            this.createPolygon = function (polygon, callback) {
                this.calculate3d(polygon);

                var element = callback.call(this, polygon);
                if (element) {
                    element.order = this.axis.depth - polygon.max().z;
                    return element;
                }
            };
        };

        PolygonCoreBrush.setup = function () {
            return {
                id: null,
                clip: false
            };
        };

        return PolygonCoreBrush;
    }
};

var CanvasCoreBrush = {
    name: "chart.brush.canvas.core",
    extend: "chart.brush.core",
    component: function component() {
        var _ = jui$1.include("util.base");

        var CanvasCoreBrush = function CanvasCoreBrush() {
            this.addPolygon = function (polygon, callback) {
                if (!_.typeCheck("array", this.polygons)) {
                    this.polygons = [];
                }

                // 폴리곤 각도 및 깊이 연산
                this.calculate3d(polygon);

                // 연산된 폴리곤 객체 추가
                this.polygons.push({
                    polygon: polygon,
                    order: this.axis.depth - polygon.max().z,
                    handler: callback
                });
            };

            this.drawAfter = function () {
                // 폴리곤 기반의 브러쉬일 경우
                if (_.typeCheck("array", this.polygons)) {
                    var list = this.polygons;

                    list.sort(function (a, b) {
                        return a.order - b.order;
                    });

                    for (var i = 0, len = list.length; i < len; i++) {
                        var p = list.shift();
                        p.handler.call(this, p.polygon);
                    }
                }
            };
        };

        return CanvasCoreBrush;
    }
};

jui$1.use(draw);

var CoreWidget = {
    name: "chart.widget.core",
    extend: "chart.draw",
    component: function component() {
        var _ = jui$1.include("util.base");

        var CoreWidget = function CoreWidget() {

            this.getIndexArray = function (index) {
                var list = [0];

                if (_.typeCheck("array", index)) {
                    list = index;
                } else if (_.typeCheck("integer", index)) {
                    list = [index];
                }

                return list;
            };

            this.getScaleToValue = function (scale, minScale, maxScale, minValue, maxValue) {
                var tick = (maxScale - minScale) * 10,
                    step = (maxValue - minValue) / tick,
                    value = maxValue - step * ((scale - minScale) / 0.1);

                if (value < minValue) return minValue;else if (value > maxValue) return maxValue;

                return value;
            };

            this.getValueToScale = function (value, minValue, maxValue, minScale, maxScale) {
                var tick = (maxScale - minScale) * 10,
                    step = (maxValue - minValue) / tick;

                return parseFloat((minScale + (maxValue - value) / step * 0.1).toFixed(1));
            };

            this.isRender = function () {
                return this.widget.render === true ? true : false;
            };

            this.on = function (type, callback, axisIndex) {
                var self = this;

                return this.chart.on(type, function () {
                    if (_.startsWith(type, "axis.") && _.typeCheck("integer", axisIndex)) {
                        var axis = self.chart.axis(axisIndex),
                            e = arguments[0];

                        if (_.typeCheck("object", axis)) {
                            if (arguments[1] == axisIndex) {
                                callback.apply(self, [e]);
                            }
                        }
                    } else {
                        callback.apply(self, arguments);
                    }
                }, this.isRender() ? "render" : "renderAll");
            };

            this.drawAfter = function (obj) {
                obj.attr({ "class": "widget-" + this.widget.type });
            };
        };

        CoreWidget.setup = function () {

            /** @property {chart.builder} chart */
            /** @property {chart.axis} axis */
            /** @property {Object} widget */
            /** @property {Number} index [Read Only] Index which shows the sequence how a widget is drawn. */

            return {
                /**
                 * @cfg {Boolean} [render=false] Determines whether a widget is to be rendered.
                 */
                render: false,
                /**
                 * @cfg {Number} [index=0] current widget index
                 */
                index: 0
            };
        };

        return CoreWidget;
    }
};

var MapCoreWidget = {
    name: "chart.widget.map.core",
    extend: "chart.widget.core",
    component: function component() {
        var MapCoreWidget = function MapCoreWidget(chart, axis, widget) {};

        MapCoreWidget.setup = function () {
            return {
                axis: 0
            };
        };

        return MapCoreWidget;
    }
};

var PolygonCoreWidget = {
    name: "chart.widget.polygon.core",
    extend: "chart.widget.core",
    component: function component() {
        var PolygonCoreWidget = function PolygonCoreWidget() {
            this.drawAfter = function (obj) {};
        };

        return PolygonCoreWidget;
    }
};

var CanvasCoreWidget = {
    name: "chart.widget.canvas.core",
    extend: "chart.widget.core",
    component: function component() {
        var CanvasCoreWidget = function CanvasCoreWidget() {
            this.drawAfter = function (obj) {};
        };

        return CanvasCoreWidget;
    }
};

jui$1.use([dom, math, color, collection, manager, UICore, time, transform, CanvasUtil, CanvasHidpiUtil, JUISvgElement, JUISvgTransformElement, JUISvgPathElement, JUISvgPathRectElement, JUISvgPathSymbolElement, JUISvgPolyElement, JUISvgBase, JUISvgBase3d, svg, LinearScaleUtil, CircleScaleUtil, LogScaleUtil, OrdinalScaleUtil, TimeScaleUtil, scale, vector, draw, axis, Map, JUIBuilder, Plane, Animation, core, grid$1, line, point, CubePolygon, draw2d, draw3d, CoreGrid, BlockGrid, DateGrid, DateBlockGrid, FullBlockGrid, RadarGrid, RangeGrid, LogGrid, RuleGrid, PanelGrid, TableGrid, OverlapGrid, Grid3dGrid, CoreBrush, MapCoreBrush, PolygonCoreBrush, CanvasCoreBrush, CoreWidget, MapCoreWidget, PolygonCoreWidget, CanvasCoreWidget]);

var _$1 = jui$1.include("util.base"),
    manager$1 = jui$1.include("manager");

_$1.extend(jui$1, manager$1, true);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (jui$1);


/***/ }),

/***/ "./node_modules/juijs-graph/src/util/canvas/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/juijs-graph/src/util/canvas/base.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: "util.canvas.base",
    extend: null,
    component: function () {
        const CanvasBase = function (context) {
            this.clearContext = function() {
                context.clearRect(0, 0, context.canvas.width, context.canvas.height);
            }

            this.drawLine = function(
                x1,
                y1,
                x2,
                y2,
                color,
                lineWidth = 1,
            ) {
                color = color || '#434d6b';
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.lineWidth = lineWidth;
                context.strokeStyle = color;
                context.stroke();
            }

            this.drawCurve = function(
                points,
                minY,
                maxY,
                tension=0.5,
                isClosed=false,
                numOfSegments=16
            ) {
                context.beginPath();
                const pts = points.reduce((prev, e) => {
                    prev.push(e[0], e[1])
                    return prev;
                }, []);
                const ptsa = getCurvePoints(pts, minY, maxY, tension, isClosed, numOfSegments);
                context.moveTo(ptsa[0], ptsa[1]);
                for (let i = 2; i < ptsa.length - 1; i += 2)
                    context.lineTo(ptsa[i], ptsa[i + 1]);
            }

            this.drawDashedLine = function(
                x1,
                y1,
                x2,
                y2,
                color,
                dash=[3, 3],
                lineWidth=1,
            ) {
                color = color || '#434d6b';
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.lineWidth = lineWidth;
                context.strokeStyle = color;
                const originDash = context.getLineDash();
                context.setLineDash(dash);
                context.stroke();
                context.setLineDash(originDash);
            }

            this.drawLines = function(
                color,
                ...pos
            ) {
                color = color || '#434d6b';
                context.beginPath();
                context.moveTo(pos[0][0], pos[0][1]);
                pos.slice(1).map(e => context.lineTo(e[0], e[1]));
                context.lineWidth = 1;
                context.strokeStyle = color;
                context.stroke();
            }

            this.drawRoundRect = function(
                x,
                y,
                width,
                height,
                radius,
            ) {
                context.beginPath();
                context.moveTo(x, y + radius);

                // left line
                context.lineTo(x, y + height - radius);
                context.arcTo(
                    x, y + height,
                    x + radius, y + height,
                    radius,
                );

                // bottom line
                context.lineTo(x + width - radius, y + height);
                context.arcTo(
                    x + width, y + height,
                    x + width, y + height - radius,
                    radius,
                );

                // right line
                context.lineTo(x + width, y + radius);
                context.arcTo(
                    x + width, y,
                    x + width - radius, y,
                    radius,
                );

                // top line
                context.lineTo(x + radius, y);
                context.arcTo(
                    x, y,
                    x, y + radius,
                    radius,
                );

                context.closePath();
            }

            this.drawFreeRect = function(
                x1,
                y1,
                x2,
                y2,
                x3,
                y3,
                x4,
                y4,
                color,
                borderColor=null
            ) {
                color = color || '#ffffff'
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.lineTo(x3, y3);
                context.lineTo(x4, y4);
                context.closePath();
                context.fillStyle = color;
                if(borderColor != null) {
                    context.lineWidth = 2;
                    context.strokeStyle = borderColor;
                    context.stroke();
                }
                context.fill();
            }

            this.drawFreeRectStroke = function(
                x1,
                y1,
                x2,
                y2,
                x3,
                y3,
                x4,
                y4,
                color
            ) {
                color = color || '#ffffff'
                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.lineTo(x3, y3);
                context.lineTo(x4, y4);
                context.lineWidth = 1;
                context.strokeStyle = color;
                context.stroke();
            }

            this.drawTriangle = function(
                x1,
                y1,
                d,
                color
            ) {
                color = color || '#ffffff'
                context.beginPath();
                context.moveTo(x1, y1 - d);
                context.lineTo(x1 - d, y1 + d);
                context.lineTo(x1 + d, y1 + d);
                context.closePath();
                context.fillStyle = color;
                context.fill();
            }

            this.drawSquare = function(
                x1,
                y1,
                d,
                color,
            ) {
                color = color || '#ffffff'
                context.beginPath();
                context.moveTo(x1 - d, y1 - d);
                context.lineTo(x1 - d, y1 + d);
                context.lineTo(x1 + d, y1 + d);
                context.lineTo(x1 + d, y1 - d);
                context.closePath();
                context.fillStyle = color;
                context.fill();
            }

            this.drawPage = function(
                value,
                x1,
                y1,
                color,
                border=false
            ) {
                drawFreeRect(
                    context,
                    value + x1, y1,
                    value + x1 - 20, y1 + 14,
                    value + x1 - 20, y1 + 52,
                    value + x1, y1 + 38,
                    color,
                    border ? 'rgba(255,255,255,0.2)' : null,
                );
            }

            this.drawCircle = function(
                x,
                y,
                d,
                color
            ) {
                color = color || 'white';
                d =  d || 1;
                context.beginPath();
                context.arc(x, y, d, 0, 2*Math.PI);
                context.fillStyle = color;
                context.fill()
            }

            this.drawBullet = function(
                x,
                y,
                width=74
            ) {
                let grd = context.createLinearGradient(x, y, x + width, y);
                grd.addColorStop(0, '#1074fc');
                grd.addColorStop(1, 'rgba(37, 172, 254, 0)');

                context.beginPath();
                context.arc(x, y, 2, Math.PI / 2, Math.PI / 2 * 3);
                context.lineTo(x + width, y - 2);
                context.lineTo(x + width, y + 2);
                context.closePath();
                context.fillStyle = grd;
                context.fill();
                context.fillStyle = grd;
            }

            this.getCurvePoints = function(pts, minY, maxY, tension=0.5, isClosed=false, numOfSegments=16) {
                var _pts = [], res = [],    // clone array
                    x, y,           // our x,y coords
                    t1x, t2x, t1y, t2y, // tension vectors
                    c1, c2, c3, c4,     // cardinal points
                    st, t, i;       // steps based on num. of segments

                // clone array so we don't change the original
                _pts = pts.slice(0);

                // The algorithm require a previous and next point to the actual point array.
                // Check if we will draw closed or open curve.
                // If closed, copy end points to beginning and first points to end
                // If open, duplicate first points to befinning, end points to end
                if (isClosed) {
                    _pts.unshift(pts[pts.length - 1]);
                    _pts.unshift(pts[pts.length - 2]);
                    _pts.unshift(pts[pts.length - 1]);
                    _pts.unshift(pts[pts.length - 2]);
                    _pts.push(pts[0]);
                    _pts.push(pts[1]);
                }
                else {
                    _pts.unshift(pts[1]);   //copy 1. point and insert at beginning
                    _pts.unshift(pts[0]);
                    _pts.push(pts[pts.length - 2]); //copy last point and append
                    _pts.push(pts[pts.length - 1]);
                }

                // ok, lets start..

                // 1. loop goes through point array
                // 2. loop goes through each segment between the 2 pts + 1e point before and after
                for (i = 2; i < (_pts.length - 4); i += 2) {
                    for (t = 0; t <= numOfSegments; t++) {

                        // calc tension vectors
                        t1x = (_pts[i + 2] - _pts[i - 2]) * tension;
                        t2x = (_pts[i + 4] - _pts[i]) * tension;

                        t1y = (_pts[i + 3] - _pts[i - 1]) * tension;
                        t2y = (_pts[i + 5] - _pts[i + 1]) * tension;

                        // calc step
                        st = t / numOfSegments;

                        // calc cardinals
                        c1 = 2 * Math.pow(st, 3) - 3 * Math.pow(st, 2) + 1;
                        c2 = -(2 * Math.pow(st, 3)) + 3 * Math.pow(st, 2);
                        c3 = Math.pow(st, 3) - 2 * Math.pow(st, 2) + st;
                        c4 = Math.pow(st, 3) - Math.pow(st, 2);

                        // calc x and y cords with common control vectors
                        x = c1 * _pts[i] + c2 * _pts[i + 2] + c3 * t1x + c4 * t2x;
                        y = c1 * _pts[i + 1] + c2 * _pts[i + 3] + c3 * t1y + c4 * t2y;

                        //store points in array
                        res.push(x);
                        if (y > maxY) res.push(maxY);
                        else if(y < minY) res.push(minY)
                        else res.push(y);
                    }
                }

                return res;
            }

        }

        return CanvasBase;
    }
});

/***/ }),

/***/ "./node_modules/lodash.clonedeep/index.js":
/*!************************************************!*\
  !*** ./node_modules/lodash.clonedeep/index.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, true, true);
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = cloneDeep;


/***/ }),

/***/ "./node_modules/lodash.isequal/index.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash.isequal/index.js ***!
  \**********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    asyncTag = '[object AsyncFunction]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    nullTag = '[object Null]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    proxyTag = '[object Proxy]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    undefinedTag = '[object Undefined]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = isEqual;


/***/ }),

/***/ "./resources/css/app.css":
/*!*******************************!*\
  !*** ./resources/css/app.css ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/nprogress/nprogress.js":
/*!*********************************************!*\
  !*** ./node_modules/nprogress/nprogress.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */

;(function(root, factory) {

  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}

})(this, function() {
  var NProgress = {};

  NProgress.version = '0.2.0';

  var Settings = NProgress.settings = {
    minimum: 0.08,
    easing: 'ease',
    positionUsing: '',
    speed: 200,
    trickle: true,
    trickleRate: 0.02,
    trickleSpeed: 800,
    showSpinner: true,
    barSelector: '[role="bar"]',
    spinnerSelector: '[role="spinner"]',
    parent: 'body',
    template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
  };

  /**
   * Updates configuration.
   *
   *     NProgress.configure({
   *       minimum: 0.1
   *     });
   */
  NProgress.configure = function(options) {
    var key, value;
    for (key in options) {
      value = options[key];
      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;
    }

    return this;
  };

  /**
   * Last number.
   */

  NProgress.status = null;

  /**
   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.
   *
   *     NProgress.set(0.4);
   *     NProgress.set(1.0);
   */

  NProgress.set = function(n) {
    var started = NProgress.isStarted();

    n = clamp(n, Settings.minimum, 1);
    NProgress.status = (n === 1 ? null : n);

    var progress = NProgress.render(!started),
        bar      = progress.querySelector(Settings.barSelector),
        speed    = Settings.speed,
        ease     = Settings.easing;

    progress.offsetWidth; /* Repaint */

    queue(function(next) {
      // Set positionUsing if it hasn't already been set
      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();

      // Add transition
      css(bar, barPositionCSS(n, speed, ease));

      if (n === 1) {
        // Fade out
        css(progress, { 
          transition: 'none', 
          opacity: 1 
        });
        progress.offsetWidth; /* Repaint */

        setTimeout(function() {
          css(progress, { 
            transition: 'all ' + speed + 'ms linear', 
            opacity: 0 
          });
          setTimeout(function() {
            NProgress.remove();
            next();
          }, speed);
        }, speed);
      } else {
        setTimeout(next, speed);
      }
    });

    return this;
  };

  NProgress.isStarted = function() {
    return typeof NProgress.status === 'number';
  };

  /**
   * Shows the progress bar.
   * This is the same as setting the status to 0%, except that it doesn't go backwards.
   *
   *     NProgress.start();
   *
   */
  NProgress.start = function() {
    if (!NProgress.status) NProgress.set(0);

    var work = function() {
      setTimeout(function() {
        if (!NProgress.status) return;
        NProgress.trickle();
        work();
      }, Settings.trickleSpeed);
    };

    if (Settings.trickle) work();

    return this;
  };

  /**
   * Hides the progress bar.
   * This is the *sort of* the same as setting the status to 100%, with the
   * difference being `done()` makes some placebo effect of some realistic motion.
   *
   *     NProgress.done();
   *
   * If `true` is passed, it will show the progress bar even if its hidden.
   *
   *     NProgress.done(true);
   */

  NProgress.done = function(force) {
    if (!force && !NProgress.status) return this;

    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
  };

  /**
   * Increments by a random amount.
   */

  NProgress.inc = function(amount) {
    var n = NProgress.status;

    if (!n) {
      return NProgress.start();
    } else {
      if (typeof amount !== 'number') {
        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
      }

      n = clamp(n + amount, 0, 0.994);
      return NProgress.set(n);
    }
  };

  NProgress.trickle = function() {
    return NProgress.inc(Math.random() * Settings.trickleRate);
  };

  /**
   * Waits for all supplied jQuery promises and
   * increases the progress as the promises resolve.
   *
   * @param $promise jQUery Promise
   */
  (function() {
    var initial = 0, current = 0;

    NProgress.promise = function($promise) {
      if (!$promise || $promise.state() === "resolved") {
        return this;
      }

      if (current === 0) {
        NProgress.start();
      }

      initial++;
      current++;

      $promise.always(function() {
        current--;
        if (current === 0) {
            initial = 0;
            NProgress.done();
        } else {
            NProgress.set((initial - current) / initial);
        }
      });

      return this;
    };

  })();

  /**
   * (Internal) renders the progress bar markup based on the `template`
   * setting.
   */

  NProgress.render = function(fromStart) {
    if (NProgress.isRendered()) return document.getElementById('nprogress');

    addClass(document.documentElement, 'nprogress-busy');
    
    var progress = document.createElement('div');
    progress.id = 'nprogress';
    progress.innerHTML = Settings.template;

    var bar      = progress.querySelector(Settings.barSelector),
        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),
        parent   = document.querySelector(Settings.parent),
        spinner;
    
    css(bar, {
      transition: 'all 0 linear',
      transform: 'translate3d(' + perc + '%,0,0)'
    });

    if (!Settings.showSpinner) {
      spinner = progress.querySelector(Settings.spinnerSelector);
      spinner && removeElement(spinner);
    }

    if (parent != document.body) {
      addClass(parent, 'nprogress-custom-parent');
    }

    parent.appendChild(progress);
    return progress;
  };

  /**
   * Removes the element. Opposite of render().
   */

  NProgress.remove = function() {
    removeClass(document.documentElement, 'nprogress-busy');
    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');
    var progress = document.getElementById('nprogress');
    progress && removeElement(progress);
  };

  /**
   * Checks if the progress bar is rendered.
   */

  NProgress.isRendered = function() {
    return !!document.getElementById('nprogress');
  };

  /**
   * Determine which positioning CSS rule to use.
   */

  NProgress.getPositioningCSS = function() {
    // Sniff on document.body.style
    var bodyStyle = document.body.style;

    // Sniff prefixes
    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :
                       ('MozTransform' in bodyStyle) ? 'Moz' :
                       ('msTransform' in bodyStyle) ? 'ms' :
                       ('OTransform' in bodyStyle) ? 'O' : '';

    if (vendorPrefix + 'Perspective' in bodyStyle) {
      // Modern browsers with 3D support, e.g. Webkit, IE10
      return 'translate3d';
    } else if (vendorPrefix + 'Transform' in bodyStyle) {
      // Browsers without 3D support, e.g. IE9
      return 'translate';
    } else {
      // Browsers without translate() support, e.g. IE7-8
      return 'margin';
    }
  };

  /**
   * Helpers
   */

  function clamp(n, min, max) {
    if (n < min) return min;
    if (n > max) return max;
    return n;
  }

  /**
   * (Internal) converts a percentage (`0..1`) to a bar translateX
   * percentage (`-100%..0%`).
   */

  function toBarPerc(n) {
    return (-1 + n) * 100;
  }


  /**
   * (Internal) returns the correct CSS for changing the bar's
   * position given an n percentage, and speed and ease from Settings
   */

  function barPositionCSS(n, speed, ease) {
    var barCSS;

    if (Settings.positionUsing === 'translate3d') {
      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };
    } else if (Settings.positionUsing === 'translate') {
      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };
    } else {
      barCSS = { 'margin-left': toBarPerc(n)+'%' };
    }

    barCSS.transition = 'all '+speed+'ms '+ease;

    return barCSS;
  }

  /**
   * (Internal) Queues a function to be executed.
   */

  var queue = (function() {
    var pending = [];
    
    function next() {
      var fn = pending.shift();
      if (fn) {
        fn(next);
      }
    }

    return function(fn) {
      pending.push(fn);
      if (pending.length == 1) next();
    };
  })();

  /**
   * (Internal) Applies css properties to an element, similar to the jQuery 
   * css method.
   *
   * While this helper does assist with vendor prefixed property names, it 
   * does not perform any manipulation of values prior to setting styles.
   */

  var css = (function() {
    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],
        cssProps    = {};

    function camelCase(string) {
      return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function(match, letter) {
        return letter.toUpperCase();
      });
    }

    function getVendorProp(name) {
      var style = document.body.style;
      if (name in style) return name;

      var i = cssPrefixes.length,
          capName = name.charAt(0).toUpperCase() + name.slice(1),
          vendorName;
      while (i--) {
        vendorName = cssPrefixes[i] + capName;
        if (vendorName in style) return vendorName;
      }

      return name;
    }

    function getStyleProp(name) {
      name = camelCase(name);
      return cssProps[name] || (cssProps[name] = getVendorProp(name));
    }

    function applyCss(element, prop, value) {
      prop = getStyleProp(prop);
      element.style[prop] = value;
    }

    return function(element, properties) {
      var args = arguments,
          prop, 
          value;

      if (args.length == 2) {
        for (prop in properties) {
          value = properties[prop];
          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);
        }
      } else {
        applyCss(element, args[1], args[2]);
      }
    }
  })();

  /**
   * (Internal) Determines if an element or space separated list of class names contains a class name.
   */

  function hasClass(element, name) {
    var list = typeof element == 'string' ? element : classList(element);
    return list.indexOf(' ' + name + ' ') >= 0;
  }

  /**
   * (Internal) Adds a class to an element.
   */

  function addClass(element, name) {
    var oldList = classList(element),
        newList = oldList + name;

    if (hasClass(oldList, name)) return; 

    // Trim the opening space.
    element.className = newList.substring(1);
  }

  /**
   * (Internal) Removes a class from an element.
   */

  function removeClass(element, name) {
    var oldList = classList(element),
        newList;

    if (!hasClass(element, name)) return;

    // Replace the class name.
    newList = oldList.replace(' ' + name + ' ', ' ');

    // Trim the opening and closing spaces.
    element.className = newList.substring(1, newList.length - 1);
  }

  /**
   * (Internal) Gets a space separated list of the class names on the element. 
   * The list is wrapped with a single space on each end to facilitate finding 
   * matches within the list.
   */

  function classList(element) {
    return (' ' + (element.className || '') + ' ').replace(/\s+/gi, ' ');
  }

  /**
   * (Internal) Removes an element from the DOM.
   */

  function removeElement(element) {
    element && element.parentNode && element.parentNode.removeChild(element);
  }

  return NProgress;
});



/***/ }),

/***/ "./node_modules/object-inspect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/object-inspect/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var match = String.prototype.match;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
var isEnumerable = Object.prototype.propertyIsEnumerable;

var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
    [].__proto__ === Array.prototype // eslint-disable-line no-proto
        ? function (O) {
            return O.__proto__; // eslint-disable-line no-proto
        }
        : null
);

var inspectCustom = __webpack_require__(/*! ./util.inspect */ "?4f7e").custom;
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
var toStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag !== 'undefined' ? Symbol.toStringTag : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (
        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
            : opts.maxStringLength !== null
        )
    ) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean') {
        throw new TypeError('option "customInspect", if provided, must be `true` or `false`');
    }

    if (
        has(opts, 'indent')
        && opts.indent !== null
        && opts.indent !== '\t'
        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
    ) {
        throw new TypeError('options "indent" must be "\\t", an integer > 0, or `null`');
    }

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        return String(obj);
    }
    if (typeof obj === 'bigint') {
        return String(obj) + 'n';
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return isArray(obj) ? '[Array]' : '[Object]';
    }

    var indent = getIndent(opts, depth);

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from, noIndent) {
        if (from) {
            seen = seen.slice();
            seen.push(from);
        }
        if (noIndent) {
            var newOpts = {
                depth: opts.depth
            };
            if (has(opts, 'quoteStyle')) {
                newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function') {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + keys.join(', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? String(obj).replace(/^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
            return '[' + indentedJoin(xs, indent) + ']';
        }
        return '[ ' + xs.join(', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + parts.join(', ') + ' }';
    }
    if (typeof obj === 'object' && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function') {
            return obj[inspectSymbol]();
        } else if (typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function (value, key) {
            mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
        });
        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function (value) {
            setParts.push(inspect(value, obj));
        });
        return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
        return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? '' : 'null prototype';
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? toStr(obj).slice(8, -1) : protoTag ? 'Object' : '';
        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
        var tag = constructorTag + (stringTag || protoTag ? '[' + [].concat(stringTag || [], protoTag || []).join(': ') + '] ' : '');
        if (ys.length === 0) { return tag + '{}'; }
        if (indent) {
            return tag + '{' + indentedJoin(ys, indent) + '}';
        }
        return tag + '{ ' + ys.join(', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return String(s).replace(/"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }

// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
function isSymbol(obj) {
    if (hasShammedSymbols) {
        return obj && typeof obj === 'object' && obj instanceof Symbol;
    }
    if (typeof obj === 'symbol') {
        return true;
    }
    if (!obj || typeof obj !== 'object' || !symToString) {
        return false;
    }
    try {
        symToString.call(obj);
        return true;
    } catch (e) {}
    return false;
}

function isBigInt(obj) {
    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
        return false;
    }
    try {
        bigIntValueOf.call(obj);
        return true;
    } catch (e) {}
    return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakRefDeref.call(x);
        return true;
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
        return inspectString(str.slice(0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b',
        9: 't',
        10: 'n',
        12: 'f',
        13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16).toUpperCase();
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : entries.join(', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], '\n') >= 0) {
            return false;
        }
    }
    return true;
}

function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
        baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
        baseIndent = Array(opts.indent + 1).join(' ');
    } else {
        return null;
    }
    return {
        base: baseIndent,
        prev: Array(depth + 1).join(baseIndent)
    };
}

function indentedJoin(xs, indent) {
    if (xs.length === 0) { return ''; }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + xs.join(',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
            symMap['$' + syms[k]] = syms[k];
        }
    }

    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
            continue; // eslint-disable-line no-restricted-syntax, no-continue
        } else if ((/[^\w$]/).test(key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    if (typeof gOPS === 'function') {
        for (var j = 0; j < syms.length; j++) {
            if (isEnumerable.call(obj, syms[j])) {
                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
            }
        }
    }
    return xs;
}


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/qs/lib/formats.js":
/*!****************************************!*\
  !*** ./node_modules/qs/lib/formats.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = {
    'default': Format.RFC3986,
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return String(value);
        }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
};


/***/ }),

/***/ "./node_modules/qs/lib/index.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "./node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "./node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "./node_modules/qs/lib/parse.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/parse.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

var parseArrayValue = function (val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
        return val.split(',');
    }

    return val;
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = utils.maybeMap(
                parseArrayValue(part.slice(pos + 1), options),
                function (encodedVal) {
                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
                }
            );
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options, valuesParsed);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
        obj = utils.merge(obj, newObj, options);
    }

    if (options.allowSparse === true) {
        return obj;
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "./node_modules/qs/lib/stringify.js":
/*!******************************************!*\
  !*** ./node_modules/qs/lib/stringify.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getSideChannel = __webpack_require__(/*! side-channel */ "./node_modules/side-channel/index.js");
var utils = __webpack_require__(/*! ./utils */ "./node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    format,
    formatter,
    encodeValuesOnly,
    charset,
    sideChannel
) {
    var obj = object;

    if (sideChannel.has(object)) {
        throw new RangeError('Cyclic object value');
    }

    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = utils.maybeMap(obj, function (value) {
            if (value instanceof Date) {
                return serializeDate(value);
            }
            return value;
        });
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray(obj)) {
        // we need to join elements in
        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : undefined }];
    } else if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        var value = typeof key === 'object' && key.value !== undefined ? key.value : obj[key];

        if (skipNulls && value === null) {
            continue;
        }

        var keyPrefix = isArray(obj)
            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix
            : prefix + (allowDots ? '.' + key : '[' + key + ']');

        sideChannel.set(object, true);
        var valueSideChannel = getSideChannel();
        pushToArray(values, stringify(
            value,
            keyPrefix,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encoder,
            filter,
            sort,
            allowDots,
            serializeDate,
            format,
            formatter,
            encodeValuesOnly,
            charset,
            valueSideChannel
        ));
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        format: format,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.format,
            options.formatter,
            options.encodeValuesOnly,
            options.charset,
            sideChannel
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "./node_modules/qs/lib/utils.js":
/*!**************************************!*\
  !*** ./node_modules/qs/lib/utils.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var formats = __webpack_require__(/*! ./formats */ "./node_modules/qs/lib/formats.js");

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

var maybeMap = function maybeMap(val, fn) {
    if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
            mapped.push(fn(val[i]));
        }
        return mapped;
    }
    return fn(val);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
};


/***/ }),

/***/ "./node_modules/side-channel/index.js":
/*!********************************************!*\
  !*** ./node_modules/side-channel/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");
var callBound = __webpack_require__(/*! call-bind/callBound */ "./node_modules/call-bind/callBound.js");
var inspect = __webpack_require__(/*! object-inspect */ "./node_modules/object-inspect/index.js");

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);

var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);

/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */
var listGetNode = function (list, key) { // eslint-disable-line consistent-return
	for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			curr.next = list.next;
			list.next = curr; // eslint-disable-line no-param-reassign
			return curr;
		}
	}
};

var listGet = function (objects, key) {
	var node = listGetNode(objects, key);
	return node && node.value;
};
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	} else {
		// Prepend the new node to the beginning of the list
		objects.next = { // eslint-disable-line no-param-reassign
			key: key,
			next: objects.next,
			value: value
		};
	}
};
var listHas = function (objects, key) {
	return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
	var $wm;
	var $m;
	var $o;
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			}
		},
		get: function (key) { // eslint-disable-line consistent-return
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapGet($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapGet($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listGet($o, key);
				}
			}
		},
		has: function (key) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if ($wm) {
					return $weakMapHas($wm, key);
				}
			} else if ($Map) {
				if ($m) {
					return $mapHas($m, key);
				}
			} else {
				if ($o) { // eslint-disable-line no-lonely-if
					return listHas($o, key);
				}
			}
			return false;
		},
		set: function (key, value) {
			if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
				if (!$wm) {
					$wm = new $WeakMap();
				}
				$weakMapSet($wm, key, value);
			} else if ($Map) {
				if (!$m) {
					$m = new $Map();
				}
				$mapSet($m, key, value);
			} else {
				if (!$o) {
					/*
					 * Initialize the linked list as an empty node, so that we don't have
					 * to special-case handling of the first node: we can always refer to
					 * it as (previous node).next, instead of something like (list).head
					 */
					$o = { key: {}, next: null };
				}
				listSet($o, key, value);
			}
		}
	};
	return channel;
};


/***/ }),

/***/ "./node_modules/vue-graph/src/base/created.js":
/*!****************************************************!*\
  !*** ./node_modules/vue-graph/src/base/created.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    created: function() {
        this.brushes = [];
        this.widgets = [];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/methods-block.js":
/*!**********************************************************!*\
  !*** ./node_modules/vue-graph/src/base/methods-block.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    methods: {
        initGraphAxes: function() {
            let xAxis = {
                type : this.axisFullMode ? 'fullblock' : 'block',
                domain : this.labels,
                line : this.axisXStyle == "none" ? false : this.axisXStyle,
                hide : this.axisXStyle == "hidden",
                orient : this.axisXPosition,
                textRotate: -this.textRotateX
            }

            let yAxis = {
                type : 'range',
                domain : this.getAxisMinAndMax(),
                step : this.axisStep,
                line : this.axisYStyle == "none" ? false : this.axisYStyle,
                hide : this.axisYStyle == "hidden",
                orient : this.axisYPosition,
                textRotate: -this.textRotateY
            }

            return {
                x : (this.axisReverse) ? yAxis : xAxis,
                y : (this.axisReverse) ? xAxis : yAxis,
                data : this.convertToData(this.values)
            }
        }
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/methods-block3d.js":
/*!************************************************************!*\
  !*** ./node_modules/vue-graph/src/base/methods-block3d.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    methods: {
        initGraphAxes: function() {
            let xAxis = {
                type : 'block',
                domain : this.labels,
                line : this.axisXStyle == "solid",
                hide : this.axisXStyle == "hidden"
            }

            let yAxis = {
                type : 'range',
                domain : this.getAxisMinAndMax(),
                step : this.axisStep,
                line : this.axisYStyle == "solid",
                hide : this.axisYStyle == "hidden"
            }

            let zAxis = {
                type : 'block',
                domain : this.names,
                line : this.axisZStyle == "solid",
                hide : this.axisZStyle == "hidden"
            }

            return {
                x : xAxis,
                y : yAxis,
                z : zAxis,
                depth : this.depth,
                perspective : this.perspective,
                degree : {
                    x: this.angleX,
                    y: this.angleY,
                    z: this.angleZ
                },
                data : this.convertToData(this.values)
            }
        }
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/methods-dateblock.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-graph/src/base/methods-dateblock.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    methods: {
        initGraphAxes: function() {
            let xAxis = {
                type : 'dateblock',
                domain : this.labels,
                interval : this.axisInterval,
                format : this.axisFormat,
                line : this.axisXStyle == "none" ? false : this.axisXStyle,
                hide : this.axisXStyle == "hidden",
                orient : this.axisXPosition,
                textRotate: -this.textRotateX
            }

            let yAxis = {
                type : 'range',
                domain : this.getAxisMinAndMax(),
                step : this.axisStep,
                line : this.axisYStyle == "none" ? false : this.axisYStyle,
                hide : this.axisYStyle == "hidden",
                orient : this.axisYPosition,
                textRotate: -this.textRotateY
            }

            return {
                x : (this.axisReverse) ? yAxis : xAxis,
                y : (this.axisReverse) ? xAxis : yAxis,
                data : this.convertToData(this.values)
            }
        }
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/methods-timerange.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-graph/src/base/methods-timerange.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    methods: {
        convertToData: function(values) {
            let util = juijs_chart__WEBPACK_IMPORTED_MODULE_0__.default.include('util.base');
            let data = [];

            for(let i = 0; i < values.length; i++) {
                let val = values[i];

                if(util.typeCheck('array', val)) {
                    data.push({
                        '0': val[0],
                        '1': val[1]
                    });
                }
            }

            return data;
        },
        initGraphAxes: function() {
            let xAxis = {
                type : 'date',
                domain : this.labels,
                interval : this.axisInterval,
                format : this.axisFormat,
                line : this.axisXStyle == "none" ? false : this.axisXStyle,
                hide : this.axisXStyle == "hidden",
                orient : this.axisXPosition,
                key : '0',
                textRotate: -this.textRotateX
            }

            let yAxis = {
                type : 'range',
                domain : [ this.axisMin, this.axisMax ],
                step : this.axisStep,
                line : this.axisYStyle == "none" ? false : this.axisYStyle,
                hide : this.axisYStyle == "hidden",
                orient : this.axisYPosition,
                textRotate: -this.textRotateY
            }

            return {
                x : (this.axisReverse) ? yAxis : xAxis,
                y : (this.axisReverse) ? xAxis : yAxis,
                data : this.convertToData(this.values)
            }
        }
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/methods.js":
/*!****************************************************!*\
  !*** ./node_modules/vue-graph/src/base/methods.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    methods: {
        convertToData: function(values) {
            let util = juijs_chart__WEBPACK_IMPORTED_MODULE_0__.default.include('util.base');
            let data = [];

            for(let i = 0; i < values.length; i++) {
                let val = values[i];

                if(util.typeCheck('array', val)) {
                    for(let j = 0; j < val.length; j++) {
                        if(i == 0) {
                            data.push({});
                        }

                        let row = data[j];
                        row[''+i] = val[j]
                    }
                } else if(util.typeCheck('number', val)) {
                    data.push({ '0' : val });
                }
            }

            return data;
        },
        getAxisMinAndMax: function() {
            let min = this.axisMin;
            let max = this.axisMax;

            if(min != max) {
                return [ min, max ]
            }

            return function(data) {
                const max = Math.max.apply(null, Object.values(data));
                return max == 0 ? 1 : max;
            }
        },
        initGraphBrushes: function() {
            for(let brush of this.brushes) {
                this.chart.addBrush(brush);
            }

            // 포커스 브러쉬는 기본 옵션으로 구현하였음
            if(this.focusStart != -1 && this.focusEnd != -1) {
                const brush = {
                    type: 'focus',
                    start: this.focusStart,
                    end: this.focusEnd
                };

                this.brushes.push(brush);
                this.chart.addBrush(brush);
            }
        },
        initGraphWidgets: function() {
            for(let widget of this.widgets) {
                this.chart.addWidget(widget);
            }
        },

        // TODO: 인터페이스 함수, 타입별로 따로 구현해야 함
        initGraphAxes: function() {}
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/mounted-animation.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-graph/src/base/mounted-animation.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_widget_raycast_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! juijs-chart/src/widget/raycast.js */ "./node_modules/juijs-chart/src/widget/raycast.js");
/* harmony import */ var juijs_chart_src_widget_canvas_picker_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! juijs-chart/src/widget/canvas/picker.js */ "./node_modules/juijs-chart/src/widget/canvas/picker.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    computed: {
        realWidth: function() {
            return this.width == 0 ? "100%" : this.width;
        }
    },
    mounted: function() {
        const self = this;

        if(this.brushes.length == 0) {
            throw new Error('[Vue Graph error]: At least one brush must be added to \'brushes\' variable.')
        }

        juijs_chart__WEBPACK_IMPORTED_MODULE_0__.default.use(juijs_chart_src_widget_raycast_js__WEBPACK_IMPORTED_MODULE_1__.default, juijs_chart_src_widget_canvas_picker_js__WEBPACK_IMPORTED_MODULE_2__.default);

        this.animation = juijs_chart__WEBPACK_IMPORTED_MODULE_0__.default.create('chart.animation', this.$el, {
            width: this.realWidth,
            height: this.height,
            padding: {
                top: this.paddingTop,
                right: this.paddingRight,
                bottom: this.paddingBottom,
                left: this.paddingLeft
            },
            event: {
                'chart.click': function(e) {
                    self.$emit('inside#click', e);
                },
                'chart.dblclick': function(e) {
                    self.$emit('inside#dblclick', e);
                },
                'chart.rclick': function(e) {
                    self.$emit('inside#rclick', e);
                },
                'chart.mouseover': function(e) {
                    self.$emit('inside#mouseover', e);
                },
                'chart.mouseout': function(e) {
                    self.$emit('inside#mouseout', e);
                },
                'chart.mousemove': function(e) {
                    self.$emit('inside#mousemove', e);
                },
                'chart.mousedown': function(e) {
                    self.$emit('inside#mousedown', e);
                },
                'chart.mouseup': function(e) {
                    self.$emit('inside#mouseup', e);
                },
                'bg.click': function(e) {
                    self.$emit('outside#click', e);
                },
                'bg.dblclick': function(e) {
                    self.$emit('outside#dblclick', e);
                },
                'bg.rclick': function(e) {
                    self.$emit('outside#rclick', e);
                },
                'bg.mouseover': function(e) {
                    self.$emit('outside#mouseover', e);
                },
                'bg.mouseout': function(e) {
                    self.$emit('outside#mouseout', e);
                },
                'bg.mousemove': function(e) {
                    self.$emit('outside#mousemove', e);
                },
                'bg.mousedown': function(e) {
                    self.$emit('outside#mousedown', e);
                },
                'bg.mouseup': function(e) {
                    self.$emit('outside#mouseup', e);
                },
                'raycast.click': function(obj, e) {
                    self.$emit('click', obj, e);
                },
                'raycast.dblclick': function(obj, e) {
                    self.$emit('dblclick', obj, e);
                },
                'raycast.rclick': function(obj, e) {
                    self.$emit('rclick', obj, e);
                },
                'picker.click': function(obj, e) {
                    self.$emit('click', obj, e);
                },
                'picker.dblclick': function(obj, e) {
                    self.$emit('dblclick', obj, e);
                },
            },
            format: this.format,
            theme: this.theme,
            style: this.styles,
            render: false,
            axis: this.initGraphAxes(),
            interval: this.renderInterval
        });

        this.chart = this.animation.builder;
        this.initGraphBrushes();
        this.initGraphWidgets();

        if(this.chart.axis(0).x != null && this.chart.axis(0).x != null)
            this.chart.addWidget({ type: 'raycast' });
        this.chart.addWidget({ type: 'canvas.picker' });
        this.chart.render(true);

        this.animation.run(function(runningTime) {
            if(typeof(self.renderHandler) == "function") {
                self.renderHandler.call(this, runningTime);
            }
        });
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/mounted.js":
/*!****************************************************!*\
  !*** ./node_modules/vue-graph/src/base/mounted.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_focus_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! juijs-chart/src/brush/focus.js */ "./node_modules/juijs-chart/src/brush/focus.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    computed: {
        realWidth: function() {
            return this.width == 0 ? "100%" : this.width;
        }
    },
    mounted: function() {
        var self = this;

        if(this.brushes.length == 0) {
            throw new Error('[Vue Graph error]: At least one brush must be added to \'brushes\' variable.')
        }

        juijs_chart__WEBPACK_IMPORTED_MODULE_0__.default.use(juijs_chart_src_brush_focus_js__WEBPACK_IMPORTED_MODULE_1__.default);

        this.chart = juijs_chart__WEBPACK_IMPORTED_MODULE_0__.default.create('chart.builder', this.$el, {
            width: this.realWidth,
            height: this.height,
            padding: {
                top: this.paddingTop,
                right: this.paddingRight,
                bottom: this.paddingBottom,
                left: this.paddingLeft
            },
            event: {
                'chart.click': function(e) {
                    self.$emit('inside#click', e);
                },
                'chart.dblclick': function(e) {
                    self.$emit('inside#dblclick', e);
                },
                'chart.rclick': function(e) {
                    self.$emit('inside#rclick', e);
                },
                'chart.mouseover': function(e) {
                    self.$emit('inside#mouseover', e);
                },
                'chart.mouseout': function(e) {
                    self.$emit('inside#mouseout', e);
                },
                'chart.mousemove': function(e) {
                    self.$emit('inside#mousemove', e);
                },
                'chart.mousedown': function(e) {
                    self.$emit('inside#mousedown', e);
                },
                'chart.mouseup': function(e) {
                    self.$emit('inside#mouseup', e);
                },
                'bg.click': function(e) {
                    self.$emit('outside#click', e);
                },
                'bg.dblclick': function(e) {
                    self.$emit('outside#dblclick', e);
                },
                'bg.rclick': function(e) {
                    self.$emit('outside#rclick', e);
                },
                'bg.mouseover': function(e) {
                    self.$emit('outside#mouseover', e);
                },
                'bg.mouseout': function(e) {
                    self.$emit('outside#mouseout', e);
                },
                'bg.mousemove': function(e) {
                    self.$emit('outside#mousemove', e);
                },
                'bg.mousedown': function(e) {
                    self.$emit('outside#mousedown', e);
                },
                'bg.mouseup': function(e) {
                    self.$emit('outside#mouseup', e);
                },
                'click': function(obj, e) {
                    self.$emit('click', obj, e);
                },
                'dblclick': function(obj, e) {
                    self.$emit('dblclick', obj, e);
                },
                'rclick': function(obj, e) {
                    self.$emit('rclick', obj, e);
                },
                'mouseover': function(obj, e) {
                    self.$emit('mouseover', obj, e);
                },
                'mouseout': function(obj, e) {
                    self.$emit('mouseout', obj, e);
                },
                'mousemove': function(obj, e) {
                    self.$emit('mousemove', obj, e);
                },
                'mousedown': function(obj, e) {
                    self.$emit('mousedown', obj, e);
                },
                'mouseup': function(obj, e) {
                    self.$emit('mouseup', obj, e);
                },
                'legend.filter': function(target) {
                    self.$emit('legends#filter', target);
                }
            },
            format: this.format,
            theme: this.theme,
            style: this.styles,
            render: false,
            axis: this.initGraphAxes()
        });

        this.initGraphBrushes();
        this.initGraphWidgets();

        this.chart.render(true);
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/props-animation.js":
/*!************************************************************!*\
  !*** ./node_modules/vue-graph/src/base/props-animation.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    props: {
        renderInterval: {
            type: Number,
            required: false,
            default: 200
        },
        renderHandler: {
            type: Function,
            required: false,
            default: null
        },
        renderStop: {
            type: Boolean,
            required: false,
            default: false
        }
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/props-block.js":
/*!********************************************************!*\
  !*** ./node_modules/vue-graph/src/base/props-block.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    props: {
        axisMin: {
            type: Number,
            required: false,
            default: 0
        },
        axisMax: {
            type: Number,
            required: false,
            default: 0
        },
        axisStep: {
            type: Number,
            required: false,
            default: 10
        },

        axisXStyle: {
            type: String,
            required: false,
            default: 'solid' // or dotted, gradient, hidden
        },
        axisYStyle: {
            type: String,
            required: false,
            default: 'solid' // or dotted, gradient, hidden
        },
        axisXPosition: {
            type: String,
            required: false,
            default: 'bottom'
        },
        axisYPosition: {
            type: String,
            required: false,
            default: 'left'
        },
        axisReverse: {
            type: Boolean,
            required: false,
            default: false
        },
        axisFullMode: {
            type: Boolean,
            required: false,
            default: false
        },

        textRotateX: {
            type: Number,
            required: false,
            default: 0
        },
        textRotateY: {
            type: Number,
            required: false,
            default: 0
        }
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/props-block3d.js":
/*!**********************************************************!*\
  !*** ./node_modules/vue-graph/src/base/props-block3d.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    props: {
        axisMin: {
            type: Number,
            required: false,
            default: 0
        },
        axisMax: {
            type: Number,
            required: false,
            default: 0
        },
        axisStep: {
            type: Number,
            required: false,
            default: 10
        },

        axisXStyle: {
            type: String,
            required: false,
            default: 'solid' // or hidden
        },
        axisYStyle: {
            type: String,
            required: false,
            default: 'solid' // or hidden
        },
        axisZStyle: {
            type: String,
            required: false,
            default: 'solid' // or hidden
        },
        angleX: {
            type: Number,
            required: false,
            default: 30
        },
        angleY: {
            type: Number,
            required: false,
            default: 20
        },
        angleZ: {
            type: Number,
            required: false,
            default: 0
        },

        depth: {
            type: Number,
            required: true
        },
        perspective: {
            type: Number,
            required: false,
            default: 0.6
        }
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/props-dateblock.js":
/*!************************************************************!*\
  !*** ./node_modules/vue-graph/src/base/props-dateblock.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    props: {
        axisMin: {
            type: Number,
            required: false,
            default: 0
        },
        axisMax: {
            type: Number,
            required: false,
            default: 0
        },
        axisStep: {
            type: Number,
            required: false,
            default: 10
        },

        axisXStyle: {
            type: String,
            required: false,
            default: 'solid' // or dotted, gradient, hidden
        },
        axisYStyle: {
            type: String,
            required: false,
            default: 'solid' // or dotted, gradient, hidden
        },
        axisXPosition: {
            type: String,
            required: false,
            default: 'bottom'
        },
        axisYPosition: {
            type: String,
            required: false,
            default: 'left'
        },
        axisReverse: {
            type: Boolean,
            required: false,
            default: false
        },

        axisInterval: {
            type: Number,
            required: true,
            default: 1000 * 60 * 60 // 1시간
        },
        axisFormat: {
            type: [ String, Function ],
            required: true,
            default: 'HH' // 1시간
        },

        textRotateX: {
            type: Number,
            required: false,
            default: 0
        },
        textRotateY: {
            type: Number,
            required: false,
            default: 0
        }
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/props-timerange.js":
/*!************************************************************!*\
  !*** ./node_modules/vue-graph/src/base/props-timerange.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    props: {
        axisMin: {
            type: Number,
            required: false,
            default: 0
        },
        axisMax: {
            type: Number,
            required: false,
            default: 100
        },
        axisStep: {
            type: Number,
            required: false,
            default: 10
        },

        axisXStyle: {
            type: String,
            required: false,
            default: 'solid' // or dotted, gradient, hidden
        },
        axisYStyle: {
            type: String,
            required: false,
            default: 'solid' // or dotted, gradient, hidden
        },
        axisXPosition: {
            type: String,
            required: false,
            default: 'bottom'
        },
        axisYPosition: {
            type: String,
            required: false,
            default: 'left'
        },
        axisReverse: {
            type: Boolean,
            required: false,
            default: false
        },

        axisInterval: {
            type: Number,
            required: true,
            default: 1000 * 60 * 60 // 1시간
        },
        axisFormat: {
            type: [ String, Function ],
            required: true,
            default: 'HH' // 1시간
        },

        textRotateX: {
            type: Number,
            required: false,
            default: 0
        },
        textRotateY: {
            type: Number,
            required: false,
            default: 0
        }
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/props.js":
/*!**************************************************!*\
  !*** ./node_modules/vue-graph/src/base/props.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    props: {
        theme: {
            type: String,
            required: false,
            default: "classic"
        },
        styles: {
            type: Object,
            required: false
        },
        colors: {
            type: [ Array, Function ],
            required: false
        },
        clip: {
            type: Boolean,
            required: false,
            default: false
        },
        format: {
            type: Function,
            required: false
        },
        width: {
            type: Number,
            required: false,
            default: 0
        },
        height: {
            type: Number,
            required: true
        },
        labels: {
            type: Array,
            required: false
        },
        values: {
            type: Array,
            required: false
        },
        paddingTop: {
            type: Number,
            required: false,
            default: 50
        },
        paddingRight: {
            type: Number,
            required: false,
            default: 50
        },
        paddingBottom: {
            type: Number,
            required: false,
            default: 50
        },
        paddingLeft: {
            type: Number,
            required: false,
            default: 50
        },
        focusStart: {
            type: Number,
            required: false,
            default: -1
        },
        focusEnd: {
            type: Number,
            required: false,
            default: -1
        }
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/watch-animation.js":
/*!************************************************************!*\
  !*** ./node_modules/vue-graph/src/base/watch-animation.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    watch: {
        renderStop: function(newVal, oldVal) {
            if(newVal) {
                this.animation.stop();
            } else {
                const self = this;
                this.animation.run(function(runningTime) {
                    if(typeof(self.renderHandler) == "function") {
                        self.renderHandler.call(this, runningTime);
                    }
                });
            }
        }
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/base/watch.js":
/*!**************************************************!*\
  !*** ./node_modules/vue-graph/src/base/watch.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    watch: {
        width: function(newVal, oldVal) {
            this.chart.setSize(newVal, this.height);
            this.chart.render()
        },
        height: function(newVal, oldVal) {
            this.chart.setSize(this.width, newVal);
            this.chart.render()
        },
        labels: function(newVal, oldVal) { // watch it
            this.chart.axis(0).set(this.axisReverse ? 'y' : 'x', { domain: newVal });
            this.chart.render();
        },
        values: function(newVal, oldVal) { // watch it
            this.chart.axis(0).update(this.convertToData(newVal));
            this.chart.render();
        },
        axisMin: function(newVal, oldVal) {
            this.chart.axis(0).set(this.axisReverse ? 'x' : 'y', { domain: [ newVal, this.axisMax ] });
            this.chart.render();
        },
        axisMax: function(newVal, oldVal) {
            this.chart.axis(0).set(this.axisReverse ? 'x' : 'y', { domain: [ this.axisMin, newVal ] });
            this.chart.render();
        },
        focusStart: function(newVal, oldVal) {
            if(newVal == oldVal) return;
            this.brushes.forEach((brush, index) => {
                if(brush.type == 'focus') {
                    this.chart.updateBrush(index, { start: newVal });
                    this.chart.render();
                }
            });
        },
        focusEnd: function(newVal, oldVal) {
            if(newVal == oldVal) return;
            this.brushes.forEach((brush, index) => {
                if(brush.type == 'focus') {
                    this.chart.updateBrush(index, { end: newVal });
                    this.chart.render();
                }
            });
        },
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/activebubble.js":
/*!***************************************************************!*\
  !*** ./node_modules/vue-graph/src/components/activebubble.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_watch_animation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/watch-animation.js */ "./node_modules/vue-graph/src/base/watch-animation.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_animation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/mounted-animation.js */ "./node_modules/vue-graph/src/base/mounted-animation.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_animation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/props-animation.js */ "./node_modules/vue-graph/src/base/props-animation.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_canvas_activebubble_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! juijs-chart/src/brush/canvas/activebubble.js */ "./node_modules/juijs-chart/src/brush/canvas/activebubble.js");












juijs_chart__WEBPACK_IMPORTED_MODULE_8__.default.use(juijs_chart_src_brush_canvas_activebubble_js__WEBPACK_IMPORTED_MODULE_9__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-activebubble',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_watch_animation_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_mounted_animation_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_props_animation_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_7__.default ],
    props: {
        gravity: {
            type: Number,
            required: false,
            default: 0.2
        },
        radius: {
            type: Number,
            required: false,
            default: 20
        },
        opacity: {
            type: Number,
            required: false,
            default: 1
        }
    },
    methods: {
        convertToData: function(values) {
            let data = [];

            for(let i = 0; i < values.length; i++) {
                let row = values[i];

                if(row.length == 2) {
                    data.push({
                        '0': row[0],
                        '1': row[1]
                    });
                }
            }

            return data;
        },
        initGraphAxes: function() {
            return {
                keymap: {
                    'startTime': '0',
                    'duration': '1'
                },
                data: this.convertToData(this.values)
            }
        }
    },
    beforeMount: function() {
        this.brushes = [{
            type: 'canvas.activebubble',
            clip: this.clip,
            colors: this.colors,
            gravity: this.gravity,
            radius: this.radius,
            opacity: this.opacity
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/area-dateblock.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vue-graph/src/components/area-dateblock.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./area.js */ "./node_modules/vue-graph/src/components/area.js");
/* harmony import */ var _base_props_dateblock_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/props-dateblock.js */ "./node_modules/vue-graph/src/base/props-dateblock.js");
/* harmony import */ var _base_methods_dateblock_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/methods-dateblock.js */ "./node_modules/vue-graph/src/base/methods-dateblock.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-area-dateblock',
    mixins: [ _area_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_props_dateblock_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_methods_dateblock_js__WEBPACK_IMPORTED_MODULE_2__.default ]
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/area-timerange.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vue-graph/src/components/area-timerange.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./area.js */ "./node_modules/vue-graph/src/components/area.js");
/* harmony import */ var _base_props_timerange_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/props-timerange.js */ "./node_modules/vue-graph/src/base/props-timerange.js");
/* harmony import */ var _base_methods_timerange_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/methods-timerange.js */ "./node_modules/vue-graph/src/base/methods-timerange.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-area-timerange',
    mixins: [ _area_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_props_timerange_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_methods_timerange_js__WEBPACK_IMPORTED_MODULE_2__.default ],
    beforeMount: function() {
        this.brushes = [{
            type: 'stackarea',
            target: '1',
            clip: this.clip,
            colors: this.colors,
            symbol: this.shape,
            opacity: this.opacity,
            line: this.borderLine,
            display: this.display
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/area.js":
/*!*******************************************************!*\
  !*** ./node_modules/vue-graph/src/components/area.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/mounted.js */ "./node_modules/vue-graph/src/base/mounted.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_block_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props-block.js */ "./node_modules/vue-graph/src/base/props-block.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var _base_methods_block_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/methods-block.js */ "./node_modules/vue-graph/src/base/methods-block.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_line_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! juijs-chart/src/brush/line.js */ "./node_modules/juijs-chart/src/brush/line.js");
/* harmony import */ var juijs_chart_src_brush_area_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! juijs-chart/src/brush/area.js */ "./node_modules/juijs-chart/src/brush/area.js");
/* harmony import */ var juijs_chart_src_brush_stackarea_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! juijs-chart/src/brush/stackarea.js */ "./node_modules/juijs-chart/src/brush/stackarea.js");














juijs_chart__WEBPACK_IMPORTED_MODULE_8__.default.use(juijs_chart_src_brush_line_js__WEBPACK_IMPORTED_MODULE_9__.default, juijs_chart_src_brush_area_js__WEBPACK_IMPORTED_MODULE_10__.default, juijs_chart_src_brush_stackarea_js__WEBPACK_IMPORTED_MODULE_11__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-area',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_block_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_methods_block_js__WEBPACK_IMPORTED_MODULE_7__.default ],
    props: {
        shape: {
            type: String, // "normal", "curve", "step"
            required: false,
            default: 'normal'
        },
        opacity: {
            type: Number,
            required: false
        },
        borderLine: {
            type: Boolean,
            required: false,
            default: true
        },
        display: { // "max", "min", "all"
            type: String,
            required: false
        }
    },
    methods: {
        getAxisMinAndMax: function() {
            let min = this.axisMin;
            let max = this.axisMax;

            if(min != max) {
                return [ min, max ]
            }

            return function(data) {
                return Object.values(data).reduce((a, b) => a + b, 0)
            }
        }
    },
    beforeMount: function() {
        this.brushes = [{
            type: 'stackarea',
            clip: this.clip,
            colors: this.colors,
            symbol: this.shape,
            opacity: this.opacity,
            line: this.borderLine,
            display: this.display
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/bar.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-graph/src/components/bar.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/mounted.js */ "./node_modules/vue-graph/src/base/mounted.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_block_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props-block.js */ "./node_modules/vue-graph/src/base/props-block.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var _base_methods_block_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/methods-block.js */ "./node_modules/vue-graph/src/base/methods-block.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_bar_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! juijs-chart/src/brush/bar.js */ "./node_modules/juijs-chart/src/brush/bar.js");
/* harmony import */ var juijs_chart_src_brush_column_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! juijs-chart/src/brush/column.js */ "./node_modules/juijs-chart/src/brush/column.js");













juijs_chart__WEBPACK_IMPORTED_MODULE_8__.default.use(juijs_chart_src_brush_bar_js__WEBPACK_IMPORTED_MODULE_9__.default, juijs_chart_src_brush_column_js__WEBPACK_IMPORTED_MODULE_10__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-bar',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_block_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_methods_block_js__WEBPACK_IMPORTED_MODULE_7__.default ],
    props: {
        fixedSize: {
            type: Number,
            required: false,
            default: 0
        },
        minValue: {
            type: Number,
            required: false,
            default: 0
        },
        barMargin: {
            type: Number,
            required: false,
            default: 2
        },
        barPadding: {
            type: Number,
            required: false,
            default: 1
        },
        activeIndex: {
            type: Number,
            required: false
        },
        activeEvent: {
            type: String, // "click", "dblclick", ...
            required: false
        },
        display: { // "max", "min", "all"
            type: String,
            required: false
        }
    },
    watch: {
        activeIndex: function(newVal, oldVal) {
            if(newVal == oldVal) return;

            this.chart.updateBrush(0, { active: newVal });
            this.chart.render();
        }
    },
    beforeMount: function() {
        this.brushes = [{
            type: this.axisReverse ? 'bar' : 'column',
            clip: this.clip,
            colors: this.colors,
            active: this.activeIndex,
            activeEvent: this.activeEvent,
            display: this.display,
            size: this.fixedSize,
            minSize: this.minValue,
            outerPadding: this.barMargin,
            innerPadding: this.barPadding
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/bar3d.js":
/*!********************************************************!*\
  !*** ./node_modules/vue-graph/src/components/bar3d.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/mounted.js */ "./node_modules/vue-graph/src/base/mounted.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_block3d_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props-block3d.js */ "./node_modules/vue-graph/src/base/props-block3d.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var _base_methods_block3d_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/methods-block3d.js */ "./node_modules/vue-graph/src/base/methods-block3d.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_polygon_column3d_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! juijs-chart/src/brush/polygon/column3d.js */ "./node_modules/juijs-chart/src/brush/polygon/column3d.js");
/* harmony import */ var juijs_chart_src_widget_polygon_rotate3d_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! juijs-chart/src/widget/polygon/rotate3d.js */ "./node_modules/juijs-chart/src/widget/polygon/rotate3d.js");













juijs_chart__WEBPACK_IMPORTED_MODULE_8__.default.use(juijs_chart_src_brush_polygon_column3d_js__WEBPACK_IMPORTED_MODULE_9__.default, juijs_chart_src_widget_polygon_rotate3d_js__WEBPACK_IMPORTED_MODULE_10__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-bar3d',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_block3d_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_methods_block3d_js__WEBPACK_IMPORTED_MODULE_7__.default ],
    props: {
        names: {
            type: Array,
            required: true
        },
        barPadding: {
            type: Number,
            required: false,
            default: 20
        }
    },
    beforeMount: function() {
        this.brushes = [{
            type: 'polygon.column3d',
            colors: this.colors,
            padding: this.barPadding
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/bubble.js":
/*!*********************************************************!*\
  !*** ./node_modules/vue-graph/src/components/bubble.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/mounted.js */ "./node_modules/vue-graph/src/base/mounted.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_timerange_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props-timerange.js */ "./node_modules/vue-graph/src/base/props-timerange.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var _base_methods_timerange_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/methods-timerange.js */ "./node_modules/vue-graph/src/base/methods-timerange.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_bubble_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! juijs-chart/src/brush/bubble.js */ "./node_modules/juijs-chart/src/brush/bubble.js");












juijs_chart__WEBPACK_IMPORTED_MODULE_8__.default.use(juijs_chart_src_brush_bubble_js__WEBPACK_IMPORTED_MODULE_9__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-bubble',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_timerange_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_methods_timerange_js__WEBPACK_IMPORTED_MODULE_7__.default ],
    props: {
        minSize: {
            type: Number,
            required: false,
            default: 5
        },
        maxSize: {
            type: Number,
            required: false,
            default: 30
        },
        showText: {
            type: Boolean,
            required: false,
            default: false
        },
        activeEvent: {
            type: String, // "click", "dblclick", ...
            required: false
        }
    },
    beforeMount: function() {
        this.brushes = [{
            type: 'bubble',
            target: [ '1' ],
            clip: this.clip,
            colors: this.colors,
            min: this.minSize,
            max: this.maxSize,
            showText: this.showText,
            activeEvent: (this.showText) ? this.activeEvent : null
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/bubblecloud.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-graph/src/components/bubblecloud.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_watch_animation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/watch-animation.js */ "./node_modules/vue-graph/src/base/watch-animation.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_animation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/mounted-animation.js */ "./node_modules/vue-graph/src/base/mounted-animation.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_animation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/props-animation.js */ "./node_modules/vue-graph/src/base/props-animation.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_canvas_bubblecloud_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! juijs-chart/src/brush/canvas/bubblecloud.js */ "./node_modules/juijs-chart/src/brush/canvas/bubblecloud.js");












juijs_chart__WEBPACK_IMPORTED_MODULE_8__.default.use(juijs_chart_src_brush_canvas_bubblecloud_js__WEBPACK_IMPORTED_MODULE_9__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-bubblecloud',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_watch_animation_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_mounted_animation_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_props_animation_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_7__.default ],
    methods: {
        convertToData: function(values) {
            let data = [];

            for(let i = 0; i < values.length; i++) {
                let row = values[i],
                    value = {};

                for(let j = 0; j < row.length; j++) {
                    value[`${j}`] = row[j];
                }

                data.push(value);
            }

            return data;
        },
        initGraphAxes: function() {
            return {
                keymap: {
                    'title': '0',
                    'capacity': '1'
                },
                data: this.convertToData(this.values)
            }
        }
    },
    beforeMount: function() {
        this.brushes = [{
            type: 'canvas.bubblecloud',
            clip: this.clip,
            colors: this.colors
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/comparisonarea.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vue-graph/src/components/comparisonarea.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./area.js */ "./node_modules/vue-graph/src/components/area.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_area_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! juijs-chart/src/brush/area.js */ "./node_modules/juijs-chart/src/brush/area.js");





juijs_chart__WEBPACK_IMPORTED_MODULE_1__.default.use(juijs_chart_src_brush_area_js__WEBPACK_IMPORTED_MODULE_2__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-comparison-area',
    mixins: [ _area_js__WEBPACK_IMPORTED_MODULE_0__.default ],
    props: {
        axisMin: {
            type: Array,
            required: false,
            default: null
        },
        axisMax: {
            type: Array,
            required: false,
            default: null
        }
    },
    methods: {
        getAxisMinAndMax: function(data, index) {
            let min = this.axisMin;
            let max = this.axisMax;

            if(min != null && max != null) {
                return [ min[index], max[index] ]
            }

            return data[index];
        },
        initGraphAxes: function() {
            const self = this;

            return [{
                x : {
                    type : "fullblock",
                    domain : this.labels,
                    line : this.axisXStyle,
                    hide : this.axisXStyle == "hidden",
                },
                y : {
                    type : "range",
                    domain : function(data) {
                        return self.getAxisMinAndMax(data, 0);
                    },
                    step : this.axisStep,
                    line : this.axisYStyle,
                    hide : this.axisYStyle == "hidden",
                    reverse : true,
                    color : 0
                },
                data : this.convertToData(this.values)
            }, {
                x : {
                    hide : true
                },
                y : {
                    orient : "right",
                    domain : function(data) {
                        return self.getAxisMinAndMax(data, 1);
                    },
                    reverse : false,
                    color : 1
                },
                extend : 0
            }]
        }
    },
    beforeMount: function() {
        const _ = juijs_chart__WEBPACK_IMPORTED_MODULE_1__.default.include('util.base')

        let colors = !this.colors ? [ 0, 1 ] : this.colors;

        let options = {
            type: 'area',
            clip: this.clip,
            symbol: this.shape,
            opacity: this.opacity,
            line: this.borderLine,
            display: this.display
        }

        this.brushes = [
            _.extend({ target: '0', axis: 0, colors: [ colors[0] ] }, options),
            _.extend({ target: '1', axis: 1, colors: [ colors[1] ] }, options)
        ]
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/comparisonbar.js":
/*!****************************************************************!*\
  !*** ./node_modules/vue-graph/src/components/comparisonbar.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bar.js */ "./node_modules/vue-graph/src/components/bar.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_bar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! juijs-chart/src/brush/bar.js */ "./node_modules/juijs-chart/src/brush/bar.js");





juijs_chart__WEBPACK_IMPORTED_MODULE_1__.default.use(juijs_chart_src_brush_bar_js__WEBPACK_IMPORTED_MODULE_2__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-comparison-bar',
    mixins: [ _bar_js__WEBPACK_IMPORTED_MODULE_0__.default ],
    methods: {
        initGraphAxes: function() {
            return [{
                x : {
                    type : "range",
                    domain : function(d) {
                        return Math.max(d[0], d[1]);
                    },
                    step : this.axisStep,
                    line : this.axisXStyle,
                    hide : this.axisXStyle == "hidden",
                    reverse : true
                },
                y : {
                    type : "block",
                    domain : this.labels,
                    line : this.axisYStyle,
                    hide : this.axisYStyle == "hidden",
                },
                data : this.convertToData(this.values),
                area : {
                    x : 0, y : 0, width : "50%", height : "100%"
                }
            }, {
                x : {
                    reverse : false
                },
                y : {
                    orient : "right"
                },
                area : {
                    x : "50%", y : 0, width : "50%", height : "100%"
                },
                extend : 0
            }]
        }
    },
    beforeMount: function() {
        const _ = juijs_chart__WEBPACK_IMPORTED_MODULE_1__.default.include('util.base')

        let colors = !this.colors ? [ 1, 2 ] : this.colors;

        let options = {
            type: 'bar',
            clip: this.clip,
            active: this.activeIndex,
            activeEvent: this.activeEvent,
            display: this.display,
            size: this.fixedSize,
            minSize: this.minValue,
            outerPadding: this.barMargin,
            innerPadding: this.barPadding
        }

        this.brushes = [
            _.extend({ target: '0', axis: 0, colors: [ colors[0] ] }, options),
            _.extend({ target: '1', axis: 1, colors: [ colors[1] ] }, options)
        ]
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/core.js":
/*!*******************************************************!*\
  !*** ./node_modules/vue-graph/src/components/core.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_theme_classic_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! juijs-chart/src/theme/classic.js */ "./node_modules/juijs-chart/src/theme/classic.js");
/* harmony import */ var juijs_chart_src_theme_dark_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! juijs-chart/src/theme/dark.js */ "./node_modules/juijs-chart/src/theme/dark.js");
/* harmony import */ var juijs_chart_src_widget_title_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! juijs-chart/src/widget/title.js */ "./node_modules/juijs-chart/src/widget/title.js");
/* harmony import */ var juijs_chart_src_widget_legend_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! juijs-chart/src/widget/legend.js */ "./node_modules/juijs-chart/src/widget/legend.js");
/* harmony import */ var juijs_chart_src_widget_tooltip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! juijs-chart/src/widget/tooltip.js */ "./node_modules/juijs-chart/src/widget/tooltip.js");
/* harmony import */ var juijs_chart_src_widget_cross_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! juijs-chart/src/widget/cross.js */ "./node_modules/juijs-chart/src/widget/cross.js");








juijs_chart__WEBPACK_IMPORTED_MODULE_0__.default.use(juijs_chart_src_theme_classic_js__WEBPACK_IMPORTED_MODULE_1__.default, juijs_chart_src_theme_dark_js__WEBPACK_IMPORTED_MODULE_2__.default, juijs_chart_src_widget_title_js__WEBPACK_IMPORTED_MODULE_3__.default, juijs_chart_src_widget_legend_js__WEBPACK_IMPORTED_MODULE_4__.default, juijs_chart_src_widget_tooltip_js__WEBPACK_IMPORTED_MODULE_5__.default, juijs_chart_src_widget_cross_js__WEBPACK_IMPORTED_MODULE_6__.default);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    beforeMount: function(e) {
        this.index = this.brushes.length;
    },
    render: function(createElement) {
        return createElement('div', this.$slots.default);
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/equalizer.js":
/*!************************************************************!*\
  !*** ./node_modules/vue-graph/src/components/equalizer.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_watch_animation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/watch-animation.js */ "./node_modules/vue-graph/src/base/watch-animation.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_animation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/mounted-animation.js */ "./node_modules/vue-graph/src/base/mounted-animation.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_animation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/props-animation.js */ "./node_modules/vue-graph/src/base/props-animation.js");
/* harmony import */ var _base_props_block_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/props-block.js */ "./node_modules/vue-graph/src/base/props-block.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var _base_methods_block_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../base/methods-block.js */ "./node_modules/vue-graph/src/base/methods-block.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_canvas_equalizercolumn_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! juijs-chart/src/brush/canvas/equalizercolumn.js */ "./node_modules/juijs-chart/src/brush/canvas/equalizercolumn.js");














juijs_chart__WEBPACK_IMPORTED_MODULE_10__.default.use(juijs_chart_src_brush_canvas_equalizercolumn_js__WEBPACK_IMPORTED_MODULE_11__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-equalizer',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_watch_animation_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_mounted_animation_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_props_animation_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_props_block_js__WEBPACK_IMPORTED_MODULE_7__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_8__.default, _base_methods_block_js__WEBPACK_IMPORTED_MODULE_9__.default ],
    props: {
        fixedSize: {
            type: Number,
            required: false,
            default: 0
        },
        minValue: {
            type: Number,
            required: false,
            default: 0
        },
        barMargin: {
            type: Number,
            required: false,
            default: 2
        },
        barPadding: {
            type: Number,
            required: false,
            default: 1
        },
        maxDivisions: {
            type: Number,
            required: false,
            default: 5
        }
    },
    beforeMount: function() {
        this.brushes = [{
            type: 'canvas.equalizercolumn',
            clip: this.clip,
            colors: this.colors,
            size: this.fixedSize,
            minSize: this.minValue,
            outerPadding: this.barMargin,
            innerPadding: this.barPadding,
            unit: this.maxDivisions
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/line-dateblock.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vue-graph/src/components/line-dateblock.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line.js */ "./node_modules/vue-graph/src/components/line.js");
/* harmony import */ var _base_props_dateblock_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/props-dateblock.js */ "./node_modules/vue-graph/src/base/props-dateblock.js");
/* harmony import */ var _base_methods_dateblock_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/methods-dateblock.js */ "./node_modules/vue-graph/src/base/methods-dateblock.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-line-dateblock',
    mixins: [ _line_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_props_dateblock_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_methods_dateblock_js__WEBPACK_IMPORTED_MODULE_2__.default ]
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/line-timerange.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vue-graph/src/components/line-timerange.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line.js */ "./node_modules/vue-graph/src/components/line.js");
/* harmony import */ var _base_props_timerange__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/props-timerange */ "./node_modules/vue-graph/src/base/props-timerange.js");
/* harmony import */ var _base_methods_timerange__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/methods-timerange */ "./node_modules/vue-graph/src/base/methods-timerange.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-line-timerange',
    mixins: [ _line_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_props_timerange__WEBPACK_IMPORTED_MODULE_1__.default, _base_methods_timerange__WEBPACK_IMPORTED_MODULE_2__.default ],
    beforeMount: function() {
        this.brushes = [{
            type: 'line',
            target: '1',
            clip: this.clip,
            colors: this.colors,
            symbol: this.shape,
            active: this.activeIndex,
            activeEvent: this.activeEvent,
            display: this.display,
            opacity: this.opacity
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/line.js":
/*!*******************************************************!*\
  !*** ./node_modules/vue-graph/src/components/line.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/mounted.js */ "./node_modules/vue-graph/src/base/mounted.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_block_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props-block.js */ "./node_modules/vue-graph/src/base/props-block.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var _base_methods_block_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/methods-block.js */ "./node_modules/vue-graph/src/base/methods-block.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_line_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! juijs-chart/src/brush/line.js */ "./node_modules/juijs-chart/src/brush/line.js");












juijs_chart__WEBPACK_IMPORTED_MODULE_8__.default.use(juijs_chart_src_brush_line_js__WEBPACK_IMPORTED_MODULE_9__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-line',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_block_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_methods_block_js__WEBPACK_IMPORTED_MODULE_7__.default ],
    props: {
        shape: {
            type: String, // "normal", "curve", "step"
            required: false,
            default: 'normal'
        },
        activeIndex: {
            type: Number,
            required: false
        },
        activeEvent: {
            type: String, // "click", "dblclick", ...
            required: false
        },
        display: { // "max", "min", "all"
            type: String,
            required: false
        },
        opacity: {
            type: Number,
            required: false
        }
    },
    beforeMount: function() {
        this.brushes = [{
            type: 'line',
            clip: this.clip,
            colors: this.colors,
            symbol: this.shape,
            active: this.activeIndex,
            activeEvent: this.activeEvent,
            display: this.display,
            opacity: this.opacity
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/line3d.js":
/*!*********************************************************!*\
  !*** ./node_modules/vue-graph/src/components/line3d.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/mounted.js */ "./node_modules/vue-graph/src/base/mounted.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_block3d_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props-block3d.js */ "./node_modules/vue-graph/src/base/props-block3d.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var _base_methods_block3d_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/methods-block3d.js */ "./node_modules/vue-graph/src/base/methods-block3d.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_polygon_line3d_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! juijs-chart/src/brush/polygon/line3d.js */ "./node_modules/juijs-chart/src/brush/polygon/line3d.js");
/* harmony import */ var juijs_chart_src_widget_polygon_rotate3d_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! juijs-chart/src/widget/polygon/rotate3d.js */ "./node_modules/juijs-chart/src/widget/polygon/rotate3d.js");













juijs_chart__WEBPACK_IMPORTED_MODULE_8__.default.use(juijs_chart_src_brush_polygon_line3d_js__WEBPACK_IMPORTED_MODULE_9__.default, juijs_chart_src_widget_polygon_rotate3d_js__WEBPACK_IMPORTED_MODULE_10__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-line3d',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_block3d_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_methods_block3d_js__WEBPACK_IMPORTED_MODULE_7__.default ],
    props: {
        names: {
            type: Array,
            required: true
        },
        linePadding: {
            type: Number,
            required: false,
            default: 20
        }
    },
    beforeMount: function() {
        this.brushes = [{
            type: 'polygon.line3d',
            colors: this.colors,
            padding: this.linePadding
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/pie.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-graph/src/components/pie.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/mounted.js */ "./node_modules/vue-graph/src/base/mounted.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_pie_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! juijs-chart/src/brush/pie.js */ "./node_modules/juijs-chart/src/brush/pie.js");
/* harmony import */ var juijs_chart_src_brush_donut_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart/src/brush/donut.js */ "./node_modules/juijs-chart/src/brush/donut.js");











juijs_chart__WEBPACK_IMPORTED_MODULE_6__.default.use(juijs_chart_src_brush_pie_js__WEBPACK_IMPORTED_MODULE_7__.default, juijs_chart_src_brush_donut_js__WEBPACK_IMPORTED_MODULE_8__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-pie',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_5__.default ],
    props: {
        shape: {
            type: String,
            required: false,
            default: 'pie' // or donut
        },
        names: {
            type: Array,
            required: true
        },
        activeIndex: {
            type: [ Number, Array ],
            required: false
        },
        activeEvent: {
            type: String,
            required: false
        },
        showTextType: {
            type: String,
            required: false // outside, inside
        },
        dataFormat: {
            type: Function,
            required: false
        },
        showTotalValue: {
            type: Boolean,
            required: false,
            default: false,
        },
        strokeWidth: {
            type: Number,
            required: false,
            default: 50
        }
    },
    watch: {
        activeIndex: function(newVal, oldVal) {
            if(newVal == oldVal) return;

            this.chart.updateBrush(0, { active: newVal });
            this.chart.render();
        }
    },
    methods: {
        convertToData: function(values) {
            var row = {};

            for(let i = 0; i < values.length; i++) {
                row['' + i] = values[i];
            }

            return [ row ];
        },
        initGraphAxes: function() {
            return {
                data : this.convertToData(this.values)
            }
        }
    },
    beforeMount: function() {
        const self = this;

        const brush = {
            type: this.shape,
            clip: this.clip,
            colors: this.colors,
            active: this.activeIndex,
            activeEvent: this.activeEvent,
            showText: this.showTextType,
            format: function(key, value) {
                if(typeof(self.dataFormat) == 'function') {
                    return self.dataFormat.apply(this, [ key, value ]);
                }

                return self.names[key] + ': ' + value;
            }
        };

        if(this.shape == 'donut') {
            brush.size = this.strokeWidth;
            brush.showValue = this.showTotalValue;
        }

        this.brushes = [ brush ];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/rangearea-dateblock.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vue-graph/src/components/rangearea-dateblock.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rangearea_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rangearea.js */ "./node_modules/vue-graph/src/components/rangearea.js");
/* harmony import */ var _base_props_dateblock_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/props-dateblock.js */ "./node_modules/vue-graph/src/base/props-dateblock.js");
/* harmony import */ var _base_methods_dateblock_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/methods-dateblock.js */ "./node_modules/vue-graph/src/base/methods-dateblock.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-rangearea-dateblock',
    mixins: [ _rangearea_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_props_dateblock_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_methods_dateblock_js__WEBPACK_IMPORTED_MODULE_2__.default ]
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/rangearea-timerange.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vue-graph/src/components/rangearea-timerange.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/mounted.js */ "./node_modules/vue-graph/src/base/mounted.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_timerange_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props-timerange.js */ "./node_modules/vue-graph/src/base/props-timerange.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var _base_methods_timerange_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/methods-timerange.js */ "./node_modules/vue-graph/src/base/methods-timerange.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_line_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! juijs-chart/src/brush/line.js */ "./node_modules/juijs-chart/src/brush/line.js");
/* harmony import */ var juijs_chart_src_brush_rangearea_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! juijs-chart/src/brush/rangearea.js */ "./node_modules/juijs-chart/src/brush/rangearea.js");













juijs_chart__WEBPACK_IMPORTED_MODULE_8__.default.use(juijs_chart_src_brush_line_js__WEBPACK_IMPORTED_MODULE_9__.default, juijs_chart_src_brush_rangearea_js__WEBPACK_IMPORTED_MODULE_10__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-rangearea-timerange',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_timerange_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_methods_timerange_js__WEBPACK_IMPORTED_MODULE_7__.default ],
    methods: {
        convertToData: function(values) {
            var data = [];

            for(let i = 0; i < values.length; i++) {
                var row = values[i];

                if(typeof(row) == 'object' && row.length == 4) {
                    data.push({
                        '0': row[0],
                        '1': [row[1], row[3]],
                        '2': row[2]
                    });
                }
            }

            return data;
        }
    },
    beforeMount: function() {
        this.brushes = [{
            type: 'rangearea',
            clip: this.clip,
            colors: this.colors,
            target: '1'
        }, {
            type: 'line',
            clip: this.clip,
            colors: this.colors,
            target: '2'
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/rangearea.js":
/*!************************************************************!*\
  !*** ./node_modules/vue-graph/src/components/rangearea.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/mounted.js */ "./node_modules/vue-graph/src/base/mounted.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_block_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props-block.js */ "./node_modules/vue-graph/src/base/props-block.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var _base_methods_block_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/methods-block.js */ "./node_modules/vue-graph/src/base/methods-block.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_line_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! juijs-chart/src/brush/line.js */ "./node_modules/juijs-chart/src/brush/line.js");
/* harmony import */ var juijs_chart_src_brush_rangearea_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! juijs-chart/src/brush/rangearea.js */ "./node_modules/juijs-chart/src/brush/rangearea.js");













juijs_chart__WEBPACK_IMPORTED_MODULE_8__.default.use(juijs_chart_src_brush_line_js__WEBPACK_IMPORTED_MODULE_9__.default, juijs_chart_src_brush_rangearea_js__WEBPACK_IMPORTED_MODULE_10__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-rangearea',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_block_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_methods_block_js__WEBPACK_IMPORTED_MODULE_7__.default ],
    methods: {
        convertToData: function(values) {
            var data = [];

            for(let i = 0; i < values.length; i++) {
                var row = values[i];

                if(typeof(row) == 'object' && row.length == 3) {
                    data.push({
                        '0': [row[0], row[2]],
                        '1': row[1]
                    });
                }
            }

            return data;
        },
        getAxisMinAndMax: function() {
            let min = this.axisMin;
            let max = this.axisMax;

            if(min != max) {
                return [ min, max ]
            }

            return function(data) {
                return Object.values(data['0']).reduce((a, b) => Math.max(a, b))
            }
        }
    },
    beforeMount: function() {
        this.brushes = [{
            type: 'rangearea',
            clip: this.clip,
            colors: this.colors,
            target: '0'
        }, {
            type: 'line',
            clip: this.clip,
            colors: this.colors,
            target: '1'
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/rangebar.js":
/*!***********************************************************!*\
  !*** ./node_modules/vue-graph/src/components/rangebar.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/mounted.js */ "./node_modules/vue-graph/src/base/mounted.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_block_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props-block.js */ "./node_modules/vue-graph/src/base/props-block.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var _base_methods_block_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/methods-block.js */ "./node_modules/vue-graph/src/base/methods-block.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_rangebar_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! juijs-chart/src/brush/rangebar.js */ "./node_modules/juijs-chart/src/brush/rangebar.js");
/* harmony import */ var juijs_chart_src_brush_rangecolumn_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! juijs-chart/src/brush/rangecolumn.js */ "./node_modules/juijs-chart/src/brush/rangecolumn.js");













juijs_chart__WEBPACK_IMPORTED_MODULE_8__.default.use(juijs_chart_src_brush_rangebar_js__WEBPACK_IMPORTED_MODULE_9__.default, juijs_chart_src_brush_rangecolumn_js__WEBPACK_IMPORTED_MODULE_10__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-rangebar',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_block_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_methods_block_js__WEBPACK_IMPORTED_MODULE_7__.default ],
    props: {
        barMargin: {
            type: Number,
            required: false,
            default: 2
        },
        barPadding: {
            type: Number,
            required: false,
            default: 1
        }
    },
    beforeMount: function() {
        this.brushes = [{
            type: this.axisReverse ? 'rangebar' : 'rangecolumn',
            clip: this.clip,
            colors: this.colors,
            outerPadding: this.barMargin,
            innerPadding: this.barPadding
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/scatter.js":
/*!**********************************************************!*\
  !*** ./node_modules/vue-graph/src/components/scatter.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/mounted.js */ "./node_modules/vue-graph/src/base/mounted.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_timerange_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props-timerange.js */ "./node_modules/vue-graph/src/base/props-timerange.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var _base_methods_timerange_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/methods-timerange.js */ "./node_modules/vue-graph/src/base/methods-timerange.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_scatter_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! juijs-chart/src/brush/scatter.js */ "./node_modules/juijs-chart/src/brush/scatter.js");












juijs_chart__WEBPACK_IMPORTED_MODULE_8__.default.use(juijs_chart_src_brush_scatter_js__WEBPACK_IMPORTED_MODULE_9__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-scatter',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_timerange_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_methods_timerange_js__WEBPACK_IMPORTED_MODULE_7__.default ],
    props: {
        shape: {
            type: String, // circle", "triangle", "rectangle", "cross"
            required: false,
            default: 'circle'
        },
        activeEvent: {
            type: String, // "click", "dblclick", ...
            required: false
        },
        display: { // "max", "min", "all"
            type: String,
            required: false
        },
        opacity: {
            type: Number,
            required: false
        },
        size: {
            type: Number,
            required: false,
            size: 7
        },
        hideZero: {
            type: Boolean,
            required: false,
            size: false
        }
    },
    beforeMount: function() {
        this.brushes = [{
            type: 'scatter',
            target: [ '1' ],
            clip: this.clip,
            colors: this.colors,
            symbol: this.shape,
            activeEvent: this.activeEvent,
            display: this.display,
            opacity: this.opacity,
            size: this.size,
            hideZero: this.hideZero
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/stackbar.js":
/*!***********************************************************!*\
  !*** ./node_modules/vue-graph/src/components/stackbar.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/mounted.js */ "./node_modules/vue-graph/src/base/mounted.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_props_block_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/props-block.js */ "./node_modules/vue-graph/src/base/props-block.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var _base_methods_block_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../base/methods-block.js */ "./node_modules/vue-graph/src/base/methods-block.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_bar_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! juijs-chart/src/brush/bar.js */ "./node_modules/juijs-chart/src/brush/bar.js");
/* harmony import */ var juijs_chart_src_brush_stackbar_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! juijs-chart/src/brush/stackbar.js */ "./node_modules/juijs-chart/src/brush/stackbar.js");
/* harmony import */ var juijs_chart_src_brush_fullstackbar_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! juijs-chart/src/brush/fullstackbar.js */ "./node_modules/juijs-chart/src/brush/fullstackbar.js");
/* harmony import */ var juijs_chart_src_brush_column_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! juijs-chart/src/brush/column.js */ "./node_modules/juijs-chart/src/brush/column.js");
/* harmony import */ var juijs_chart_src_brush_stackcolumn_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! juijs-chart/src/brush/stackcolumn.js */ "./node_modules/juijs-chart/src/brush/stackcolumn.js");
/* harmony import */ var juijs_chart_src_brush_fullstackcolumn_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! juijs-chart/src/brush/fullstackcolumn.js */ "./node_modules/juijs-chart/src/brush/fullstackcolumn.js");

















juijs_chart__WEBPACK_IMPORTED_MODULE_8__.default.use(juijs_chart_src_brush_bar_js__WEBPACK_IMPORTED_MODULE_9__.default, juijs_chart_src_brush_stackbar_js__WEBPACK_IMPORTED_MODULE_10__.default, juijs_chart_src_brush_fullstackbar_js__WEBPACK_IMPORTED_MODULE_11__.default, juijs_chart_src_brush_column_js__WEBPACK_IMPORTED_MODULE_12__.default, juijs_chart_src_brush_stackcolumn_js__WEBPACK_IMPORTED_MODULE_13__.default, juijs_chart_src_brush_fullstackcolumn_js__WEBPACK_IMPORTED_MODULE_14__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-stackbar',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_props_block_js__WEBPACK_IMPORTED_MODULE_5__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_6__.default, _base_methods_block_js__WEBPACK_IMPORTED_MODULE_7__.default ],
    props: {
        fixedSize: {
            type: Number,
            required: false,
            default: 0
        },
        barMargin: {
            type: Number,
            required: false,
            default: 2
        },
        barPadding: {
            type: Number,
            required: false,
            default: 1
        },
        activeIndex: {
            type: Number,
            required: false
        },
        activeEvent: {
            type: String, // "click", "dblclick", ...
            required: false
        },
        display: { // "max", "min", "all"
            type: String,
            required: false
        },
        connectedLine: {
            type: Boolean,
            required: false,
            default: false
        },
        fullMode: {
            type: Boolean,
            required: false,
            default: false
        },
        showText: {
            type: Boolean,
            required: false,
            default: false
        }
    },
    watch: {
        activeIndex: function(newVal, oldVal) {
            if(newVal == oldVal) return;

            this.chart.updateBrush(0, { active: newVal });
            this.chart.render();
        }
    },
    methods: {
        getAxisMinAndMax: function() {
            let min = this.axisMin;
            let max = this.axisMax;

            if(min != max) {
                return [ min, max ]
            }

            return function(data) {
                return Object.values(data).reduce((a, b) => a + b, 0)
            }
        }
    },
    beforeMount: function() {
        const brushName = this.axisReverse ? 'stackbar' : 'stackcolumn';

        this.brushes = [{
            type: this.fullMode ? 'full' + brushName : brushName,
            clip: this.clip,
            colors: this.colors,
            active: this.activeIndex,
            activeEvent: this.activeEvent,
            display: this.display,
            size: this.fixedSize,
            outerPadding: this.barMargin,
            innerPadding: this.barPadding,
            edge: this.connectedLine
        }];

        if(this.fullMode) {
            this.brushes[0].showText = this.showText;
        }
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/components/treemap.js":
/*!**********************************************************!*\
  !*** ./node_modules/vue-graph/src/components/treemap.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/components/core.js");
/* harmony import */ var _base_watch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../base/watch.js */ "./node_modules/vue-graph/src/base/watch.js");
/* harmony import */ var _base_created_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../base/created.js */ "./node_modules/vue-graph/src/base/created.js");
/* harmony import */ var _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base/mounted.js */ "./node_modules/vue-graph/src/base/mounted.js");
/* harmony import */ var _base_props_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../base/props.js */ "./node_modules/vue-graph/src/base/props.js");
/* harmony import */ var _base_methods_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../base/methods.js */ "./node_modules/vue-graph/src/base/methods.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");
/* harmony import */ var juijs_chart_src_brush_treemap_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! juijs-chart/src/brush/treemap.js */ "./node_modules/juijs-chart/src/brush/treemap.js");










juijs_chart__WEBPACK_IMPORTED_MODULE_6__.default.use(juijs_chart_src_brush_treemap_js__WEBPACK_IMPORTED_MODULE_7__.default)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'graph-treemap',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default, _base_watch_js__WEBPACK_IMPORTED_MODULE_1__.default, _base_created_js__WEBPACK_IMPORTED_MODULE_2__.default, _base_mounted_js__WEBPACK_IMPORTED_MODULE_3__.default, _base_props_js__WEBPACK_IMPORTED_MODULE_4__.default, _base_methods_js__WEBPACK_IMPORTED_MODULE_5__.default ],
    props: {
        textAlign: {
            type: String,
            required: false,
            default: 'center' // or left, right
        },
        textVerticalAlign: {
            typ: String,
            required: false,
            default: 'top' // or bottom, middle
        },
        showText: {
            type: Boolean,
            required: false,
            default: false
        },
        titleDepth: {
            type: Number,
            required: false,
            default: 1
        },
        nodeColor: {
            type: Function,
            required: false,
            default: null
        }
    },
    methods: {
        convertToData: function(values) {
            let util = juijs_chart__WEBPACK_IMPORTED_MODULE_6__.default.include('util.base');
            let rows = [];

            for(let i = 0; i < values.length; i++) {
                let val = values[i];

                if(util.typeCheck('array', val)) {
                    let row = { index: val[0], text: val[1] };

                    if(val.length == 3 && val[2] > 0) {
                        row['value'] = val[2];
                    }

                    rows.push(row);
                }
            }

            return rows;
        },
        initGraphAxes: function() {
            return {
                data : this.convertToData(this.values)
            }
        }
    },
    beforeMount: function() {
        const ORIENT_MAP = {
            top: 'top',
            middle: 'center',
            bottom: 'bottom'
        };

        const ALIGN_MAP = {
            left: 'start',
            center: 'middle',
            right: 'end'
        }

        this.brushes = [{
            type: 'treemap',
            clip: this.clip,
            colors: this.colors,
            target: [ 'value' ],
            textOrient: ORIENT_MAP[this.textVerticalAlign],
            textAlign: ALIGN_MAP[this.textAlign],
            showText: this.showText,
            titleDepth: this.titleDepth,
            nodeColor: this.nodeColor
        }];
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/main.js":
/*!********************************************!*\
  !*** ./node_modules/vue-graph/src/main.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_bar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/bar.js */ "./node_modules/vue-graph/src/components/bar.js");
/* harmony import */ var _components_bar3d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/bar3d.js */ "./node_modules/vue-graph/src/components/bar3d.js");
/* harmony import */ var _components_stackbar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/stackbar.js */ "./node_modules/vue-graph/src/components/stackbar.js");
/* harmony import */ var _components_rangebar_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/rangebar.js */ "./node_modules/vue-graph/src/components/rangebar.js");
/* harmony import */ var _components_line_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/line.js */ "./node_modules/vue-graph/src/components/line.js");
/* harmony import */ var _components_line3d_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/line3d.js */ "./node_modules/vue-graph/src/components/line3d.js");
/* harmony import */ var _components_line_dateblock_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/line-dateblock.js */ "./node_modules/vue-graph/src/components/line-dateblock.js");
/* harmony import */ var _components_line_timerange_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/line-timerange.js */ "./node_modules/vue-graph/src/components/line-timerange.js");
/* harmony import */ var _components_scatter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/scatter.js */ "./node_modules/vue-graph/src/components/scatter.js");
/* harmony import */ var _components_bubble_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/bubble.js */ "./node_modules/vue-graph/src/components/bubble.js");
/* harmony import */ var _components_area_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/area.js */ "./node_modules/vue-graph/src/components/area.js");
/* harmony import */ var _components_area_dateblock_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/area-dateblock.js */ "./node_modules/vue-graph/src/components/area-dateblock.js");
/* harmony import */ var _components_area_timerange_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/area-timerange.js */ "./node_modules/vue-graph/src/components/area-timerange.js");
/* harmony import */ var _components_rangearea_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/rangearea.js */ "./node_modules/vue-graph/src/components/rangearea.js");
/* harmony import */ var _components_rangearea_dateblock_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/rangearea-dateblock.js */ "./node_modules/vue-graph/src/components/rangearea-dateblock.js");
/* harmony import */ var _components_rangearea_timerange_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/rangearea-timerange.js */ "./node_modules/vue-graph/src/components/rangearea-timerange.js");
/* harmony import */ var _components_pie_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/pie.js */ "./node_modules/vue-graph/src/components/pie.js");
/* harmony import */ var _components_comparisonbar_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./components/comparisonbar.js */ "./node_modules/vue-graph/src/components/comparisonbar.js");
/* harmony import */ var _components_comparisonarea_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/comparisonarea.js */ "./node_modules/vue-graph/src/components/comparisonarea.js");
/* harmony import */ var _components_treemap_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./components/treemap.js */ "./node_modules/vue-graph/src/components/treemap.js");
/* harmony import */ var _components_equalizer_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./components/equalizer.js */ "./node_modules/vue-graph/src/components/equalizer.js");
/* harmony import */ var _components_activebubble_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/activebubble.js */ "./node_modules/vue-graph/src/components/activebubble.js");
/* harmony import */ var _components_bubblecloud_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/bubblecloud.js */ "./node_modules/vue-graph/src/components/bubblecloud.js");
/* harmony import */ var _widgets_note_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./widgets/note.js */ "./node_modules/vue-graph/src/widgets/note.js");
/* harmony import */ var _widgets_tooltip_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./widgets/tooltip.js */ "./node_modules/vue-graph/src/widgets/tooltip.js");
/* harmony import */ var _widgets_guideline_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./widgets/guideline.js */ "./node_modules/vue-graph/src/widgets/guideline.js");
/* harmony import */ var _widgets_legends_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./widgets/legends.js */ "./node_modules/vue-graph/src/widgets/legends.js");
/* harmony import */ var _widgets_rotate3d_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./widgets/rotate3d.js */ "./node_modules/vue-graph/src/widgets/rotate3d.js");





























/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    install: function(Vue, options) {
        // 1. 브러쉬 추가 영역
        Vue.component(_components_bar_js__WEBPACK_IMPORTED_MODULE_0__.default.name, _components_bar_js__WEBPACK_IMPORTED_MODULE_0__.default);
        Vue.component(_components_bar3d_js__WEBPACK_IMPORTED_MODULE_1__.default.name, _components_bar3d_js__WEBPACK_IMPORTED_MODULE_1__.default);
        Vue.component(_components_stackbar_js__WEBPACK_IMPORTED_MODULE_2__.default.name, _components_stackbar_js__WEBPACK_IMPORTED_MODULE_2__.default);
        Vue.component(_components_rangebar_js__WEBPACK_IMPORTED_MODULE_3__.default.name, _components_rangebar_js__WEBPACK_IMPORTED_MODULE_3__.default);
        Vue.component(_components_line_js__WEBPACK_IMPORTED_MODULE_4__.default.name, _components_line_js__WEBPACK_IMPORTED_MODULE_4__.default);
        Vue.component(_components_line3d_js__WEBPACK_IMPORTED_MODULE_5__.default.name, _components_line3d_js__WEBPACK_IMPORTED_MODULE_5__.default);
        Vue.component(_components_line_dateblock_js__WEBPACK_IMPORTED_MODULE_6__.default.name, _components_line_dateblock_js__WEBPACK_IMPORTED_MODULE_6__.default);
        Vue.component(_components_line_timerange_js__WEBPACK_IMPORTED_MODULE_7__.default.name, _components_line_timerange_js__WEBPACK_IMPORTED_MODULE_7__.default);
        Vue.component(_components_scatter_js__WEBPACK_IMPORTED_MODULE_8__.default.name, _components_scatter_js__WEBPACK_IMPORTED_MODULE_8__.default);
        Vue.component(_components_bubble_js__WEBPACK_IMPORTED_MODULE_9__.default.name, _components_bubble_js__WEBPACK_IMPORTED_MODULE_9__.default);
        Vue.component(_components_area_js__WEBPACK_IMPORTED_MODULE_10__.default.name, _components_area_js__WEBPACK_IMPORTED_MODULE_10__.default);
        Vue.component(_components_area_dateblock_js__WEBPACK_IMPORTED_MODULE_11__.default.name, _components_area_dateblock_js__WEBPACK_IMPORTED_MODULE_11__.default);
        Vue.component(_components_area_timerange_js__WEBPACK_IMPORTED_MODULE_12__.default.name, _components_area_timerange_js__WEBPACK_IMPORTED_MODULE_12__.default);
        Vue.component(_components_rangearea_js__WEBPACK_IMPORTED_MODULE_13__.default.name, _components_rangearea_js__WEBPACK_IMPORTED_MODULE_13__.default);
        Vue.component(_components_rangearea_dateblock_js__WEBPACK_IMPORTED_MODULE_14__.default.name, _components_rangearea_dateblock_js__WEBPACK_IMPORTED_MODULE_14__.default);
        Vue.component(_components_rangearea_timerange_js__WEBPACK_IMPORTED_MODULE_15__.default.name, _components_rangearea_timerange_js__WEBPACK_IMPORTED_MODULE_15__.default);
        Vue.component(_components_pie_js__WEBPACK_IMPORTED_MODULE_16__.default.name, _components_pie_js__WEBPACK_IMPORTED_MODULE_16__.default);
        Vue.component(_components_comparisonbar_js__WEBPACK_IMPORTED_MODULE_17__.default.name, _components_comparisonbar_js__WEBPACK_IMPORTED_MODULE_17__.default);
        Vue.component(_components_comparisonarea_js__WEBPACK_IMPORTED_MODULE_18__.default.name, _components_comparisonarea_js__WEBPACK_IMPORTED_MODULE_18__.default);
        Vue.component(_components_treemap_js__WEBPACK_IMPORTED_MODULE_19__.default.name, _components_treemap_js__WEBPACK_IMPORTED_MODULE_19__.default);
        Vue.component(_components_equalizer_js__WEBPACK_IMPORTED_MODULE_20__.default.name, _components_equalizer_js__WEBPACK_IMPORTED_MODULE_20__.default);
        Vue.component(_components_activebubble_js__WEBPACK_IMPORTED_MODULE_21__.default.name, _components_activebubble_js__WEBPACK_IMPORTED_MODULE_21__.default);
        Vue.component(_components_bubblecloud_js__WEBPACK_IMPORTED_MODULE_22__.default.name, _components_bubblecloud_js__WEBPACK_IMPORTED_MODULE_22__.default);

        // 2. 위젯 추가 영역
        Vue.component(_widgets_note_js__WEBPACK_IMPORTED_MODULE_23__.default.name, _widgets_note_js__WEBPACK_IMPORTED_MODULE_23__.default);
        Vue.component(_widgets_tooltip_js__WEBPACK_IMPORTED_MODULE_24__.default.name, _widgets_tooltip_js__WEBPACK_IMPORTED_MODULE_24__.default);
        Vue.component(_widgets_guideline_js__WEBPACK_IMPORTED_MODULE_25__.default.name, _widgets_guideline_js__WEBPACK_IMPORTED_MODULE_25__.default);
        Vue.component(_widgets_legends_js__WEBPACK_IMPORTED_MODULE_26__.default.name, _widgets_legends_js__WEBPACK_IMPORTED_MODULE_26__.default);
        Vue.component(_widgets_rotate3d_js__WEBPACK_IMPORTED_MODULE_27__.default.name, _widgets_rotate3d_js__WEBPACK_IMPORTED_MODULE_27__.default);
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/widgets/core.js":
/*!****************************************************!*\
  !*** ./node_modules/vue-graph/src/widgets/core.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    template: '<span style="display: none;"></span>',
    beforeMount: function(e) {
        if(!this.$parent || !this.$parent.$vnode || this.$parent.$vnode.tag.indexOf("graph-") == -1) {
            throw new Error('[Vue Graph error]: Can only be used as child nodes.');
        }

        this.index = this.$parent.widgets.length;
        this.brushes = [];

        for(let i = 0; i < this.$parent.brushes.length; i++) {
            this.brushes.push(i);
        }
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/widgets/guideline.js":
/*!*********************************************************!*\
  !*** ./node_modules/vue-graph/src/widgets/guideline.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/widgets/core.js");
/* harmony import */ var juijs_chart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! juijs-chart */ "./node_modules/juijs-chart/src/main.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'guideline',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default ],
    props: {
        tooltipX: {
            type: Boolean,
            required: false,
            default: false
        },
        tooltipY: {
            type: Boolean,
            required: false,
            default: true
        }
    },
    beforeMount: function(e) {
        const time = juijs_chart__WEBPACK_IMPORTED_MODULE_1__.default.include('util.time');
        const format = this.$parent.axisFormat;

        let formatFunc = function(value) {
            if(typeof(value) == 'object' && typeof(format) == 'string') {
                return time.format(value, format);
            } else if(typeof(value) == 'number') {
                return Math.round(value);
            }

            return value;
        }

        let opts = { type: 'cross' };
        if(this.tooltipX) opts.xFormat = formatFunc;
        if(this.tooltipY) opts.yFormat = formatFunc;

        this.$parent.widgets.push(opts);
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/widgets/legends.js":
/*!*******************************************************!*\
  !*** ./node_modules/vue-graph/src/widgets/legends.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/widgets/core.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'legends',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default ],
    props: {
        names: {
            type: Array,
            required: true
        },
        align: {
            type: String,
            required: false,
            default: 'center' // or start, end
        },
        position: {
            typ: String,
            required: false,
            default: 'bottom' // or top, left, right
        },
        dx: {
            type: Number,
            required: false,
            default: 0
        },
        dy: {
            type: Number,
            required: false,
            default: 0
        },
        filter: {
            type: Boolean,
            required: false,
            default: false
        },
        colors: {
            type: Array,
            required: false
        }
    },
    watch: {
        names: function(newVal, oldVal) {
            this.names = newVal;
            this.$parent.chart.render(true);
        }
    },
    beforeMount: function(e) {
        const self = this;

        const ALIGN_MAP = {
            left: 'start',
            center: 'center',
            right: 'end'
        }

        this.$parent.widgets.push({
            type: 'legend',
            brush: this.brushes,
            orient: this.position,
            align: ALIGN_MAP[this.align],
            dx: this.dx,
            dy: this.dy,
            filter: this.filter,
            colors: this.color,
            format: function(key) {
                return this.format(self.names[key]);
            }
        });
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/widgets/note.js":
/*!****************************************************!*\
  !*** ./node_modules/vue-graph/src/widgets/note.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/widgets/core.js");


const ORIENT_MAP = {
    top: 'top',
    middle: 'center',
    bottom: 'bottom'
};

const ALIGN_MAP = {
    left: 'start',
    center: 'middle',
    right: 'end'
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'note',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default ],
    props: {
        text: {
            type: String,
            required: true,
            default: ''
        },
        align: {
            type: String,
            required: false,
            default: 'center' // or left, right
        },
        verticalAlign: {
            typ: String,
            required: false,
            default: 'top' // or bottom, middle
        },
        dx: {
            type: Number,
            required: false,
            default: 0
        },
        dy: {
            type: Number,
            required: false,
            default: 0
        },
        size: {
            type: Number,
            required: false
        },
        color: {
            type: String,
            required: false
        }
    },
    watch: {
        text: function(newVal, oldVal) {
            this.$parent.chart.updateWidget(this.index, {
                text: newVal
            });

            this.$parent.chart.render(true)
        },
        align: function(newVal, oldVal) {
            if(newVal == oldVal || (newVal != "left" && newVal != "center" && newVal != "right"))
                return;

            this.$parent.chart.updateWidget(this.index, {
                align: ALIGN_MAP[newVal]
            });

            this.$parent.chart.render(true)
        },
        verticalAlign: function(newVal, oldVal) {
            if(newVal == oldVal || (newVal != "top" && newVal != "middle" && newVal != "bottom"))
                return;

            this.$parent.chart.updateWidget(this.index, {
                orient: ORIENT_MAP[newVal]
            });

            this.$parent.chart.render(true)
        }
    },
    beforeMount: function(e) {
        this.$parent.widgets.push({
            type: 'title',
            text: this.text,
            orient: ORIENT_MAP[this.verticalAlign],
            align: ALIGN_MAP[this.align],
            dx: this.dx,
            dy: this.dy,
            size: this.size,
            color: this.color
        });
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/widgets/rotate3d.js":
/*!********************************************************!*\
  !*** ./node_modules/vue-graph/src/widgets/rotate3d.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/widgets/core.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'rotate3d',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default ],
    beforeMount: function(e) {
        this.$parent.widgets.push({
            type: 'polygon.rotate3d'
        });
    }
});

/***/ }),

/***/ "./node_modules/vue-graph/src/widgets/tooltip.js":
/*!*******************************************************!*\
  !*** ./node_modules/vue-graph/src/widgets/tooltip.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ "./node_modules/vue-graph/src/widgets/core.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    name: 'tooltip',
    mixins: [ _core_js__WEBPACK_IMPORTED_MODULE_0__.default ],
    props: {
        names: {
            type: Array,
            required: false
        },
        position: {
            type: String,
            required: false,
            default: 'top' // or top, bottom, left, right
        },
        showAnchor: {
            type: Boolean,
            required: false,
            default: true
        }
    },
    watch: {
        names: function(newVal, oldVal) {
            this.names = newVal;
            this.$parent.chart.render(true);
        }
    },
    beforeMount: function(e) {
        const self = this;

        this.$parent.widgets.push({
            type: 'tooltip',
            brush: this.brushes,
            orient: this.position,
            anchor: this.showAnchor,
            format: function(data, key) {
                // TODO: 좋은 방법은 아닌 것 같다. ㅠㅠ
                if(self.$parent.$vnode.tag.indexOf('graph-treemap') != -1) {
                    return {
                        key: data.text,
                        value: this.format(data[key])
                    }
                } else {
                    if(data != null) {
                        return {
                            key: self.names[key],
                            value: this.format(data[key])
                        }
                    } else {
                        return self.names[key];
                    }
                }
            }
        });
    }
});

/***/ }),

/***/ "./resources/js/Components/Table.vue":
/*!*******************************************!*\
  !*** ./resources/js/Components/Table.vue ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Table_vue_vue_type_template_id_67955193_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Table.vue?vue&type=template&id=67955193&scoped=true& */ "./resources/js/Components/Table.vue?vue&type=template&id=67955193&scoped=true&");
/* harmony import */ var _Table_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Table.vue?vue&type=script&lang=js& */ "./resources/js/Components/Table.vue?vue&type=script&lang=js&");
/* harmony import */ var _Table_vue_vue_type_style_index_0_id_67955193_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Table.vue?vue&type=style&index=0&id=67955193&scoped=true&lang=css& */ "./resources/js/Components/Table.vue?vue&type=style&index=0&id=67955193&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__.default)(
  _Table_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__.default,
  _Table_vue_vue_type_template_id_67955193_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _Table_vue_vue_type_template_id_67955193_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "67955193",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/js/Components/Table.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/js/Components/Toggle.vue":
/*!********************************************!*\
  !*** ./resources/js/Components/Toggle.vue ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Toggle_vue_vue_type_template_id_96dc2142___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Toggle.vue?vue&type=template&id=96dc2142& */ "./resources/js/Components/Toggle.vue?vue&type=template&id=96dc2142&");
/* harmony import */ var _Toggle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Toggle.vue?vue&type=script&lang=js& */ "./resources/js/Components/Toggle.vue?vue&type=script&lang=js&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__.default)(
  _Toggle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__.default,
  _Toggle_vue_vue_type_template_id_96dc2142___WEBPACK_IMPORTED_MODULE_0__.render,
  _Toggle_vue_vue_type_template_id_96dc2142___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/js/Components/Toggle.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/js/Layouts/Navigation.vue":
/*!*********************************************!*\
  !*** ./resources/js/Layouts/Navigation.vue ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Navigation_vue_vue_type_template_id_5b807f98_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Navigation.vue?vue&type=template&id=5b807f98&scoped=true& */ "./resources/js/Layouts/Navigation.vue?vue&type=template&id=5b807f98&scoped=true&");
/* harmony import */ var _Navigation_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Navigation.vue?vue&type=script&lang=js& */ "./resources/js/Layouts/Navigation.vue?vue&type=script&lang=js&");
/* harmony import */ var _Navigation_vue_vue_type_style_index_0_id_5b807f98_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Navigation.vue?vue&type=style&index=0&id=5b807f98&scoped=true&lang=css& */ "./resources/js/Layouts/Navigation.vue?vue&type=style&index=0&id=5b807f98&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__.default)(
  _Navigation_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__.default,
  _Navigation_vue_vue_type_template_id_5b807f98_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _Navigation_vue_vue_type_template_id_5b807f98_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "5b807f98",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/js/Layouts/Navigation.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/js/Pages/Bill.vue":
/*!*************************************!*\
  !*** ./resources/js/Pages/Bill.vue ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Bill_vue_vue_type_template_id_873580a0_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bill.vue?vue&type=template&id=873580a0&scoped=true& */ "./resources/js/Pages/Bill.vue?vue&type=template&id=873580a0&scoped=true&");
/* harmony import */ var _Bill_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bill.vue?vue&type=script&lang=js& */ "./resources/js/Pages/Bill.vue?vue&type=script&lang=js&");
/* harmony import */ var _Bill_vue_vue_type_style_index_0_id_873580a0_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bill.vue?vue&type=style&index=0&id=873580a0&scoped=true&lang=css& */ "./resources/js/Pages/Bill.vue?vue&type=style&index=0&id=873580a0&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__.default)(
  _Bill_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__.default,
  _Bill_vue_vue_type_template_id_873580a0_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _Bill_vue_vue_type_template_id_873580a0_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "873580a0",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/js/Pages/Bill.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/js/Pages/Client.vue":
/*!***************************************!*\
  !*** ./resources/js/Pages/Client.vue ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Client_vue_vue_type_template_id_a794a598___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Client.vue?vue&type=template&id=a794a598& */ "./resources/js/Pages/Client.vue?vue&type=template&id=a794a598&");
/* harmony import */ var _Client_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Client.vue?vue&type=script&lang=js& */ "./resources/js/Pages/Client.vue?vue&type=script&lang=js&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");





/* normalize component */
;
var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__.default)(
  _Client_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__.default,
  _Client_vue_vue_type_template_id_a794a598___WEBPACK_IMPORTED_MODULE_0__.render,
  _Client_vue_vue_type_template_id_a794a598___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/js/Pages/Client.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/js/Pages/Clients.vue":
/*!****************************************!*\
  !*** ./resources/js/Pages/Clients.vue ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Clients_vue_vue_type_template_id_43a8cb22_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Clients.vue?vue&type=template&id=43a8cb22&scoped=true& */ "./resources/js/Pages/Clients.vue?vue&type=template&id=43a8cb22&scoped=true&");
/* harmony import */ var _Clients_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Clients.vue?vue&type=script&lang=js& */ "./resources/js/Pages/Clients.vue?vue&type=script&lang=js&");
/* harmony import */ var _Clients_vue_vue_type_style_index_0_id_43a8cb22_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Clients.vue?vue&type=style&index=0&id=43a8cb22&scoped=true&lang=css& */ "./resources/js/Pages/Clients.vue?vue&type=style&index=0&id=43a8cb22&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__.default)(
  _Clients_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__.default,
  _Clients_vue_vue_type_template_id_43a8cb22_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _Clients_vue_vue_type_template_id_43a8cb22_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "43a8cb22",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/js/Pages/Clients.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/js/Pages/Login.vue":
/*!**************************************!*\
  !*** ./resources/js/Pages/Login.vue ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Login_vue_vue_type_template_id_0004d9e0_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Login.vue?vue&type=template&id=0004d9e0&scoped=true& */ "./resources/js/Pages/Login.vue?vue&type=template&id=0004d9e0&scoped=true&");
/* harmony import */ var _Login_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Login.vue?vue&type=script&lang=js& */ "./resources/js/Pages/Login.vue?vue&type=script&lang=js&");
/* harmony import */ var _Login_vue_vue_type_style_index_0_id_0004d9e0_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Login.vue?vue&type=style&index=0&id=0004d9e0&scoped=true&lang=css& */ "./resources/js/Pages/Login.vue?vue&type=style&index=0&id=0004d9e0&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__.default)(
  _Login_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__.default,
  _Login_vue_vue_type_template_id_0004d9e0_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _Login_vue_vue_type_template_id_0004d9e0_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "0004d9e0",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/js/Pages/Login.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/js/Pages/Users.vue":
/*!**************************************!*\
  !*** ./resources/js/Pages/Users.vue ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Users_vue_vue_type_template_id_7bbfca2f_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Users.vue?vue&type=template&id=7bbfca2f&scoped=true& */ "./resources/js/Pages/Users.vue?vue&type=template&id=7bbfca2f&scoped=true&");
/* harmony import */ var _Users_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Users.vue?vue&type=script&lang=js& */ "./resources/js/Pages/Users.vue?vue&type=script&lang=js&");
/* harmony import */ var _Users_vue_vue_type_style_index_0_id_7bbfca2f_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Users.vue?vue&type=style&index=0&id=7bbfca2f&scoped=true&lang=css& */ "./resources/js/Pages/Users.vue?vue&type=style&index=0&id=7bbfca2f&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js");



;


/* normalize component */

var component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__.default)(
  _Users_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__.default,
  _Users_vue_vue_type_template_id_7bbfca2f_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,
  _Users_vue_vue_type_template_id_7bbfca2f_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,
  false,
  null,
  "7bbfca2f",
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "resources/js/Pages/Users.vue"
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);

/***/ }),

/***/ "./resources/js/Components/Table.vue?vue&type=script&lang=js&":
/*!********************************************************************!*\
  !*** ./resources/js/Components/Table.vue?vue&type=script&lang=js& ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Table_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Table.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Table.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Table_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__.default); 

/***/ }),

/***/ "./resources/js/Components/Toggle.vue?vue&type=script&lang=js&":
/*!*********************************************************************!*\
  !*** ./resources/js/Components/Toggle.vue?vue&type=script&lang=js& ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Toggle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Toggle.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Toggle.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Toggle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__.default); 

/***/ }),

/***/ "./resources/js/Layouts/Navigation.vue?vue&type=script&lang=js&":
/*!**********************************************************************!*\
  !*** ./resources/js/Layouts/Navigation.vue?vue&type=script&lang=js& ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Navigation_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Navigation.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Layouts/Navigation.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Navigation_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__.default); 

/***/ }),

/***/ "./resources/js/Pages/Bill.vue?vue&type=script&lang=js&":
/*!**************************************************************!*\
  !*** ./resources/js/Pages/Bill.vue?vue&type=script&lang=js& ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Bill_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Bill.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Bill.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Bill_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__.default); 

/***/ }),

/***/ "./resources/js/Pages/Client.vue?vue&type=script&lang=js&":
/*!****************************************************************!*\
  !*** ./resources/js/Pages/Client.vue?vue&type=script&lang=js& ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Client_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Client.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Client.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Client_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__.default); 

/***/ }),

/***/ "./resources/js/Pages/Clients.vue?vue&type=script&lang=js&":
/*!*****************************************************************!*\
  !*** ./resources/js/Pages/Clients.vue?vue&type=script&lang=js& ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Clients_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Clients.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Clients.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Clients_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__.default); 

/***/ }),

/***/ "./resources/js/Pages/Login.vue?vue&type=script&lang=js&":
/*!***************************************************************!*\
  !*** ./resources/js/Pages/Login.vue?vue&type=script&lang=js& ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Login_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Login.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Login.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Login_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__.default); 

/***/ }),

/***/ "./resources/js/Pages/Users.vue?vue&type=script&lang=js&":
/*!***************************************************************!*\
  !*** ./resources/js/Pages/Users.vue?vue&type=script&lang=js& ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Users_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Users.vue?vue&type=script&lang=js& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Users.vue?vue&type=script&lang=js&");
 /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Users_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__.default); 

/***/ }),

/***/ "./resources/js/Components/Table.vue?vue&type=template&id=67955193&scoped=true&":
/*!**************************************************************************************!*\
  !*** ./resources/js/Components/Table.vue?vue&type=template&id=67955193&scoped=true& ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Table_vue_vue_type_template_id_67955193_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Table_vue_vue_type_template_id_67955193_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Table_vue_vue_type_template_id_67955193_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Table.vue?vue&type=template&id=67955193&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Table.vue?vue&type=template&id=67955193&scoped=true&");


/***/ }),

/***/ "./resources/js/Components/Toggle.vue?vue&type=template&id=96dc2142&":
/*!***************************************************************************!*\
  !*** ./resources/js/Components/Toggle.vue?vue&type=template&id=96dc2142& ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Toggle_vue_vue_type_template_id_96dc2142___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Toggle_vue_vue_type_template_id_96dc2142___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Toggle_vue_vue_type_template_id_96dc2142___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Toggle.vue?vue&type=template&id=96dc2142& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Toggle.vue?vue&type=template&id=96dc2142&");


/***/ }),

/***/ "./resources/js/Layouts/Navigation.vue?vue&type=template&id=5b807f98&scoped=true&":
/*!****************************************************************************************!*\
  !*** ./resources/js/Layouts/Navigation.vue?vue&type=template&id=5b807f98&scoped=true& ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Navigation_vue_vue_type_template_id_5b807f98_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Navigation_vue_vue_type_template_id_5b807f98_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Navigation_vue_vue_type_template_id_5b807f98_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Navigation.vue?vue&type=template&id=5b807f98&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Layouts/Navigation.vue?vue&type=template&id=5b807f98&scoped=true&");


/***/ }),

/***/ "./resources/js/Pages/Bill.vue?vue&type=template&id=873580a0&scoped=true&":
/*!********************************************************************************!*\
  !*** ./resources/js/Pages/Bill.vue?vue&type=template&id=873580a0&scoped=true& ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Bill_vue_vue_type_template_id_873580a0_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Bill_vue_vue_type_template_id_873580a0_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Bill_vue_vue_type_template_id_873580a0_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Bill.vue?vue&type=template&id=873580a0&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Bill.vue?vue&type=template&id=873580a0&scoped=true&");


/***/ }),

/***/ "./resources/js/Pages/Client.vue?vue&type=template&id=a794a598&":
/*!**********************************************************************!*\
  !*** ./resources/js/Pages/Client.vue?vue&type=template&id=a794a598& ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Client_vue_vue_type_template_id_a794a598___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Client_vue_vue_type_template_id_a794a598___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Client_vue_vue_type_template_id_a794a598___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Client.vue?vue&type=template&id=a794a598& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Client.vue?vue&type=template&id=a794a598&");


/***/ }),

/***/ "./resources/js/Pages/Clients.vue?vue&type=template&id=43a8cb22&scoped=true&":
/*!***********************************************************************************!*\
  !*** ./resources/js/Pages/Clients.vue?vue&type=template&id=43a8cb22&scoped=true& ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Clients_vue_vue_type_template_id_43a8cb22_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Clients_vue_vue_type_template_id_43a8cb22_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Clients_vue_vue_type_template_id_43a8cb22_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Clients.vue?vue&type=template&id=43a8cb22&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Clients.vue?vue&type=template&id=43a8cb22&scoped=true&");


/***/ }),

/***/ "./resources/js/Pages/Login.vue?vue&type=template&id=0004d9e0&scoped=true&":
/*!*********************************************************************************!*\
  !*** ./resources/js/Pages/Login.vue?vue&type=template&id=0004d9e0&scoped=true& ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Login_vue_vue_type_template_id_0004d9e0_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Login_vue_vue_type_template_id_0004d9e0_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Login_vue_vue_type_template_id_0004d9e0_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Login.vue?vue&type=template&id=0004d9e0&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Login.vue?vue&type=template&id=0004d9e0&scoped=true&");


/***/ }),

/***/ "./resources/js/Pages/Users.vue?vue&type=template&id=7bbfca2f&scoped=true&":
/*!*********************************************************************************!*\
  !*** ./resources/js/Pages/Users.vue?vue&type=template&id=7bbfca2f&scoped=true& ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Users_vue_vue_type_template_id_7bbfca2f_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Users_vue_vue_type_template_id_7bbfca2f_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Users_vue_vue_type_template_id_7bbfca2f_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Users.vue?vue&type=template&id=7bbfca2f&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Users.vue?vue&type=template&id=7bbfca2f&scoped=true&");


/***/ }),

/***/ "./resources/js/Components/Table.vue?vue&type=style&index=0&id=67955193&scoped=true&lang=css&":
/*!****************************************************************************************************!*\
  !*** ./resources/js/Components/Table.vue?vue&type=style&index=0&id=67955193&scoped=true&lang=css& ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Table_vue_vue_type_style_index_0_id_67955193_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-style-loader/index.js!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Table.vue?vue&type=style&index=0&id=67955193&scoped=true&lang=css& */ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Table.vue?vue&type=style&index=0&id=67955193&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Table_vue_vue_type_style_index_0_id_67955193_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Table_vue_vue_type_style_index_0_id_67955193_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Table_vue_vue_type_style_index_0_id_67955193_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Table_vue_vue_type_style_index_0_id_67955193_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),

/***/ "./resources/js/Layouts/Navigation.vue?vue&type=style&index=0&id=5b807f98&scoped=true&lang=css&":
/*!******************************************************************************************************!*\
  !*** ./resources/js/Layouts/Navigation.vue?vue&type=style&index=0&id=5b807f98&scoped=true&lang=css& ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Navigation_vue_vue_type_style_index_0_id_5b807f98_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-style-loader/index.js!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Navigation.vue?vue&type=style&index=0&id=5b807f98&scoped=true&lang=css& */ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Layouts/Navigation.vue?vue&type=style&index=0&id=5b807f98&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Navigation_vue_vue_type_style_index_0_id_5b807f98_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Navigation_vue_vue_type_style_index_0_id_5b807f98_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Navigation_vue_vue_type_style_index_0_id_5b807f98_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Navigation_vue_vue_type_style_index_0_id_5b807f98_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),

/***/ "./resources/js/Pages/Bill.vue?vue&type=style&index=0&id=873580a0&scoped=true&lang=css&":
/*!**********************************************************************************************!*\
  !*** ./resources/js/Pages/Bill.vue?vue&type=style&index=0&id=873580a0&scoped=true&lang=css& ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Bill_vue_vue_type_style_index_0_id_873580a0_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-style-loader/index.js!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Bill.vue?vue&type=style&index=0&id=873580a0&scoped=true&lang=css& */ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Bill.vue?vue&type=style&index=0&id=873580a0&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Bill_vue_vue_type_style_index_0_id_873580a0_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Bill_vue_vue_type_style_index_0_id_873580a0_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Bill_vue_vue_type_style_index_0_id_873580a0_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Bill_vue_vue_type_style_index_0_id_873580a0_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),

/***/ "./resources/js/Pages/Clients.vue?vue&type=style&index=0&id=43a8cb22&scoped=true&lang=css&":
/*!*************************************************************************************************!*\
  !*** ./resources/js/Pages/Clients.vue?vue&type=style&index=0&id=43a8cb22&scoped=true&lang=css& ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Clients_vue_vue_type_style_index_0_id_43a8cb22_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-style-loader/index.js!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Clients.vue?vue&type=style&index=0&id=43a8cb22&scoped=true&lang=css& */ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Clients.vue?vue&type=style&index=0&id=43a8cb22&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Clients_vue_vue_type_style_index_0_id_43a8cb22_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Clients_vue_vue_type_style_index_0_id_43a8cb22_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Clients_vue_vue_type_style_index_0_id_43a8cb22_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Clients_vue_vue_type_style_index_0_id_43a8cb22_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),

/***/ "./resources/js/Pages/Login.vue?vue&type=style&index=0&id=0004d9e0&scoped=true&lang=css&":
/*!***********************************************************************************************!*\
  !*** ./resources/js/Pages/Login.vue?vue&type=style&index=0&id=0004d9e0&scoped=true&lang=css& ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Login_vue_vue_type_style_index_0_id_0004d9e0_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-style-loader/index.js!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Login.vue?vue&type=style&index=0&id=0004d9e0&scoped=true&lang=css& */ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Login.vue?vue&type=style&index=0&id=0004d9e0&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Login_vue_vue_type_style_index_0_id_0004d9e0_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Login_vue_vue_type_style_index_0_id_0004d9e0_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Login_vue_vue_type_style_index_0_id_0004d9e0_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Login_vue_vue_type_style_index_0_id_0004d9e0_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),

/***/ "./resources/js/Pages/Users.vue?vue&type=style&index=0&id=7bbfca2f&scoped=true&lang=css&":
/*!***********************************************************************************************!*\
  !*** ./resources/js/Pages/Users.vue?vue&type=style&index=0&id=7bbfca2f&scoped=true&lang=css& ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Users_vue_vue_type_style_index_0_id_7bbfca2f_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-style-loader/index.js!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Users.vue?vue&type=style&index=0&id=7bbfca2f&scoped=true&lang=css& */ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Users.vue?vue&type=style&index=0&id=7bbfca2f&scoped=true&lang=css&");
/* harmony import */ var _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Users_vue_vue_type_style_index_0_id_7bbfca2f_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Users_vue_vue_type_style_index_0_id_7bbfca2f_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Users_vue_vue_type_style_index_0_id_7bbfca2f_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_vue_style_loader_index_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Users_vue_vue_type_style_index_0_id_7bbfca2f_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);


/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Table.vue?vue&type=template&id=67955193&scoped=true&":
/*!*****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Table.vue?vue&type=template&id=67955193&scoped=true& ***!
  \*****************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "table",
    { staticClass: "w-full" },
    [
      _c(
        "tr",
        { staticClass: "text-center" },
        _vm._l(_vm.columns, function(column) {
          return _c("th", { key: column }, [
            _vm._v("\n            " + _vm._s(column) + "\n        ")
          ])
        }),
        0
      ),
      _vm._v(" "),
      _vm._l(_vm.rows, function(l, index) {
        return _c(
          "tr",
          { key: l.id, staticClass: "text-center" },
          _vm._l(_vm.keys, function(k, i) {
            return _c(
              "td",
              {
                key: i,
                staticClass: "cursor-pointer",
                class: {
                  "--active__color": !!_vm.selected && _vm.selected.id == l.id
                },
                on: {
                  click: function($event) {
                    return _vm.selectItem(l)
                  }
                }
              },
              [_c("span", [_vm._v(_vm._s(_vm.rows[index][k.label]))])]
            )
          }),
          0
        )
      })
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Toggle.vue?vue&type=template&id=96dc2142&":
/*!******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Toggle.vue?vue&type=template&id=96dc2142& ***!
  \******************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "inline-flex" },
    [
      _vm._t("default"),
      _vm._v(" "),
      _c(
        "div",
        {
          staticClass:
            "w-12 h-6 flex items-center bg-red-300 rounded-full p-1 duration-300 cursor-pointer",
          class: { "bg-green-500": _vm.value },
          attrs: { "aria-checked": _vm.value },
          on: { click: _vm.toggle }
        },
        [
          _c("div", {
            staticClass:
              "bg-white w-4 h-4 rounded-full shadow-md transform duration-300",
            class: { "translate-x-6": _vm.value }
          })
        ]
      )
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Layouts/Navigation.vue?vue&type=template&id=5b807f98&scoped=true&":
/*!*******************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Layouts/Navigation.vue?vue&type=template&id=5b807f98&scoped=true& ***!
  \*******************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "w-screen h-screen flex flex-col" }, [
    _c(
      "div",
      {
        staticClass: "w-full flex flex-row",
        staticStyle: { "background-color": "#6eafdb", height: "7%" }
      },
      [
        _vm._m(0),
        _vm._v(" "),
        _c("div", { staticStyle: { width: "93%" } }, [
          _c(
            "div",
            {
              staticClass: "float-right flex flex-row mt-6 mr-3 font-semibold"
            },
            [
              _c("div", { staticClass: "mx-5 cursor-pointer dropdown" }, [
                _vm._m(1),
                _vm._v(" "),
                _c(
                  "div",
                  {
                    staticClass:
                      "dropdown-content text-center font-medium text-sm"
                  },
                  [
                    _c(
                      "a",
                      {
                        on: {
                          click: function($event) {
                            return _vm.logout()
                          }
                        }
                      },
                      [_vm._v("Logout")]
                    )
                  ]
                )
              ]),
              _vm._v(" "),
              _c(
                "div",
                {
                  staticClass: "mx-5 cursor-pointer",
                  class: { "--active": _vm.active == "/users" },
                  on: {
                    click: function($event) {
                      return _vm.changeActive("/users")
                    }
                  }
                },
                [
                  _c("i", { staticClass: "fa-solid fa-users-gear mr-1" }),
                  _vm._v("USERS\n                ")
                ]
              ),
              _vm._v(" "),
              _c(
                "div",
                {
                  staticClass: "mx-5 cursor-pointer",
                  class: { "--active": _vm.active.includes("clients") },
                  on: {
                    click: function($event) {
                      return _vm.changeActive("/clients")
                    }
                  }
                },
                [
                  _c("i", { staticClass: "fa-solid fa-users mr-1" }),
                  _vm._v("CLIENTS\n                ")
                ]
              ),
              _vm._v(" "),
              _c(
                "div",
                {
                  staticClass: "mx-5 cursor-pointer",
                  class: { "--active": _vm.active == "/announcements" },
                  on: {
                    click: function($event) {
                      return _vm.changeActive("/announcements")
                    }
                  }
                },
                [
                  _c("i", {
                    staticClass: "fa-sharp fa-solid fa-envelopes-bulk mr-1"
                  }),
                  _vm._v("ANNOUNCEMENTS\n                ")
                ]
              )
            ]
          )
        ])
      ]
    ),
    _vm._v(" "),
    _c(
      "div",
      {
        staticClass: "w-full",
        staticStyle: { "background-color": "#ffefd2", height: "93%" }
      },
      [_vm._t("default")],
      2
    )
  ])
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticStyle: { width: "7%" } }, [
      _c("img", {
        staticClass: "py-1 px-1 cursor-pointer",
        staticStyle: { width: "100%", height: "100%", "border-radius": "50%" },
        attrs: { src: "/images/logo.jpg" }
      })
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("span", { staticClass: "dropbtn" }, [
      _c("i", { staticClass: "fa-solid fa-user mr-1" }),
      _vm._v(" PROFILE")
    ])
  }
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Bill.vue?vue&type=template&id=873580a0&scoped=true&":
/*!***********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Bill.vue?vue&type=template&id=873580a0&scoped=true& ***!
  \***********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "w-full h-screen" }, [
    _c(
      "div",
      {
        staticClass:
          "flex flex-col p-4 w-full h-screen justify-center items-center"
      },
      [
        _vm._m(0),
        _vm._v(" "),
        _c("div", { staticClass: "w-full" }, [
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.form.reference,
                expression: "form.reference"
              }
            ],
            staticClass: "w-full  my-2 --login__register--input text-center",
            attrs: { type: "text", placeholder: "Line #" },
            domProps: { value: _vm.form.reference },
            on: {
              input: function($event) {
                if ($event.target.composing) {
                  return
                }
                _vm.$set(_vm.form, "reference", $event.target.value)
              }
            }
          }),
          _vm._v(" "),
          _c("span", { staticClass: "text-xs text-red-500" }, [
            _vm._v(
              _vm._s(_vm.validationError("reference", _vm.saveError)) + " "
            )
          ])
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "w-full" }, [
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.form.amount,
                expression: "form.amount"
              }
            ],
            staticClass: "w-full  my-2 --login__register--input text-center",
            attrs: { type: "number", placeholder: "Amount" },
            domProps: { value: _vm.form.amount },
            on: {
              input: function($event) {
                if ($event.target.composing) {
                  return
                }
                _vm.$set(_vm.form, "amount", $event.target.value)
              }
            }
          }),
          _vm._v(" "),
          _c("span", { staticClass: "text-xs text-red-500" }, [
            _vm._v(_vm._s(_vm.validationError("amount", _vm.saveError)) + " ")
          ])
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "w-full" }, [
          _c(
            "button",
            {
              staticClass: "w-full  my-2 --login__register--button text-center",
              on: {
                click: function($event) {
                  return _vm.generateBill()
                }
              }
            },
            [_vm._v("\n                Submit\n            ")]
          )
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "w-full" }, [
          _c(
            "button",
            {
              staticClass: "w-full  my-2 --logout--button text-center",
              on: {
                click: function($event) {
                  return _vm.logout()
                }
              }
            },
            [_vm._v("\n                Logout\n            ")]
          )
        ])
      ]
    )
  ])
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "w-full text-center mb-5" }, [
      _c("span", { staticClass: "w-full text-2xl font-bold" }, [
        _vm._v("\n                Generate Water Bill\n            ")
      ])
    ])
  }
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Client.vue?vue&type=template&id=a794a598&":
/*!*************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Client.vue?vue&type=template&id=a794a598& ***!
  \*************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("Navigation", { attrs: { auth: _vm.auth } }, [
    _c("div", { staticClass: "w-full h-full px-2 py-2" }, [
      _c("div", { staticClass: "w-full text-2xl pt-5 px-4 cursor-pointer" }, [
        _c(
          "span",
          {
            on: {
              click: function($event) {
                return _vm.back()
              }
            }
          },
          [
            _c("i", { staticClass: "fa-solid fa-arrow-left mr-2" }),
            _vm._v(" Back\n            ")
          ]
        ),
        _vm._v(" "),
        _c("span", { staticClass: "float-right" }, [
          _vm._v(
            "\n                " +
              _vm._s(_vm.client.name) +
              " - " +
              _vm._s(_vm.client.reference) +
              "\n            "
          )
        ])
      ])
    ])
  ])
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Clients.vue?vue&type=template&id=43a8cb22&scoped=true&":
/*!**************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Clients.vue?vue&type=template&id=43a8cb22&scoped=true& ***!
  \**************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("Navigation", { attrs: { auth: _vm.auth } }, [
    _c("div", { staticClass: "w-full h-full px-2 py-2 flex flex-col" }, [
      _c("div", { staticClass: "w-full mt-3" }, [
        _c("span", { staticClass: "text-2xl ml-2 font-bold" }, [
          _c("i", { staticClass: "fa-solid fa-users mr-3" }),
          _vm._v("Clients\n            ")
        ])
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "w-full h-full mt-5 flex flex-row" }, [
        _c(
          "div",
          { staticClass: "mx-2", staticStyle: { width: "80%" } },
          [
            _c("Table", {
              attrs: {
                columns: _vm.columns,
                rows: _vm.clients,
                keys: _vm.keys,
                selected: _vm.client
              },
              on: {
                "update:selected": function($event) {
                  _vm.client = $event
                }
              }
            })
          ],
          1
        ),
        _vm._v(" "),
        !!_vm.client
          ? _c(
              "div",
              {
                staticClass: "mx-2 flex flex-col",
                staticStyle: { width: "20%" }
              },
              [
                _c(
                  "div",
                  {
                    staticClass: "py-2 px-3 flex flex-col",
                    staticStyle: {
                      width: "100%",
                      border: "1px solid black",
                      "border-radius": "5px"
                    }
                  },
                  [
                    _c("div", { staticClass: "w-full" }, [
                      _c(
                        "span",
                        {
                          staticClass: "ml-2 cursor-pointer",
                          on: {
                            click: function($event) {
                              _vm.client = null
                            }
                          }
                        },
                        [_c("i", { staticClass: "fa-solid fa-xmark" })]
                      )
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "w-full text-center" }, [
                      _c("span", { staticClass: "text-xl font-bold" }, [
                        _vm._v(
                          "\n                            " +
                            _vm._s(_vm.client.name) +
                            "\n                        "
                        )
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "w-full mt-8 pl-2" }, [
                      _c("p", { staticClass: "text-xl" }, [
                        _vm._v("\n                            Line #: "),
                        _c("span", { staticClass: "ml-2" }, [
                          _vm._v(" " + _vm._s(_vm.client.reference) + " ")
                        ])
                      ])
                    ]),
                    _vm._v(" "),
                    _c(
                      "div",
                      { staticClass: "w-full mt-4 flex flex-row pl-2" },
                      [
                        _c(
                          "div",
                          { staticClass: "w-2/12" },
                          [
                            _c("Toggle", {
                              staticClass: "pt-1",
                              attrs: {
                                value: _vm.client.is_active,
                                url: "/clients/deactivate-reactivate",
                                id: _vm.client.id
                              }
                            })
                          ],
                          1
                        ),
                        _vm._v(" "),
                        _c("div", { staticClass: "w-10/12" }, [
                          _c("span", { staticClass: "text-lg font-semibold" }, [
                            _vm._v(
                              _vm._s(
                                _vm.client.is_active
                                  ? "Disconnect"
                                  : "Reconnect"
                              )
                            )
                          ])
                        ])
                      ]
                    ),
                    _vm._v(" "),
                    _c(
                      "div",
                      { staticClass: "w-full mt-4 flex flex-row pl-2 pb-2" },
                      [
                        _c(
                          "div",
                          {
                            staticClass: "w-2/12 cursor-pointer",
                            on: {
                              click: function($event) {
                                return _vm.viewClient(_vm.client.id)
                              }
                            }
                          },
                          [_c("i", { staticClass: "fa-solid fa-eye fa-2xl" })]
                        ),
                        _vm._v(" "),
                        _c("div", { staticClass: "w-10/12" }, [
                          _c(
                            "span",
                            { staticClass: "text-lg ml-1 font-semibold" },
                            [_vm._v("View")]
                          )
                        ])
                      ]
                    )
                  ]
                )
              ]
            )
          : _c(
              "div",
              {
                staticClass: "mx-2 flex flex-col",
                staticStyle: { width: "20%" }
              },
              [
                _c(
                  "div",
                  { staticClass: "pb-3", staticStyle: { width: "100%" } },
                  [
                    _c("span", { staticClass: "text-xl" }, [
                      _c("i", { staticClass: "fa-solid fa-square-plus mr-2" }),
                      _vm._v("New Connection\n                    ")
                    ])
                  ]
                ),
                _vm._v(" "),
                _c(
                  "div",
                  {
                    staticClass: "py-5 px-3",
                    staticStyle: {
                      width: "100%",
                      border: "1px solid black",
                      "border-radius": "5px"
                    }
                  },
                  [
                    _c("div", [
                      _c("label", { attrs: { for: "name" } }, [
                        _vm._v("Name:")
                      ]),
                      _c("br"),
                      _vm._v(" "),
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.form.name,
                            expression: "form.name"
                          }
                        ],
                        staticClass: "--input py-4",
                        attrs: { type: "text", id: "name", name: "name" },
                        domProps: { value: _vm.form.name },
                        on: {
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(_vm.form, "name", $event.target.value)
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(_vm.validationError("name", _vm.saveError)) +
                            " "
                        )
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "mt-4" }, [
                      _c("label", { attrs: { for: "address" } }, [
                        _vm._v("Address:")
                      ]),
                      _c("br"),
                      _vm._v(" "),
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.form.address,
                            expression: "form.address"
                          }
                        ],
                        staticClass: "--input py-4",
                        attrs: { type: "text", id: "address", name: "address" },
                        domProps: { value: _vm.form.address },
                        on: {
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(_vm.form, "address", $event.target.value)
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(
                            _vm.validationError("address", _vm.saveError)
                          ) + " "
                        )
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "mt-6" }, [
                      _c(
                        "button",
                        {
                          staticClass: "--btn py-2",
                          on: {
                            click: function($event) {
                              return _vm.createClient()
                            }
                          }
                        },
                        [
                          _vm._v(
                            "\n                            Submit\n                        "
                          )
                        ]
                      )
                    ])
                  ]
                )
              ]
            )
      ])
    ])
  ])
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Login.vue?vue&type=template&id=0004d9e0&scoped=true&":
/*!************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Login.vue?vue&type=template&id=0004d9e0&scoped=true& ***!
  \************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "w-screen h-screen flex flex-row" }, [
    !!_vm.isLogin || !!_vm.mobile
      ? _c(
          "div",
          {
            staticClass: "flex justify-center items-center",
            staticStyle: { background: "#B0BEC5" },
            style: { width: _vm.mobile ? "100%" : "20%" }
          },
          [
            !_vm.isRegister
              ? _c(
                  "div",
                  {
                    staticClass: "mx-2",
                    staticStyle: {
                      border: "1px solid black",
                      "border-radius": "5px"
                    }
                  },
                  [
                    !_vm.mobile
                      ? _c("div", { staticClass: "w-full" }, [
                          _c(
                            "span",
                            {
                              staticClass: "float-right mr-3 cursor-pointer",
                              on: {
                                click: function($event) {
                                  _vm.isLogin = false
                                }
                              }
                            },
                            [
                              _c("i", {
                                staticClass: "fa-sharp fa-solid fa-xmark"
                              })
                            ]
                          )
                        ])
                      : _vm._e(),
                    _vm._v(" "),
                    _c("div", { staticClass: "px-2 py-2" }, [
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.formloginData.email,
                            expression: "formloginData.email"
                          }
                        ],
                        staticClass:
                          "w-full  my-2 --login__register--input text-center",
                        attrs: { type: "text", placeholder: "Email" },
                        domProps: { value: _vm.formloginData.email },
                        on: {
                          keyup: function($event) {
                            if (
                              !$event.type.indexOf("key") &&
                              _vm._k(
                                $event.keyCode,
                                "enter",
                                13,
                                $event.key,
                                "Enter"
                              )
                            ) {
                              return null
                            }
                            return _vm.login()
                          },
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(
                              _vm.formloginData,
                              "email",
                              $event.target.value
                            )
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.formloginData.password,
                            expression: "formloginData.password"
                          }
                        ],
                        staticClass:
                          "w-full mt-2 --login__register--input text-center",
                        class: { "mb-2": !_vm.message },
                        attrs: { type: "password", placeholder: "Password" },
                        domProps: { value: _vm.formloginData.password },
                        on: {
                          keyup: function($event) {
                            if (
                              !$event.type.indexOf("key") &&
                              _vm._k(
                                $event.keyCode,
                                "enter",
                                13,
                                $event.key,
                                "Enter"
                              )
                            ) {
                              return null
                            }
                            return _vm.login()
                          },
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(
                              _vm.formloginData,
                              "password",
                              $event.target.value
                            )
                          }
                        }
                      }),
                      _vm._v(" "),
                      _vm.message
                        ? _c(
                            "span",
                            { staticClass: "text-red-500 text-xs ml-2" },
                            [
                              _vm._v(
                                "\n\t\t\t\t\t" +
                                  _vm._s(_vm.message) +
                                  "\n\t\t\t\t"
                              )
                            ]
                          )
                        : _vm._e(),
                      _vm._v(" "),
                      _c(
                        "button",
                        {
                          staticClass:
                            "w-full  my-2 --login__register--button text-center",
                          class: { "cursor-not-allowed": _vm.disableButton() },
                          attrs: { disabled: _vm.disableButton() },
                          on: {
                            click: function($event) {
                              return _vm.login()
                            }
                          }
                        },
                        [_vm._v("\n\t\t\t\t\tLogin\n\t\t\t\t")]
                      ),
                      _vm._v(" "),
                      !_vm.mobile
                        ? _c(
                            "p",
                            {
                              staticClass:
                                "text-black text-sm ml-14 cursor-pointer hover:underline",
                              on: {
                                click: function($event) {
                                  _vm.isRegister = true
                                }
                              }
                            },
                            [
                              _vm._v(
                                "\n\t\t\t\t\tDoesn't have accout ? Sign Up Here!\n\t\t\t\t"
                              )
                            ]
                          )
                        : _vm._e()
                    ])
                  ]
                )
              : _c(
                  "div",
                  {
                    staticClass: "mx-2",
                    staticStyle: {
                      border: "1px solid black",
                      "border-radius": "5px"
                    }
                  },
                  [
                    _c("div", { staticClass: "w-full" }, [
                      _c(
                        "span",
                        {
                          staticClass: "float-right mr-3 cursor-pointer",
                          on: {
                            click: function($event) {
                              _vm.isLogin = false
                            }
                          }
                        },
                        [_c("i", { staticClass: "fa-sharp fa-solid fa-xmark" })]
                      )
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "px-2 py-2" }, [
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.formRegisterData.name,
                            expression: "formRegisterData.name"
                          }
                        ],
                        staticClass:
                          "w-full  my-2 --login__register--input text-center",
                        attrs: { type: "text", placeholder: "Name" },
                        domProps: { value: _vm.formRegisterData.name },
                        on: {
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(
                              _vm.formRegisterData,
                              "name",
                              $event.target.value
                            )
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(_vm.validationError("name", _vm.saveError)) +
                            " "
                        )
                      ]),
                      _vm._v(" "),
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.formRegisterData.email,
                            expression: "formRegisterData.email"
                          }
                        ],
                        staticClass:
                          "w-full  my-2 --login__register--input text-center",
                        attrs: { type: "text", placeholder: "Email" },
                        domProps: { value: _vm.formRegisterData.email },
                        on: {
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(
                              _vm.formRegisterData,
                              "email",
                              $event.target.value
                            )
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(_vm.validationError("email", _vm.saveError)) +
                            " "
                        )
                      ]),
                      _vm._v(" "),
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.formRegisterData.phone,
                            expression: "formRegisterData.phone"
                          }
                        ],
                        staticClass:
                          "w-full  my-2 --login__register--input text-center",
                        attrs: { type: "text", placeholder: "Contact" },
                        domProps: { value: _vm.formRegisterData.phone },
                        on: {
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(
                              _vm.formRegisterData,
                              "phone",
                              $event.target.value
                            )
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(_vm.validationError("phone", _vm.saveError)) +
                            " "
                        )
                      ]),
                      _vm._v(" "),
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.formRegisterData.reference,
                            expression: "formRegisterData.reference"
                          }
                        ],
                        staticClass:
                          "w-full  my-2 --login__register--input text-center",
                        attrs: { type: "text", placeholder: "Reference" },
                        domProps: { value: _vm.formRegisterData.reference },
                        on: {
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(
                              _vm.formRegisterData,
                              "reference",
                              $event.target.value
                            )
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(
                            _vm.validationError("reference", _vm.saveError)
                          ) + " "
                        )
                      ]),
                      _vm._v(" "),
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.formRegisterData.password,
                            expression: "formRegisterData.password"
                          }
                        ],
                        staticClass:
                          "w-full mt-2 --login__register--input text-center",
                        class: { "mb-2": !_vm.message },
                        attrs: { type: "password", placeholder: "Password" },
                        domProps: { value: _vm.formRegisterData.password },
                        on: {
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(
                              _vm.formRegisterData,
                              "password",
                              $event.target.value
                            )
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(
                            _vm.validationError("password", _vm.saveError)
                          ) + " "
                        )
                      ]),
                      _vm._v(" "),
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.formRegisterData.confirm_password,
                            expression: "formRegisterData.confirm_password"
                          }
                        ],
                        staticClass:
                          "w-full mt-2 --login__register--input text-center",
                        class: { "mb-2": !_vm.message },
                        attrs: {
                          type: "password",
                          placeholder: "Confirm Password"
                        },
                        domProps: {
                          value: _vm.formRegisterData.confirm_password
                        },
                        on: {
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(
                              _vm.formRegisterData,
                              "confirm_password",
                              $event.target.value
                            )
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(
                            _vm.validationError(
                              "confirm_password",
                              _vm.saveError
                            )
                          ) + " "
                        )
                      ]),
                      _vm._v(" "),
                      _c(
                        "button",
                        {
                          staticClass:
                            "w-full  my-2 --login__register--button text-center",
                          on: {
                            click: function($event) {
                              return _vm.register()
                            }
                          }
                        },
                        [_vm._v("\n\t\t\t\t\tRegister\n\t\t\t\t")]
                      ),
                      _vm._v(" "),
                      _c(
                        "p",
                        {
                          staticClass:
                            "text-black text-sm ml-14 cursor-pointer hover:underline",
                          on: {
                            click: function($event) {
                              _vm.isRegister = false
                            }
                          }
                        },
                        [
                          _vm._v(
                            "\n\t\t\t\t\tAlready have account ? Login Here!\n\t\t\t\t"
                          )
                        ]
                      )
                    ])
                  ]
                )
          ]
        )
      : _vm._e(),
    _vm._v(" "),
    !_vm.mobile
      ? _c(
          "div",
          {
            staticClass: "relative",
            style: { width: !_vm.isLogin ? "100%" : "80%" }
          },
          [
            _c("div", { staticClass: "w-full px-60 mt-10 flex flex-row" }, [
              _c(
                "div",
                {
                  staticClass: "w-full text-center cursor-pointer py-4",
                  class: { "font-bold": _vm.active == "home" },
                  staticStyle: { background: "#2596be" },
                  on: {
                    click: function($event) {
                      return _vm.changeActive("home")
                    }
                  }
                },
                [_vm._v("\n\t\t\t\tHOME\t\n\t\t\t")]
              ),
              _vm._v(" "),
              _c(
                "div",
                {
                  staticClass: "w-full text-center cursor-pointer py-4",
                  class: { "font-bold": _vm.active == "client" },
                  staticStyle: { background: "#2596be" },
                  on: {
                    click: function($event) {
                      return _vm.changeActive("client")
                    }
                  }
                },
                [_vm._v("\n\t\t\t\tCLIENT\n\t\t\t")]
              ),
              _vm._v(" "),
              _c(
                "div",
                {
                  staticClass: "w-full text-center cursor-pointer py-4",
                  class: { "font-bold": _vm.active == "about" },
                  staticStyle: { background: "#2596be" },
                  on: {
                    click: function($event) {
                      return _vm.changeActive("about")
                    }
                  }
                },
                [_vm._v("\n\t\t\t\tABOUT US\n\t\t\t")]
              ),
              _vm._v(" "),
              _c(
                "div",
                {
                  staticClass: "w-full text-center cursor-pointer py-4",
                  class: { "font-bold": _vm.active == "contact" },
                  staticStyle: { background: "#2596be" },
                  on: {
                    click: function($event) {
                      return _vm.changeActive("contact")
                    }
                  }
                },
                [_vm._v("\n\t\t\t\tCONTACT US\n\t\t\t")]
              ),
              _vm._v(" "),
              _c(
                "div",
                {
                  staticClass: "w-full text-center cursor-pointer py-4",
                  staticStyle: { background: "#2596be" },
                  on: {
                    click: function($event) {
                      _vm.isLogin = true
                    }
                  }
                },
                [_vm._v("\n\t\t\t\tLOGIN\n\t\t\t")]
              )
            ]),
            _vm._v(" "),
            _vm._m(0),
            _vm._v(" "),
            _c(
              "div",
              { staticClass: "w-full flex justify-center items-center" },
              [
                _c("div", { staticClass: "w-4/5 h-full" }, [
                  _vm.active == "client"
                    ? _c("div", { staticClass: "w-full flex flex-row" }, [
                        _vm._m(1),
                        _vm._v(" "),
                        _vm._m(2),
                        _vm._v(" "),
                        _vm._m(3)
                      ])
                    : _vm._e(),
                  _vm._v(" "),
                  _vm.active == "contact"
                    ? _c("div", { staticClass: "w-full" }, [
                        _vm._v("\n\t\t\t\t\tContact\n\t\t\t\t")
                      ])
                    : _vm._e()
                ])
              ]
            )
          ]
        )
      : _vm._e()
  ])
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
      "div",
      { staticClass: "w-full flex justify-center items-center" },
      [
        _c("div", {
          staticClass: "w-4/5 --banner",
          staticStyle: { height: "250px" }
        })
      ]
    )
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "w-full" }, [
      _c("p", { staticClass: "text-xl font-bold mb-5 mt-5 text-center" }, [
        _vm._v("\n\t\t\t\t\t\t\tAPPLICATION FOR NEW CONNECTION\n\t\t\t\t\t\t")
      ]),
      _vm._v(" "),
      _c("p", { staticClass: "mb-3" }, [
        _c("b", [_vm._v("Schedule of Availability of Service")]),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\tMonday to Friday"),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t8:00 A.M. to 5:00 P.M."),
        _c("br")
      ]),
      _vm._v(" "),
      _c("p", { staticClass: "mb-5" }, [
        _c("b", [_vm._v("Who may avail of the service?")]),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\tApplicants covered by the service areas."),
        _c("br"),
        _c("br"),
        _vm._v(" "),
        _c("b", [_vm._v("What is the requirement?")]),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t- Company I.D. "),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t- Current School I.D."),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t- Voter’s I.D."),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t- Driver’s License"),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t- Updated Postal I.D."),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t- Passport"),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t- One (1) copy any of 1×1/2×2 ID Picture"),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t- Photocopy of Brgy. Clearance"),
        _c("br"),
        _c("br"),
        _vm._v(" "),
        _c("b", [_vm._v("How to avail of the service:")]),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t1.Visit the office;"),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t2. Tell your purpose;"),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t3. Wait to be entertained by the staff;"),
        _c("br"),
        _vm._v(
          "\n\t\t\t\t\t\t\t4. Staff to advise the applicant for schedule of inspection and field survey;"
        ),
        _c("br"),
        _vm._v(
          "\n\t\t\t\t\t\t\t5. Staff to get the complete address and contact number of the applicant;"
        ),
        _c("br"),
        _vm._v(
          "\n\t\t\t\t\t\t\t6. The applicant must be sure to get list of requirements."
        ),
        _c("br")
      ])
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "w-full" }, [
      _c("p", { staticClass: "text-xl font-bold mb-5 mt-5 text-center" }, [
        _vm._v("\n\t\t\t\t\t\t\tAPPLICATION FOR RECONNECTION\n\t\t\t\t\t\t")
      ]),
      _vm._v(" "),
      _c("p", { staticClass: "mb-3" }, [
        _c("b", [_vm._v("Schedule of Availability of Service")]),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\tMonday to Friday"),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t8:00 A.M. to 5:00 P.M."),
        _c("br")
      ]),
      _vm._v(" "),
      _c("p", { staticClass: "mb-5" }, [
        _c("b", [_vm._v("Who may avail of the service?")]),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\tThose connections who were disconnected."),
        _c("br"),
        _c("br"),
        _vm._v(" "),
        _c("b", [_vm._v("What is the requirement?")]),
        _c("br"),
        _vm._v(
          "\n\t\t\t\t\t\t\tFull payment of unpaid water bills, re-connection fee and other charges if any"
        ),
        _c("br"),
        _c("br"),
        _vm._v(" "),
        _c("b", [_vm._v("How to avail of the service:")]),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t1. Visit the office;"),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t2. Tell your purpose;"),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t3. Wait to be entertained by the in-charge;"),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t4. Submit your residence certificate;"),
        _c("br"),
        _vm._v(
          "\n\t\t\t\t\t\t\t5. Staff to verify record of accounts and status of connection;"
        ),
        _c("br"),
        _vm._v(
          "\n\t\t\t\t\t\t\t6. Signing of Service Application and Construction Order and cost estimates;"
        ),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t7. Forward to the Admin for approval;"),
        _c("br"),
        _vm._v(
          "\n\t\t\t\t\t\t\t8. Payment to cashier and wait for the issuance of Official Receipt;"
        ),
        _c("br"),
        _vm._v(
          "\n\t\t\t\t\t\t\t9. Signing of Application and Agreement for Water Service Connection;"
        ),
        _c("br"),
        _vm._v(
          "\n\t\t\t\t\t\t\t10. Staff will indicate schedule of installation."
        ),
        _c("br")
      ])
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "w-full" }, [
      _c("p", { staticClass: "text-xl font-bold mb-5 mt-5 text-center" }, [
        _vm._v("\n\t\t\t\t\t\t\tAPPLICATION FOR DISCONNECTION\n\t\t\t\t\t\t")
      ]),
      _vm._v(" "),
      _c("p", { staticClass: "mb-3" }, [
        _c("b", [_vm._v("Schedule of Availability of Service")]),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\tMonday to Friday"),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t8:00 A.M. to 5:00 P.M."),
        _c("br")
      ]),
      _vm._v(" "),
      _c("p", { staticClass: "mb-5" }, [
        _c("b", [_vm._v("Who may avail of the service?")]),
        _c("br"),
        _vm._v(
          "\n\t\t\t\t\t\t\tThose who wish to temporarily disconnect their water service installed through\n\t\t\t\t\t\t\tpull-out water meter due to any valid reason that service needs to be disconnected.\n\t\t\t\t\t\t\t"
        ),
        _c("br"),
        _c("br"),
        _vm._v(" "),
        _c("b", [_vm._v("What is the requirement?")]),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\tRequest for disconnection of service line."),
        _c("br"),
        _vm._v(
          "\n\t\t\t\t\t\t\tFull payment of outstanding water bills and materials under Promissory Note if any"
        ),
        _c("br"),
        _c("br"),
        _vm._v(" "),
        _c("b", [_vm._v("How to avail of the service:")]),
        _c("br"),
        _vm._v(
          "\n\t\t\t\t\t\t\t1.Proceeds to customer service and requests disconnection"
        ),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t2.Signs Disconnection Logbook"),
        _c("br"),
        _vm._v(
          "\n\t\t\t\t\t\t\t3. Pays all unpaid water bills and other charges under installment scheme (if any)"
        ),
        _c("br"),
        _vm._v("\n\t\t\t\t\t\t\t4. Accepts work done, signs Maintenance Order"),
        _c("br")
      ])
    ])
  }
]
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Users.vue?vue&type=template&id=7bbfca2f&scoped=true&":
/*!************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Users.vue?vue&type=template&id=7bbfca2f&scoped=true& ***!
  \************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "staticRenderFns": () => (/* binding */ staticRenderFns)
/* harmony export */ });
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("Navigation", { attrs: { auth: _vm.auth } }, [
    _c("div", { staticClass: "w-full h-full px-2 py-2 flex flex-col" }, [
      _c("div", { staticClass: "w-full mt-3" }, [
        _c("span", { staticClass: "text-2xl ml-2 font-bold" }, [
          _c("i", { staticClass: "fa-solid fa-users mr-3" }),
          _vm._v("Users \n            ")
        ]),
        _vm._v(" "),
        _c(
          "span",
          {
            staticClass: "text-xl mr-2 font-bold float-right cursor-pointer",
            on: {
              click: function($event) {
                _vm.newUser = true
              }
            }
          },
          [_c("i", { staticClass: "fa-sharp fa-solid fa-user-plus" })]
        )
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "w-full h-full mt-5 flex flex-row" }, [
        _c(
          "div",
          {
            staticClass: "mx-2",
            style: { width: _vm.newUser ? "80%" : "100%" }
          },
          [
            _c("Table", {
              attrs: {
                columns: _vm.columns,
                rows: _vm.users,
                keys: _vm.keys,
                selected: _vm.user
              },
              on: {
                "update:selected": function($event) {
                  _vm.user = $event
                }
              }
            })
          ],
          1
        ),
        _vm._v(" "),
        _vm.newUser
          ? _c(
              "div",
              { staticClass: "mx-2 h-full", staticStyle: { width: "20%" } },
              [
                _c(
                  "div",
                  {
                    staticClass: "h-auto flex flex-col",
                    staticStyle: {
                      border: "1px solid black",
                      "border-radius": "10px"
                    }
                  },
                  [
                    _c("div", { staticClass: "w-full" }, [
                      _c(
                        "span",
                        {
                          staticClass: "ml-2 mt-2 cursor-pointer",
                          on: {
                            click: function($event) {
                              _vm.newUser = false
                            }
                          }
                        },
                        [_c("i", { staticClass: "fa-solid fa-xmark" })]
                      )
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "w-full px-4 p-2" }, [
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.formRegisterData.name,
                            expression: "formRegisterData.name"
                          }
                        ],
                        staticClass:
                          "w-full  my-2 --login__register--input text-center",
                        attrs: { type: "text", placeholder: "Name" },
                        domProps: { value: _vm.formRegisterData.name },
                        on: {
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(
                              _vm.formRegisterData,
                              "name",
                              $event.target.value
                            )
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(_vm.validationError("name", _vm.saveError)) +
                            " "
                        )
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "w-full px-4 p-2" }, [
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.formRegisterData.phone,
                            expression: "formRegisterData.phone"
                          }
                        ],
                        staticClass:
                          "w-full  my-2 --login__register--input text-center",
                        attrs: { type: "text", placeholder: "Contact" },
                        domProps: { value: _vm.formRegisterData.phone },
                        on: {
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(
                              _vm.formRegisterData,
                              "phone",
                              $event.target.value
                            )
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(_vm.validationError("phone", _vm.saveError)) +
                            " "
                        )
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "w-full px-4 p-2" }, [
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.formRegisterData.email,
                            expression: "formRegisterData.email"
                          }
                        ],
                        staticClass:
                          "w-full  my-2 --login__register--input text-center",
                        attrs: { type: "text", placeholder: "Email" },
                        domProps: { value: _vm.formRegisterData.email },
                        on: {
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(
                              _vm.formRegisterData,
                              "email",
                              $event.target.value
                            )
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(_vm.validationError("email", _vm.saveError)) +
                            " "
                        )
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "w-full px-4 p-2" }, [
                      _c(
                        "select",
                        {
                          directives: [
                            {
                              name: "model",
                              rawName: "v-model",
                              value: _vm.formRegisterData.user_type,
                              expression: "formRegisterData.user_type"
                            }
                          ],
                          staticClass:
                            "w-full text-center my-2 --login__register--input",
                          on: {
                            change: function($event) {
                              var $$selectedVal = Array.prototype.filter
                                .call($event.target.options, function(o) {
                                  return o.selected
                                })
                                .map(function(o) {
                                  var val = "_value" in o ? o._value : o.value
                                  return val
                                })
                              _vm.$set(
                                _vm.formRegisterData,
                                "user_type",
                                $event.target.multiple
                                  ? $$selectedVal
                                  : $$selectedVal[0]
                              )
                            }
                          }
                        },
                        [
                          _c("option", { attrs: { value: "staff" } }, [
                            _vm._v("Staff")
                          ]),
                          _vm._v(" "),
                          _c("option", { attrs: { value: "reader" } }, [
                            _vm._v("Reader")
                          ]),
                          _vm._v(" "),
                          _c("option", { attrs: { value: "utility" } }, [
                            _vm._v("Utility")
                          ])
                        ]
                      ),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(
                            _vm.validationError("user_type", _vm.saveError)
                          ) + " "
                        )
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "w-full px-4 p-2" }, [
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.formRegisterData.password,
                            expression: "formRegisterData.password"
                          }
                        ],
                        staticClass:
                          "w-full  my-2 --login__register--input text-center",
                        attrs: { type: "password", placeholder: "Password" },
                        domProps: { value: _vm.formRegisterData.password },
                        on: {
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(
                              _vm.formRegisterData,
                              "password",
                              $event.target.value
                            )
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(
                            _vm.validationError("password", _vm.saveError)
                          ) + " "
                        )
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "w-full px-4 p-2" }, [
                      _c("input", {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.formRegisterData.confirm_password,
                            expression: "formRegisterData.confirm_password"
                          }
                        ],
                        staticClass:
                          "w-full  my-2 --login__register--input text-center",
                        attrs: {
                          type: "password",
                          placeholder: "Confirm Password"
                        },
                        domProps: {
                          value: _vm.formRegisterData.confirm_password
                        },
                        on: {
                          input: function($event) {
                            if ($event.target.composing) {
                              return
                            }
                            _vm.$set(
                              _vm.formRegisterData,
                              "confirm_password",
                              $event.target.value
                            )
                          }
                        }
                      }),
                      _vm._v(" "),
                      _c("span", { staticClass: "text-xs text-red-500" }, [
                        _vm._v(
                          _vm._s(
                            _vm.validationError(
                              "confirm_password",
                              _vm.saveError
                            )
                          ) + " "
                        )
                      ])
                    ]),
                    _vm._v(" "),
                    _c("div", { staticClass: "w-full px-4 p-2" }, [
                      _c(
                        "button",
                        {
                          staticClass:
                            "w-full --login__register--button text-center",
                          on: {
                            click: function($event) {
                              return _vm.createAccount()
                            }
                          }
                        },
                        [
                          _vm._v(
                            "\n                            Submit\n                        "
                          )
                        ]
                      )
                    ])
                  ]
                )
              ]
            )
          : _vm._e()
      ])
    ])
  ])
}
var staticRenderFns = []
render._withStripped = true



/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ normalizeComponent)
/* harmony export */ });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Table.vue?vue&type=style&index=0&id=67955193&scoped=true&lang=css&":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Table.vue?vue&type=style&index=0&id=67955193&scoped=true&lang=css& ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Table.vue?vue&type=style&index=0&id=67955193&scoped=true&lang=css& */ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Components/Table.vue?vue&type=style&index=0&id=67955193&scoped=true&lang=css&");
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! !../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("2704e71d", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Layouts/Navigation.vue?vue&type=style&index=0&id=5b807f98&scoped=true&lang=css&":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Layouts/Navigation.vue?vue&type=style&index=0&id=5b807f98&scoped=true&lang=css& ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Navigation.vue?vue&type=style&index=0&id=5b807f98&scoped=true&lang=css& */ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Layouts/Navigation.vue?vue&type=style&index=0&id=5b807f98&scoped=true&lang=css&");
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! !../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("3041f67c", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Bill.vue?vue&type=style&index=0&id=873580a0&scoped=true&lang=css&":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Bill.vue?vue&type=style&index=0&id=873580a0&scoped=true&lang=css& ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Bill.vue?vue&type=style&index=0&id=873580a0&scoped=true&lang=css& */ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Bill.vue?vue&type=style&index=0&id=873580a0&scoped=true&lang=css&");
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! !../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("0c78aa54", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Clients.vue?vue&type=style&index=0&id=43a8cb22&scoped=true&lang=css&":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Clients.vue?vue&type=style&index=0&id=43a8cb22&scoped=true&lang=css& ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Clients.vue?vue&type=style&index=0&id=43a8cb22&scoped=true&lang=css& */ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Clients.vue?vue&type=style&index=0&id=43a8cb22&scoped=true&lang=css&");
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! !../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("9fc0ea46", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Login.vue?vue&type=style&index=0&id=0004d9e0&scoped=true&lang=css&":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Login.vue?vue&type=style&index=0&id=0004d9e0&scoped=true&lang=css& ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Login.vue?vue&type=style&index=0&id=0004d9e0&scoped=true&lang=css& */ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Login.vue?vue&type=style&index=0&id=0004d9e0&scoped=true&lang=css&");
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! !../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("20b41c50", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Users.vue?vue&type=style&index=0&id=7bbfca2f&scoped=true&lang=css&":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-style-loader/index.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Users.vue?vue&type=style&index=0&id=7bbfca2f&scoped=true&lang=css& ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !!../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Users.vue?vue&type=style&index=0&id=7bbfca2f&scoped=true&lang=css& */ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/Pages/Users.vue?vue&type=style&index=0&id=7bbfca2f&scoped=true&lang=css&");
if(content.__esModule) content = content.default;
if(typeof content === 'string') content = [[module.id, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var add = __webpack_require__(/*! !../../../node_modules/vue-style-loader/lib/addStylesClient.js */ "./node_modules/vue-style-loader/lib/addStylesClient.js").default
var update = add("432e25d1", content, false, {});
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/vue-style-loader/lib/addStylesClient.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/addStylesClient.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addStylesClient)
/* harmony export */ });
/* harmony import */ var _listToStyles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./listToStyles */ "./node_modules/vue-style-loader/lib/listToStyles.js");
/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/



var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}
var options = null
var ssrIdKey = 'data-vue-ssr-id'

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

function addStylesClient (parentId, list, _isProduction, _options) {
  isProduction = _isProduction

  options = _options || {}

  var styles = (0,_listToStyles__WEBPACK_IMPORTED_MODULE_0__.default)(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = (0,_listToStyles__WEBPACK_IMPORTED_MODULE_0__.default)(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[' + ssrIdKey + '~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }
  if (options.ssrId) {
    styleElement.setAttribute(ssrIdKey, obj.id)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ "./node_modules/vue-style-loader/lib/listToStyles.js":
/*!***********************************************************!*\
  !*** ./node_modules/vue-style-loader/lib/listToStyles.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ listToStyles)
/* harmony export */ });
/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),

/***/ "./node_modules/vue/dist/vue.esm.js":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.esm.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*!
 * Vue.js v2.6.12
 * (c) 2014-2020 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive.
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

function isPromise (val) {
  return (
    isDef(val) &&
    typeof val.then === 'function' &&
    typeof val.catch === 'function'
  )
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array.
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */
var identity = function (_) { return _; };

/**
 * Generate a string containing static keys from compiler modules.
 */
function genStaticKeys (modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || [])
  }, []).join(',')
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime()
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
];

/*  */



var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof __webpack_require__.g !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/(function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  if ( true && !config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) { return a.id - b.id; });
  }
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];

function pushTarget (target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget () {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(),
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if ( true && customSetter) {
        customSetter();
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) { return }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if ( true &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
     true && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;

  var keys = hasSymbol
    ? Reflect.ownKeys(from)
    : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    // in case the object is already observed...
    if (key === '__ob__') { continue }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (
      toVal !== fromVal &&
      isPlainObject(toVal) &&
      isPlainObject(fromVal)
    ) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
       true && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  var res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal;
  return res
    ? dedupeHooks(res)
    : res
}

function dedupeHooks (hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
     true && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  if (true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'should conform to valid custom element name in html5 specification.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else if (true) {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];
      if (typeof def$$1 === 'function') {
        dirs[key] = { bind: def$$1, update: def$$1 };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ( true && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */



function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  if (
    true
  ) {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ( true && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(
      getInvalidTypeMessage(name, value, expectedTypes),
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

function getInvalidTypeMessage (name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
    " Expected " + (expectedTypes.map(capitalize).join(', '));
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType);
  // check if we need to specify expected value
  if (expectedTypes.length === 1 &&
      isExplicable(expectedType) &&
      !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }
  message += ", got " + receivedType + " ";
  // check if we need to specify received value
  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }
  return message
}

function styleValue (value, type) {
  if (type === 'String') {
    return ("\"" + value + "\"")
  } else if (type === 'Number') {
    return ("" + (Number(value)))
  } else {
    return ("" + value)
  }
}

function isExplicable (value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })
}

function isBoolean () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
}

/*  */

function handleError (err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while ((cur = cur.$parent)) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) { return }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling (
  handler,
  context,
  args,
  vm,
  info
) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
      // issue #9511
      // avoid catch triggering multiple times when nested calls
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  if (true) {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */

var isUsingMicroTask = false;

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function () {
    p.then(flushCallbacks);
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      // perf.clearMeasures(name)
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (true) {
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var warnReservedPrefix = function (target, key) {
    warn(
      "Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " +
      'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
      'prevent conflicts with Vue internals. ' +
      'See: https://vuejs.org/v2/api/#data',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) ||
        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
      if (!has && !isAllowed) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns, vm) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  createOnceHandler,
  vm
) {
  var name, def$$1, cur, old, event;
  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
       true && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }
      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      } else {}
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject)
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      // #6574 in case the inject object is observed...
      if (key === '__ob__') { continue }
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else if (true) {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  if (!children || !children.length) {
    return {}
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

/*  */

function normalizeScopedSlots (
  slots,
  normalSlots,
  prevSlots
) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized
  } else if (
    isStable &&
    prevSlots &&
    prevSlots !== emptyObject &&
    key === prevSlots.$key &&
    !hasNormalSlots &&
    !prevSlots.$hasNormal
  ) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  // expose normal slots on scopedSlots
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  }
  // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error
  if (slots && Object.isExtensible(slots)) {
    (slots)._normalized = res;
  }
  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res)
      ? [res] // single vnode
      : normalizeChildren(res);
    return res && (
      res.length === 0 ||
      (res.length === 1 && res[0].isComment) // #9658
    ) ? undefined
      : res
  };
  // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized
}

function proxyNormalSlot(slots, key) {
  return function () { return slots[key]; }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  (ret)._isVList = true;
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if ( true && !isObject(bindObject)) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
       true && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
       true && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function resolveScopedSlots (
  fns, // see flow/vnode
  res,
  // the following are added in 2.6
  hasDynamicKeys,
  contentHashKey
) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    (res).$key = contentHashKey;
  }
  return res
}

/*  */

function bindDynamicKeys (baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if ( true && key !== '' && key !== null) {
      // null is a special value for explicitly removing a binding
      warn(
        ("Invalid value for dynamic directive argument (expected string or null): " + key),
        this
      );
    }
  }
  return baseObj
}

// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier (value, symbol) {
  return typeof value === 'string' ? symbol + value : value
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var this$1 = this;

  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(
        data.scopedSlots,
        this$1.$slots = resolveSlots(children, parent)
      );
    }
    return this$1.$slots
  };

  Object.defineProperty(this, 'scopedSlots', ({
    enumerable: true,
    get: function get () {
      return normalizeScopedSlots(data.scopedSlots, this.slots())
    }
  }));

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (true) {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

/*  */

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (true) {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1 (f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input'
  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (
      Array.isArray(existing)
        ? existing.indexOf(callback) === -1
        : existing !== callback
    ) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
     true && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if ( true &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      );
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if ( true && isDef(data) && isDef(data.nativeOn)) {
        warn(
          ("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">."),
          context
        );
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (true) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {}
}

var currentRenderingInstance = null;

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      );
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if ( true && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ( true && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null

    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        (owners[i]).$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });

    var reject = once(function (reason) {
       true && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;
            if (isUndef(factory.resolved)) {
              reject(
                 true
                  ? ("timeout (" + (res.timeout) + "ms)")
                  : 0
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn) {
  target.$on(event, fn);
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function createOnceHandler (event, fn) {
  var _target = target;
  return function onceHandler () {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  }
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm
  };
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  }
}

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (true) {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ( true && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before: function before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  if (true) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.

  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(
    (newScopedSlots && !newScopedSlots.$stable) ||
    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)
  );

  // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.
  var needsForceUpdate = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    hasDynamicScopedSlot
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}

// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;

// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;

// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
  var performance = window.performance;
  if (
    performance &&
    typeof performance.now === 'function' &&
    getNow() > document.createEvent('Event').timeStamp
  ) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () { return performance.now(); };
  }
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ( true && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;

      if ( true && !config.async) {
        flushSchedulerQueue();
        return
      }
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */



var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true
    ? expOrFn.toString()
    : 0;
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = noop;
       true && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (true) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    } else {}
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
     true && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
       true && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if ( true && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if ( true &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (typeof methods[key] !== 'function') {
        warn(
          "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  if (true) {
    dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\""));
      }
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    if (true) {
      initProxy(vm);
    } else {}
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if ( true && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = latest[key];
    }
  }
  return modified
}

function Vue (options) {
  if ( true &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if ( true && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if ( true && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */



function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  if (true) {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  // 2.6 explicit observable API
  Vue.observable = function (obj) {
    observe(obj);
    return obj
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.6.12';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false'
    ? 'false'
    // allow arbitrary string value for contenteditable
    : key === 'contenteditable' && isValidContentEditableValue(value)
      ? value
      : 'true'
};

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isPreTag = function (tag) { return tag === 'pre'; };

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
       true && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setStyleScope (node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1 (vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }

  var creatingElmInVPre = 0;

  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if ( true && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (true) {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (true) {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys (children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn(
            ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
            vnode.context
          );
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    if (oldVnode === vnode) {
      return
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (true) {
          checkDuplicateKeys(ch);
        }
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || (data && data.pre);
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true
    }
    // assert node match
    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ( true &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ( true &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else if (true) {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes([oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr (el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (
      isIE && !isIE9 &&
      el.tagName === 'TEXTAREA' &&
      key === 'placeholder' && value !== '' && !el.__ieph
    ) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters (exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
    } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // "
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        var j = i - 1;
        var p = (void 0);
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') { break }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression
}

function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args))
  }
}

/*  */



/* eslint-disable no-unused-vars */
function baseWarn (msg, range) {
  console.error(("[Vue compiler]: " + msg));
}
/* eslint-enable no-unused-vars */

function pluckModuleFunction (
  modules,
  key
) {
  return modules
    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
    : []
}

function addProp (el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

function addAttr (el, name, value, range, dynamic) {
  var attrs = dynamic
    ? (el.dynamicAttrs || (el.dynamicAttrs = []))
    : (el.attrs || (el.attrs = []));
  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

// add a raw attr (use this in preTransforms)
function addRawAttr (el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));
}

function addDirective (
  el,
  name,
  rawName,
  value,
  arg,
  isDynamicArg,
  modifiers,
  range
) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker (symbol, name, dynamic) {
  return dynamic
    ? ("_p(" + name + ",\"" + symbol + "\")")
    : symbol + name // mark the event as captured
}

function addHandler (
  el,
  name,
  value,
  modifiers,
  important,
  warn,
  range,
  dynamic
) {
  modifiers = modifiers || emptyObject;
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (
     true && warn &&
    modifiers.prevent && modifiers.passive
  ) {
    warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.',
      range
    );
  }

  // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.
  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  }

  // check capture modifier
  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }
  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */
  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;
  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr (
  el,
  name
) {
  return el.rawAttrsMap[':' + name] ||
    el.rawAttrsMap['v-bind:' + name] ||
    el.rawAttrsMap[name]
}

function getBindingAttr (
  el,
  name,
  getStatic
) {
  var dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue)
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue)
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr (
  el,
  name,
  removeFromMap
) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val
}

function getAndRemoveAttrByRegex (
  el,
  name
) {
  var list = el.attrsList;
  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];
    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr
    }
  }
}

function rangeSetItem (
  item,
  range
) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }
    if (range.end != null) {
      item.end = range.end;
    }
  }
  return item
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel (
  el,
  value,
  modifiers
) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression =
      "(typeof " + baseValueExpression + " === 'string'" +
      "? " + baseValueExpression + ".trim()" +
      ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: ("(" + value + ")"),
    expression: JSON.stringify(value),
    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode (
  value,
  assignment
) {
  var res = parseModel(value);
  if (res.key === null) {
    return (value + "=" + assignment)
  } else {
    return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len, str, chr, index$1, expressionPos, expressionEndPos;



function parseModel (val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      }
    } else {
      return {
        exp: val,
        key: null
      }
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  }
}

function next () {
  return str.charCodeAt(++index$1)
}

function eof () {
  return index$1 >= len
}

function isStringStart (chr) {
  return chr === 0x22 || chr === 0x27
}

function parseBracket (chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue
    }
    if (chr === 0x5B) { inBracket++; }
    if (chr === 0x5D) { inBracket--; }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break
    }
  }
}

function parseString (chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model (
  el,
  dir,
  _warn
) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (true) {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
        "File inputs are read only. Use a v-on:change listener instead.",
        el.rawAttrsMap['v-model']
      );
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (true) {
    warn$1(
      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
      "v-model is not supported on this element type. " +
      'If you are working with contenteditable, it\'s recommended to ' +
      'wrap a library dedicated for that purpose inside a custom component.',
      el.rawAttrsMap['v-model']
    );
  }

  // ensure runtime directive metadata
  return true
}

function genCheckboxModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked',
    "Array.isArray(" + value + ")" +
    "?_i(" + value + "," + valueBinding + ")>-1" + (
      trueValueBinding === 'true'
        ? (":(" + value + ")")
        : (":_q(" + value + "," + trueValueBinding + ")")
    )
  );
  addHandler(el, 'change',
    "var $$a=" + value + "," +
        '$$el=$event.target,' +
        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
    'if(Array.isArray($$a)){' +
      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
          '$$i=_i($$a,$$v);' +
      "if($$el.checked){$$i<0&&(" + (genAssignmentCode(value, '$$a.concat([$$v])')) + ")}" +
      "else{$$i>-1&&(" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + ")}" +
    "}else{" + (genAssignmentCode(value, '$$c')) + "}",
    null, true
  );
}

function genRadioModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" +
    ".call($event.target.options,function(o){return o.selected})" +
    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
    "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + (genAssignmentCode(value, assignment));
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel (
  el,
  value,
  modifiers
) {
  var type = el.attrsMap.type;

  // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type
  if (true) {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(
        binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " +
        'because the latter already expands to a value binding internally',
        el.rawAttrsMap[binding]
      );
    }
  }

  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy
    ? 'change'
    : type === 'range'
      ? RANGE_TOKEN
      : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', ("(" + value + ")"));
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1 (event, handler, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1 (
  name,
  handler,
  capture,
  passive
) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;
    handler = original._wrapper = function (e) {
      if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        e.target === e.currentTarget ||
        // event is fired after handler attachment
        e.timeStamp >= attachedTimestamp ||
        // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        e.timeStamp <= 0 ||
        // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        e.target.ownerDocument !== document
      ) {
        return original.apply(this, arguments)
      }
    };
  }
  target$1.addEventListener(
    name,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  name,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    name,
    handler._wrapper || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

var svgContainer;

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;
      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }
      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if (
      // skip the update if old and new VDOM state is the same.
      // `value` is handled separately because the DOM value may be temporarily
      // out of sync with VDOM state due to focus, composition and modifiers.
      // This  #4521 by skipping the unnecessary `checked` update.
      cur !== oldProps[key]
    ) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isNotInFocusAndDirty(elm, checkVal) ||
    isDirtyWithModifiers(elm, checkVal)
  ))
}

function isNotInFocusAndDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal)
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim()
    }
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (
        childNode && childNode.data &&
        (styleData = normalizeStyleData(childNode.data))
      ) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

var whitespaceRE = /\s+/;

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def$$1) {
  if (!def$$1) {
    return
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  // JSDOM may return undefined for transition properties
  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs (s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if ( true && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if ( true && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
     true && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

var isVShowDirective = function (d) { return d.name === 'show'; };

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(isNotTextNode);
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if ( true && children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if ( true &&
      mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  beforeMount: function beforeMount () {
    var this$1 = this;

    var update = this._update;
    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1);
      // force removing pass
      this$1.__patch__(
        this$1._vnode,
        this$1.kept,
        false, // hydrating
        true // removeOnly (!important, avoids unnecessary moves)
      );
      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (e && e.target !== el) {
            return
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (
        true
      ) {
        console[console.info ? 'info' : 'log'](
          'Download the Vue Devtools extension for a better development experience:\n' +
          'https://github.com/vuejs/vue-devtools'
        );
      }
    }
    if ( true &&
      config.productionTip !== false &&
      typeof console !== 'undefined'
    ) {
      console[console.info ? 'info' : 'log'](
        "You are running Vue in development mode.\n" +
        "Make sure to turn on production mode when deploying for production.\n" +
        "See more tips at https://vuejs.org/guide/deployment.html"
      );
    }
  }, 0);
}

/*  */

var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
});



function parseText (
  text,
  delimiters
) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return
  }
  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;
  while ((match = tagRE.exec(text))) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push(("_s(" + exp + ")"));
    rawTokens.push({ '@binding': exp });
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }
  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  }
}

/*  */

function transformNode (el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if ( true && staticClass) {
    var res = parseText(staticClass, options.delimiters);
    if (res) {
      warn(
        "class=\"" + staticClass + "\": " +
        'Interpolation inside attributes has been removed. ' +
        'Use v-bind or the colon shorthand instead. For example, ' +
        'instead of <div class="{{ val }}">, use <div :class="val">.',
        el.rawAttrsMap['class']
      );
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData (el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + (el.staticClass) + ",";
  }
  if (el.classBinding) {
    data += "class:" + (el.classBinding) + ",";
  }
  return data
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1 (el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (true) {
      var res = parseText(staticStyle, options.delimiters);
      if (res) {
        warn(
          "style=\"" + staticStyle + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div style="{{ val }}">, use <div :style="val">.',
          el.rawAttrsMap['style']
        );
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1 (el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + (el.staticStyle) + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + (el.styleBinding) + "),";
  }
  return data
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

/*  */

var decoder;

var he = {
  decode: function decode (html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent
  }
};

/*  */

var isUnaryTag = makeMap(
  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
  'link,meta,param,source,track,wbr'
);

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap(
  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
);

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap(
  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
  'title,tr,track'
);

/**
 * Not type-checking this file because it's mostly vendor code.
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + (unicodeRegExp.source) + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp(("^<" + qnameCapture));
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
var doctype = /^<!DOCTYPE [^>]+>/i;
// #7298: escape - to avoid being passed as HTML comment when inlined in page
var comment = /^<!\--/;
var conditionalComment = /^<!\[/;

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

function decodeAttr (value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) { return decodingMap[match]; })
}

function parseHTML (html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }
            advance(commentEnd + 3);
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }
          continue
        }
      }

      var text = (void 0), rest = (void 0), next = (void 0);
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) { break }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return ''
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if ( true && !stack.length && options.warn) {
        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""), { start: index + html.length });
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance (n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag () {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match
      }
    }
  }

  function handleStartTag (match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
      if ( true && options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag (tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) { start = index; }
    if (end == null) { end = index; }

    // Find the closest opened tag of the same type
    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if ( true &&
          (i > pos || !tagName) &&
          options.warn
        ) {
          options.warn(
            ("tag <" + (stack[i].tag) + "> has no matching end tag."),
            { start: stack[i].start, end: stack[i].end }
          );
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:|^#/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;

var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;

var slotRE = /^v-slot(:|$)|^#/;

var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /\s+/g;

var invalidAttributeRE = /[\s"'<>\/=]/;

var decodeHTMLCached = cached(he.decode);

var emptySlotScopeToken = "_empty_";

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement (
  tag,
  attrs,
  parent
) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  }
}

/**
 * Convert HTML string to AST.
 */
function parse (
  template,
  options
) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;
  maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce (msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement (element) {
    trimEndingWhitespace(element);
    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    }
    // tree management
    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        if (true) {
          checkRootConstraints(element);
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else if (true) {
        warnOnce(
          "Component template should contain exactly one root element. " +
          "If you are using v-if on multiple elements, " +
          "use v-else-if to chain them instead.",
          { start: element.start }
        );
      }
    }
    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"'
          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }
        currentParent.children.push(element);
        element.parent = currentParent;
      }
    }

    // final children cleanup
    // filter out scoped slots
    element.children = element.children.filter(function (c) { return !(c).slotScope; });
    // remove trailing whitespace node again
    trimEndingWhitespace(element);

    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
    // apply post-transforms
    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace (el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;
      while (
        (lastNode = el.children[el.children.length - 1]) &&
        lastNode.type === 3 &&
        lastNode.text === ' '
      ) {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints (el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce(
        "Cannot use <" + (el.tag) + "> as component root element because it may " +
        'contain multiple nodes.',
        { start: el.start }
      );
    }
    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce(
        'Cannot use v-for on stateful component root element because ' +
        'it renders multiple elements.',
        el.rawAttrsMap['v-for']
      );
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start (tag, attrs, unary, start$1, end) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (true) {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.end = end;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated
          }, {});
        }
        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2(
              "Invalid dynamic argument expression: attribute names cannot contain " +
              "spaces, quotes, <, >, / or =.",
              {
                start: attr.start + attr.name.indexOf("["),
                end: attr.start + attr.name.length
              }
            );
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
         true && warn$2(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          "<" + tag + ">" + ', as they will not be parsed.',
          { start: element.start }
        );
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;
        if (true) {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },

    end: function end (tag, start, end$1) {
      var element = stack[stack.length - 1];
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      if ( true && options.outputSourceRange) {
        element.end = end$1;
      }
      closeElement(element);
    },

    chars: function chars (text, start, end) {
      if (!currentParent) {
        if (true) {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.',
              { start: start }
            );
          } else if ((text = text.trim())) {
            warnOnce(
              ("text \"" + text + "\" outside root element will be ignored."),
              { start: start }
            );
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      var children = currentParent.children;
      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }
      if (text) {
        if (!inPre && whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }
        var res;
        var child;
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }
        if (child) {
          if ( true && options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }
          children.push(child);
        }
      }
    },
    comment: function comment (text, start, end) {
      // adding anything as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };
        if ( true && options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }
        currentParent.children.push(child);
      }
    }
  });
  return root
}

function processPre (el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs (el) {
  var list = el.attrsList;
  var len = list.length;
  if (len) {
    var attrs = el.attrs = new Array(len);
    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };
      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement (
  element,
  options
) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = (
    !element.key &&
    !element.scopedSlots &&
    !element.attrsList.length
  );

  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
  return element
}

function processKey (el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if (true) {
      if (el.tag === 'template') {
        warn$2(
          "<template> cannot be keyed. Place the key on real elements instead.",
          getRawBindingAttr(el, 'key')
        );
      }
      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;
        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2(
            "Do not use v-for index as key on <transition-group> children, " +
            "this is the same as not using keys.",
            getRawBindingAttr(el, 'key'),
            true /* tip */
          );
        }
      }
    }
    el.key = exp;
  }
}

function processRef (el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor (el) {
  var exp;
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    var res = parseFor(exp);
    if (res) {
      extend(el, res);
    } else if (true) {
      warn$2(
        ("Invalid v-for expression: " + exp),
        el.rawAttrsMap['v-for']
      );
    }
  }
}



function parseFor (exp) {
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) { return }
  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);
  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }
  return res
}

function processIf (el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions (el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (true) {
    warn$2(
      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
      "used on element <" + (el.tag) + "> without corresponding v-if.",
      el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']
    );
  }
}

function findPrevElement (children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i]
    } else {
      if ( true && children[i].text !== ' ') {
        warn$2(
          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
          "will be ignored.",
          children[i]
        );
      }
      children.pop();
    }
  }
}

function addIfCondition (el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce (el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

// handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">
function processSlotContent (el) {
  var slotScope;
  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */
    if ( true && slotScope) {
      warn$2(
        "the \"scope\" attribute for scoped slots have been deprecated and " +
        "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
        "can also be used on plain elements in addition to <template> to " +
        "denote scoped slots.",
        el.rawAttrsMap['scope'],
        true
      );
    }
    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
    /* istanbul ignore if */
    if ( true && el.attrsMap['v-for']) {
      warn$2(
        "Ambiguous combined usage of slot-scope and v-for on <" + (el.tag) + "> " +
        "(v-for takes higher priority). Use a wrapper <template> for the " +
        "scoped slot to make it clearer.",
        el.rawAttrsMap['slot-scope'],
        true
      );
    }
    el.slotScope = slotScope;
  }

  // slot="xxx"
  var slotTarget = getBindingAttr(el, 'slot');
  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
    // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.
    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  }

  // 2.6 v-slot syntax
  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding) {
        if (true) {
          if (el.slotTarget || el.slotScope) {
            warn$2(
              "Unexpected mixed usage of different slot syntaxes.",
              el
            );
          }
          if (el.parent && !maybeComponent(el.parent)) {
            warn$2(
              "<template v-slot> can only appear at the root level inside " +
              "the receiving component",
              el
            );
          }
        }
        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding$1) {
        if (true) {
          if (!maybeComponent(el)) {
            warn$2(
              "v-slot can only be used on components or <template>.",
              slotBinding$1
            );
          }
          if (el.slotScope || el.slotTarget) {
            warn$2(
              "Unexpected mixed usage of different slot syntaxes.",
              el
            );
          }
          if (el.scopedSlots) {
            warn$2(
              "To avoid scope ambiguity, the default slot should also use " +
              "<template> syntax when there are other named slots.",
              slotBinding$1
            );
          }
        }
        // add the component's children to its default slot
        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;
        // remove children as they are returned from scopedSlots now
        el.children = [];
        // mark el non-plain so data gets generated
        el.plain = false;
      }
    }
  }
}

function getSlotName (binding) {
  var name = binding.name.replace(slotRE, '');
  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else if (true) {
      warn$2(
        "v-slot shorthand syntax requires a slot name.",
        binding
      );
    }
  }
  return dynamicArgRE.test(name)
    // dynamic [name]
    ? { name: name.slice(1, -1), dynamic: true }
    // static name
    : { name: ("\"" + name + "\""), dynamic: false }
}

// handle <slot/> outlets
function processSlotOutlet (el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if ( true && el.key) {
      warn$2(
        "`key` does not work on <slot> because slots are abstract outlets " +
        "and can possibly expand into multiple elements. " +
        "Use the key on a wrapping element instead.",
        getRawBindingAttr(el, 'key')
      );
    }
  }
}

function processComponent (el) {
  var binding;
  if ((binding = getBindingAttr(el, 'is'))) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs (el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name.replace(dirRE, ''));
      // support .foo shorthand syntax for the .prop modifier
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) { // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        if (
           true &&
          value.trim().length === 0
        ) {
          warn$2(
            ("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"")
          );
        }
        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);
            if (name === 'innerHtml') { name = 'innerHTML'; }
          }
          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");
            if (!isDynamic) {
              addHandler(
                el,
                ("update:" + (camelize(name))),
                syncGen,
                null,
                false,
                warn$2,
                list[i]
              );
              if (hyphenate(name) !== camelize(name)) {
                addHandler(
                  el,
                  ("update:" + (hyphenate(name))),
                  syncGen,
                  null,
                  false,
                  warn$2,
                  list[i]
                );
              }
            } else {
              // handler w/ dynamic event name
              addHandler(
                el,
                ("\"update:\"+(" + name + ")"),
                syncGen,
                null,
                false,
                warn$2,
                list[i],
                true // dynamic
              );
            }
          }
        }
        if ((modifiers && modifiers.prop) || (
          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) { // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else { // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }
        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
        if ( true && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (true) {
        var res = parseText(value, delimiters);
        if (res) {
          warn$2(
            name + "=\"" + value + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div id="{{ val }}">, use <div :id="val">.',
            list[i]
          );
        }
      }
      addAttr(el, name, JSON.stringify(value), list[i]);
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
      if (!el.component &&
          name === 'muted' &&
          platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor (el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true
    }
    parent = parent.parent;
  }
  return false
}

function parseModifiers (name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) { ret[m.slice(1)] = true; });
    return ret
  }
}

function makeAttrsMap (attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (
       true &&
      map[attrs[i].name] && !isIE && !isEdge
    ) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag (el) {
  return el.tag === 'script' || el.tag === 'style'
}

function isForbiddenTag (el) {
  return (
    el.tag === 'style' ||
    (el.tag === 'script' && (
      !el.attrsMap.type ||
      el.attrsMap.type === 'text/javascript'
    ))
  )
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug (attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res
}

function checkForAliasModel (el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "You are binding v-model directly to a v-for iteration alias. " +
        "This will not be able to modify the v-for source array because " +
        "writing to the alias is like modifying a function local variable. " +
        "Consider using an array of objects and use v-model on an object property instead.",
        el.rawAttrsMap['v-model']
      );
    }
    _el = _el.parent;
  }
}

/*  */

function preTransformNode (el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (!map['v-model']) {
      return
    }

    var typeBinding;
    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }
    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + (map['v-bind']) + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0
    }
  }
}

function cloneASTElement (el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent)
}

var model$1 = {
  preTransformNode: preTransformNode
};

var modules$1 = [
  klass$1,
  style$1,
  model$1
];

/*  */

function text (el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"), dir);
  }
}

/*  */

function html (el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"), dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize (root, options) {
  if (!root) { return }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1 (keys) {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
    (keys ? ',' + keys : '')
  )
}

function markStatic$1 (node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots (node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true;
      return
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic (node) {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}

function isDirectChildOfTemplateFor (node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false
    }
    if (node.for) {
      return true
    }
  }
  return false
}

/*  */

var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

// KeyboardEvent.keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// KeyboardEvent.key aliases
var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers (
  events,
  isNative
) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";
  for (var name in events) {
    var handlerCode = genHandler(events[name]);
    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }
  staticHandlers = "{" + (staticHandlers.slice(0, -1)) + "}";
  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + (dynamicHandlers.slice(0, -1)) + "])"
  } else {
    return prefix + staticHandlers
  }
}

function genHandler (handler) {
  if (!handler) {
    return 'function(){}'
  }

  if (Array.isArray(handler)) {
    return ("[" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + "]")
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value
    }
    return ("function($event){" + (isFunctionInvocation ? ("return " + (handler.value)) : handler.value) + "}") // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = (handler.modifiers);
        genModifierCode += genGuard(
          ['ctrl', 'shift', 'alt', 'meta']
            .filter(function (keyModifier) { return !modifiers[keyModifier]; })
            .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
            .join('||')
        );
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath
      ? ("return " + (handler.value) + "($event)")
      : isFunctionExpression
        ? ("return (" + (handler.value) + ")($event)")
        : isFunctionInvocation
          ? ("return " + (handler.value))
          : handler.value;
    return ("function($event){" + code + handlerCode + "}")
  }
}

function genKeyFilter (keys) {
  return (
    // make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" +
    (keys.map(genFilterCode).join('&&')) + ")return null;"
  )
}

function genFilterCode (key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return ("$event.keyCode!==" + keyVal)
  }
  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return (
    "_k($event.keyCode," +
    (JSON.stringify(key)) + "," +
    (JSON.stringify(keyCode)) + "," +
    "$event.key," +
    "" + (JSON.stringify(keyName)) +
    ")"
  )
}

/*  */

function on (el, dir) {
  if ( true && dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
}

/*  */

function bind$1 (el, dir) {
  el.wrapData = function (code) {
    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */





var CodegenState = function CodegenState (options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };
  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};



function generate (
  ast,
  options
) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: ("with(this){return " + code + "}"),
    staticRenderFns: state.staticRenderFns
  }
}

function genElement (el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;
      if (!el.plain || (el.pre && state.maybeComponent(el))) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code
  }
}

// hoist static sub-trees out
function genStatic (el, state) {
  el.staticProcessed = true;
  // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.
  var originalPreState = state.pre;
  if (el.pre) {
    state.pre = el.pre;
  }
  state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
  state.pre = originalPreState;
  return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
}

// v-once
function genOnce (el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break
      }
      parent = parent.parent;
    }
    if (!key) {
       true && state.warn(
        "v-once can only be used inside v-for that is keyed. ",
        el.rawAttrsMap['v-once']
      );
      return genElement(el, state)
    }
    return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
  } else {
    return genStatic(el, state)
  }
}

function genIf (
  el,
  state,
  altGen,
  altEmpty
) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions,
  state,
  altGen,
  altEmpty
) {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
  } else {
    return ("" + (genTernaryExp(condition.block)))
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}

function genFor (
  el,
  state,
  altGen,
  altHelper
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

  if ( true &&
    state.maybeComponent(el) &&
    el.tag !== 'slot' &&
    el.tag !== 'template' &&
    !el.key
  ) {
    state.warn(
      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
      "v-for should have explicit keys. " +
      "See https://vuejs.org/guide/list.html#key for more info.",
      el.rawAttrsMap['v-for'],
      true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + ((altGen || genElement)(el, state)) +
    '})'
}

function genData$2 (el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) { data += dirs + ','; }

  // key
  if (el.key) {
    data += "key:" + (el.key) + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + (el.ref) + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + (el.tag) + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:" + (genProps(el.attrs)) + ",";
  }
  // DOM props
  if (el.props) {
    data += "domProps:" + (genProps(el.props)) + ",";
  }
  // event handlers
  if (el.events) {
    data += (genHandlers(el.events, false)) + ",";
  }
  if (el.nativeEvents) {
    data += (genHandlers(el.nativeEvents, true)) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + (el.slotTarget) + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += (genScopedSlots(el, el.scopedSlots, state)) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.
  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + (el.tag) + "\"," + (genProps(el.dynamicAttrs)) + ")";
  }
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data
}

function genDirectives (el, state) {
  var dirs = el.directives;
  if (!dirs) { return }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:" + (dir.isDynamicArg ? dir.arg : ("\"" + (dir.arg) + "\""))) : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']'
  }
}

function genInlineTemplate (el, state) {
  var ast = el.children[0];
  if ( true && (
    el.children.length !== 1 || ast.type !== 1
  )) {
    state.warn(
      'Inline-template components must have exactly one child element.',
      { start: el.start }
    );
  }
  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
  }
}

function genScopedSlots (
  el,
  slots,
  state
) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return (
      slot.slotTargetDynamic ||
      slot.if ||
      slot.for ||
      containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    )
  });

  // #9534: if a component with scoped slots is inside a conditional branch,
  // it's possible for the same component to be reused but with different
  // compiled slot content. To avoid that, we generate a unique key based on
  // the generated code of all the slot contents.
  var needsKey = !!el.if;

  // OR when it is inside another scoped slot or v-for (the reactivity may be
  // disconnected due to the intermediate scope variable)
  // #9438, #9506
  // TODO: this can be further optimized by properly analyzing in-scope bindings
  // and skip force updating ones that do not actually use scope variables.
  if (!needsForceUpdate) {
    var parent = el.parent;
    while (parent) {
      if (
        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||
        parent.for
      ) {
        needsForceUpdate = true;
        break
      }
      if (parent.if) {
        needsKey = true;
      }
      parent = parent.parent;
    }
  }

  var generatedSlots = Object.keys(slots)
    .map(function (key) { return genScopedSlot(slots[key], state); })
    .join(',');

  return ("scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? (",null,false," + (hash(generatedSlots))) : "") + ")")
}

function hash(str) {
  var hash = 5381;
  var i = str.length;
  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }
  return hash >>> 0
}

function containsSlotChild (el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true
    }
    return el.children.some(containsSlotChild)
  }
  return false
}

function genScopedSlot (
  el,
  state
) {
  var isLegacySyntax = el.attrsMap['slot-scope'];
  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null")
  }
  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot)
  }
  var slotScope = el.slotScope === emptySlotScopeToken
    ? ""
    : String(el.slotScope);
  var fn = "function(" + slotScope + "){" +
    "return " + (el.tag === 'template'
      ? el.if && isLegacySyntax
        ? ("(" + (el.if) + ")?" + (genChildren(el, state) || 'undefined') + ":undefined")
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)) + "}";
  // reverse proxy v-slot without scope on this.$slots
  var reverseProxy = slotScope ? "" : ",proxy:true";
  return ("{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}")
}

function genChildren (
  el,
  state,
  checkSkip,
  altGenElement,
  altGenNode
) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 &&
      el$1.for &&
      el$1.tag !== 'template' &&
      el$1.tag !== 'slot'
    ) {
      var normalizationType = checkSkip
        ? state.maybeComponent(el$1) ? ",1" : ",0"
        : "";
      return ("" + ((altGenElement || genElement)(el$1, state)) + normalizationType)
    }
    var normalizationType$1 = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0;
    var gen = altGenNode || genNode;
    return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType$1 ? ("," + normalizationType$1) : ''))
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType (
  children,
  maybeComponent
) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue
    }
    if (needsNormalization(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
      res = 2;
      break
    }
    if (maybeComponent(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
      res = 1;
    }
  }
  return res
}

function needsNormalization (el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
}

function genNode (node, state) {
  if (node.type === 1) {
    return genElement(node, state)
  } else if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

function genText (text) {
  return ("_v(" + (text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
}

function genComment (comment) {
  return ("_e(" + (JSON.stringify(comment.text)) + ")")
}

function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? ("," + children) : '');
  var attrs = el.attrs || el.dynamicAttrs
    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({
        // slot props are camelized
        name: camelize(attr.name),
        value: attr.value,
        dynamic: attr.dynamic
      }); }))
    : null;
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')'
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent (
  componentName,
  el,
  state
) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
}

function genProps (props) {
  var staticProps = "";
  var dynamicProps = "";
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);
    if (prop.dynamic) {
      dynamicProps += (prop.name) + "," + value + ",";
    } else {
      staticProps += "\"" + (prop.name) + "\":" + value + ",";
    }
  }
  staticProps = "{" + (staticProps.slice(0, -1)) + "}";
  if (dynamicProps) {
    return ("_d(" + staticProps + ",[" + (dynamicProps.slice(0, -1)) + "])")
  } else {
    return staticProps
  }
}

// #3895, #4268
function transformSpecialNewlines (text) {
  return text
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
}

/*  */



// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors (ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode (node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          var range = node.rawAttrsMap[name];
          if (name === 'v-for') {
            checkFor(node, ("v-for=\"" + value + "\""), warn, range);
          } else if (name === 'v-slot' || name[0] === '#') {
            checkFunctionParameterExpression(value, (name + "=\"" + value + "\""), warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, (name + "=\"" + value + "\""), warn, range);
          } else {
            checkExpression(value, (name + "=\"" + value + "\""), warn, range);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent (exp, text, warn, range) {
  var stripped = exp.replace(stripStringRE, '');
  var keywordMatch = stripped.match(unaryOperatorsRE);
  if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
    warn(
      "avoid using JavaScript unary operator as property name: " +
      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim()),
      range
    );
  }
  checkExpression(exp, text, warn, range);
}

function checkFor (node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier (
  ident,
  type,
  text,
  warn,
  range
) {
  if (typeof ident === 'string') {
    try {
      new Function(("var " + ident + "=_"));
    } catch (e) {
      warn(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())), range);
    }
  }
}

function checkExpression (exp, text, warn, range) {
  try {
    new Function(("return " + exp));
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      warn(
        "avoid using JavaScript keyword as property name: " +
        "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim()),
        range
      );
    } else {
      warn(
        "invalid expression: " + (e.message) + " in\n\n" +
        "    " + exp + "\n\n" +
        "  Raw expression: " + (text.trim()) + "\n",
        range
      );
    }
  }
}

function checkFunctionParameterExpression (exp, text, warn, range) {
  try {
    new Function(exp, '');
  } catch (e) {
    warn(
      "invalid function parameter expression: " + (e.message) + " in\n\n" +
      "    " + exp + "\n\n" +
      "  Raw expression: " + (text.trim()) + "\n",
      range
    );
  }
}

/*  */

var range = 2;

function generateCodeFrame (
  source,
  start,
  end
) {
  if ( start === void 0 ) start = 0;
  if ( end === void 0 ) end = source.length;

  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];
  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;
    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) { continue }
        res.push(("" + (j + 1) + (repeat$1(" ", 3 - String(j + 1).length)) + "|  " + (lines[j])));
        var lineLength = lines[j].length;
        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat$1("^", length$1));
          }
          count += lineLength + 1;
        }
      }
      break
    }
  }
  return res.join('\n')
}

function repeat$1 (str, n) {
  var result = '';
  if (n > 0) {
    while (true) { // eslint-disable-line
      if (n & 1) { result += str; }
      n >>>= 1;
      if (n <= 0) { break }
      str += str;
    }
  }
  return result
}

/*  */



function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop
  }
}

function createCompileToFunctionFn (compile) {
  var cache = Object.create(null);

  return function compileToFunctions (
    template,
    options,
    vm
  ) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    if (true) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          );
        }
      }
    }

    // check cache
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key]
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (true) {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1(
              "Error compiling template:\n\n" + (e.msg) + "\n\n" +
              generateCodeFrame(template, e.start, e.end),
              vm
            );
          });
        } else {
          warn$$1(
            "Error compiling template:\n\n" + template + "\n\n" +
            compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
            vm
          );
        }
      }
      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) { return tip(e.msg, vm); });
        } else {
          compiled.tips.forEach(function (msg) { return tip(msg, vm); });
        }
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (true) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1(
          "Failed to generate render function:\n\n" +
          fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return ((err.toString()) + " in\n\n" + code + "\n");
        }).join('\n'),
          vm
        );
      }
    }

    return (cache[key] = res)
  }
}

/*  */

function createCompilerCreator (baseCompile) {
  return function createCompiler (baseOptions) {
    function compile (
      template,
      options
    ) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if ( true && options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = { msg: msg };
            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }
              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }
            (tip ? tips : errors).push(data);
          };
        }
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          );
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;

      var compiled = baseCompile(template.trim(), finalOptions);
      if (true) {
        detectErrors(compiled.ast, warn);
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
  var ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    optimize(ast, options);
  }
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compile = ref$1.compile;
var compileToFunctions = ref$1.compileToFunctions;

/*  */

// check whether current browser encodes a char inside attribute values
var div;
function getShouldDecode (href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0
}

// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML
});

var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
     true && warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if ( true && !template) {
            warn(
              ("Template element not found or is empty: " + (options.template)),
              this
            );
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (true) {
          warn('invalid template option:' + template, this);
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if ( true && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if ( true && config.performance && mark) {
        mark('compile end');
        measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating)
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el) {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}

Vue.compile = compileToFunctions;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Vue);


/***/ }),

/***/ "?4f7e":
/*!********************************!*\
  !*** ./util.inspect (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					result = fn();
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			for(moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) var result = runtime(__webpack_require__);
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/css/app.css")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;